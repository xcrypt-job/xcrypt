# Sample of DC.pm module (Divide and Conquer)
# Compute Fib(n) by dividing a job for Fib(n) into jobs for Fib(n-1) and Fib(n-2) recursively
use base qw(DC core);

# Returns 1 (true) if the $job can be divided into equivalent multiple jobs.
# Returns 0 (false) otherwise.
sub can_divde
{
	$job = shift;
	print "User function"."\n";
	if($job->{arg0_0} > 10)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

# Divides $job into equivalent multiple jobs and returns an array of them.
sub divide
{
	my $job = shift;
	print "User Function divide"."\n";

	my %j1 = (
		'id' => $job->{id}."_".($job->{arg0_0}-1),
		'exe0' => $job->{exe0},
		'arg0_0' => $job->{arg0_0}-1,
		'canDivideFunc' => $job->{canDivideFunc},
		'divideFunc' => $job->{divideFunc},
		'mergeFunc' => $job->{mergeFunc},
	);
	my %j2 = (
		'id' => $job->{id}."_".($job->{arg0_0}-2),
		'exe0' => $job->{exe0},
		'arg0_0' => $job->{arg0_0}-2,
		'canDivideFunc' => $job->{canDivideFunc},
		'divideFunc' => $job->{divideFunc},
		'mergeFunc' => $job->{mergeFunc},
	);
	my @children = ();
	push(@children, prepare(%j1));
	push(@children, prepare(%j2));
	return @children;
}

# Merges the results of @children jobs as the result of the $parent job.
sub merge
{
	my ($parent, @children) = @_;
	print "User Function merge"."\n";
	my $val = 0;
	foreach my $child (@children)
	{
		open(FH,"<".$children->{JS_stdout});
		my $line = <FH>;
                chomp ($line);
		$val += $line;
		print $line."\n";
		close(FH);
	}
        my $ofname = $parent->{JS_stdout};
	print $ofname."\n";
	open(OUT,">".$ofname);
	print OUT $val;
	close(OUT);
}

%template = (
    'id' => 'job0',
    'exe0' => "$ENV{'XCRYPT'}/sample/DC/fib.out",
    'arg0_0' => 13,
    'canDivideFunc' => \&can_divde,
    'divideFunc' => \&divide,
    'mergeFunc' => \&merge,
);

@results = &prepare_submit_sync(%template);
#foreach (@results) { print $_->{stdout} , "\n"; }
#print "---------------\n";
