#!/usr/bin/env perl

my %val;
open(TREE, "< $ARGV[2]");
my $line = <TREE>;
my @array = split(' ', $line);
%val = @array;
close(TREE);

#my $word = &alphabeta((- (2 ** 31) + 1), ((2 ** 31) - 1), @ARGV);
my $word = &alphabeta((- (2 ** 31) + 1), ((2 ** 31) - 1), $ARGV[0], $ARGV[1],
		      (- (2 ** 31) + 1), ((2 ** 31) - 1));
print $word;

sub isMyTurn { # Int -> Bool
    if ($_[0] == 0) {
	return 1;
    } else {
	my $i = 0;
	while (2 ** ($i + 1) - 2 < $_[0]) { $i = $i + 1; }
	return ($i + 1) % 2;
    }
}

#!/usr/bin/env perl

sub getchildren {
#    my $foo = 2 * $_[0] + 1;
#    my $bar = 2 * $_[0] + 2;
    my $num = 100;
    my @bar;
    foreach (1..$num) {
	my $foo = $num * $_[0] + $_;
	push(@bar, $foo);
    }
    return join(' ', @bar);
}

sub inverse {
    return (10000000 / $_[0]);
}

sub alphabeta {
    my ($inf, $sup, $depth, $pos, $alpha, $beta,
	$getchildren,  $staticevaluation) = @_;

#    my $gc ='./' . $getchildren;
#    my $pre_children = qx/$gc $pos/;
    my $pre_children = &getchildren($pos);
    my @children = split(/ /, $pre_children);
    if (($depth == 0) || ($#children == -1)) {
#	my $se ='./' . $staticevaluation;
#	my $result = qx/$se $pos/;
#	my $result = &inverse($pos);
	my $result = $val{"$pos"};
	return $result;
    }
    my $max = $inf;
    my $min = $sup;
    if (isMyTurn($pos)) {
	foreach (@children) {
	    my $score = alphabeta($max, $min, ($depth - 1), $_, $alpha, $beta,
				$getchildren, $staticevaluation);
	    if ($alpha <= $score) {
		$alpha = $score;}
	    if ($beta <= $alpha) {
		return $beta;
	    }
	    if ($score > $max) { $max = $score; }
	}
	return $max;
    } else {
	foreach (@children) {
	    my $score = alphabeta($max, $min, ($depth - 1), $_, $alpha, $beta,
				$getchildren, $staticevaluation);
	    if ($score <= $beta) {
		$beta = $score;
	    }
	    if ($beta <= $alpha) {
		return $alpha;
	    }
	    if ($score < $min) { $min = $score; }
	}
     return $min;
    }
}
