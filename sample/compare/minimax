#!/usr/bin/env perl

my $branch = 4;

my %val;
open(TREE, "< $ARGV[2]");
my $line = <TREE>;
my @array = split(' ', $line);
%val = @array;
close(TREE);

my $word = &minimax((- (2 ** 31) + 1), ((2 ** 31) - 1), @ARGV);
print $word;

sub isMyTurn { # Int -> Bool
    my $i = 1;
    while ((($branch ** $i - 1) / 3) <= $_[0]) { $i = $i + 1; }
    return ($i) % 2;
}

sub getchildren {
    my @bar;
    foreach (1..$branch) {
	my $foo = $branch * $_[0] + $_;
	push(@bar, $foo);
    }
    return join(' ', @bar);
}

sub inverse {
    return (10000000 / $_[0]);
}

sub minimax {
    my ($inf, $sup, $depth, $pos, $staticevaluation, $getchildren) = @_;

#    my $gc ='./' . $getchildren;
#    my $pre_children = qx/$gc $pos/;
    my $pre_children = &getchildren($pos);
    my @children = split(/ /, $pre_children);
    if (($depth == 0) || ($#children == -1)) {
	my $se ='./' . $staticevaluation;
	my $result = qx/$se $pos/;
#	my $result = &inverse($pos);
#	my $result = int(rand(1000));
#	my $result = $val{"$pos"};
	return $result;
    }
    my $max = $inf;
    my $min = $sup;
    if (isMyTurn($pos)) {
	foreach (@children) {
	    my $score = minimax($max, $min, ($depth - 1), $_,
				$staticevaluation, $getchildren);
	    if ($score > $max) { $max = $score; }
	}
	return $max;
    } else {
	foreach (@children) {
	    my $score = minimax($max, $min, ($depth - 1), $_,
				$staticevaluation, $getchildren);
	    if ($score < $min) { $min = $score; }
	}
     return $min;
    }
}

