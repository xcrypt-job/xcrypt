use base qw(sandbox limit core);
use data_generator;
use data_extractor;
&limit::initialize(10);

%template = (
    'exe0' => 'cd ./hpl; make arch=Linux_ATHLON_FBLAS clean_arch_all',
    'exe1' => 'make arch=Linux_ATHLON_FBLAS; cd -',
    'exe2' => 'mpiexec -n ${QSUB_VNODES} ./hpl/bin/Linux_ATHLON_FBLAS/xhpl',
    'JS_queue' => 'gh10034',
    'JS_group' => 'gh10034',
    'JS_cpu' => 1,
    'copiedfile0' => 'hpl',
    'JS_node'  => 4,					# P x Q = # of proc.
);

# Indicate sweep ranges
@copts = ("-O2", "-O3");	# Compile option
@pmaps = (0, 1);		# PMAP process mapping
@pblks = (2, 4);		# Value of P

$preid = "hpljob_";

foreach my $copt (@copts) {
  foreach my $pmap (@pmaps) {
    foreach my $pblk (@pblks) {
      $template{'id'} = $preid . $copt . "_" . $pmap . "_" . $pblk;
      my @job = &prepare(%template);
      my $self = $job[0];

    #before
      # Generate Makefile
      my $hplmake = data_generator
                 -> new("hpl/Make.Linux_ATHLON_FBLAS",
                        $self->{workdir} . "/hpl/Make.Linux_ATHLON_FBLAS");
      $hplmake -> replace_key_value ("TOPdir",
                      "$ENV{'PWD'}/" . $self->{workdir} . "/hpl");
      $hplmake -> replace_line_column(171, 4, $copt);
      $hplmake -> execute();
      # Generate input file
      my $hpldat = data_generator -> new("HPL.dat",
                                         $self->{workdir} . "/HPL.dat");
      $hpldat -> replace_line_column ( 9, 1, $pmap); # take one of RANGE1
      $hpldat -> replace_line_column (11, 1, $pblk); # take one of RANGE2
      $hpldat -> replace_line_column (12, 1, $self->{'JS_node'}/$pblk);
      $hpldat -> execute();

      @results = &submit_sync(@job);

    #after
      # Wait for stdout to be outputed
      sleep(2);
      # Extract performance value
      my $stdout_file = $self->{workdir} . "/$self->{id}_stdout";
      my $stdout = data_extractor->new($stdout_file);
      $stdout -> extract_line_rn (['PASSED',-2]);
      $stdout -> extract_line_nn (1);
      $stdout -> extract_column_nn (7);
      @performance = $stdout -> execute();
      print $performance[0], "\n";
      # Examine the best performance
      if ( $performance[0] > $max_performance ) {
          $max_performance = $performance[0];
          $max_performance_dir = $self->{workdir};
          $coption = $copt;
          my $stdout = data_extractor -> new($stdout_file);
          $stdout -> extract_line_rn(['following parameter',18]);
          $stdout -> extract_line_nn([3,18]);
          @parameters = $stdout -> execute();
      }
    }
  }
}

# Output of final result
print "\n", "-------- RESULT -------- \n\n";
print "Maximum performance is\n\n" . $max_performance . " Gflops,\n\n";
print "when the following compile options and parameter values are used:\n";
print "(corresponding working directory is " . $max_performance_dir . " )\n\n";
print "Compile options : " . $coption . "\n";
foreach $parameter ( @parameters ) {
    print $parameter, "\n";
}
print "\n";
