#!/usr/bin/env perl
package xcrypt;

use strict;
use Cwd;
use File::Copy;
use File::Spec;
use File::Temp qw/tempfile/;
use File::Basename;
use Getopt::Long qw(:config pass_through);
use Data::Dumper;

my $localhost = qx/hostname/;
chomp $localhost;
my $username = qx/whoami/;
chomp $username;
my $wd = Cwd::getcwd();

our %options = (
#    'localhost' => $localhost,  # Obsolete
    'host' => $username . '@' . $localhost,
    'wd' => $wd,
    'xd' => $ENV{XCRYPT},
#    'p5l' => $ENV{PERL5LIB},
    'sched' => $ENV{XCRJOBSCHED},
    'queue' => $ENV{XCRQUEUE},
    #
#    'port' => 0, # インベントリ通知待ち受けポート．0ならNFS経由  # Obsolete
#    'comm_timeout' => 60, # timeout for inventory_write.pl       # Obsolete
    'abort_check_interval' => 19, # abortになったジョブをチェックする間隔(sec)
    'left_message_check_interval' => 3, # ジョブスクリプトが残したメッセージをチェックする間隔(sec)
    'inventory_path' => 'inv_watch',
    #
    'verbose' => 0,               # verbose level
    'stack_size' => 32768,        # Perlスレッドのスタックサイズ
    # define other default values...
    );

GetOptions
    (\%options,
     'compile_only',
     'print_log',
     'xbs-auto',
     'xbs-site=s',
     'shared',
     'scratch',
     #
#     'localhost=s',  # Obsolete
     'host=s',
     'wd=s',
     'xd=s',
#     'p5l=s',
     'sched=s',
     'queue=s',
     #
#     'port=i',         # Obsolete
#     'comm_timeout=i', # Obsolete
     'abort_check_interval=i',
     'left_message_check_interval=i',
     'inventory_path=s',
     #
     'verbose=i',
     'stack_size=i',
     # define other command-line options...
    );

if (defined $options{'xbs-auto'}) {
    $options{'xbs-site'} = $options{sched};
}
if (defined $options{'xbs-site'}) {
    $options{sched} = 'XBS';
}

my $xcrfile;
my @argv;
foreach my $i (@ARGV) {
    if ($i =~ /\.xcr\Z/) {
	$xcrfile = $i;
    } elsif ($i eq '--') {
    } else {
	push(@argv, $i);
    }
}
@ARGV = @argv;
if (File::Spec->catfile(basename($xcrfile)) !~ /\.xcr\Z/) {
    die "The file extension should be .xcr\n";
}

my $added_path = File::Spec->catfile($ENV{XCRYPT}, 'lib') . ':'
    . File::Spec->catfile($ENV{XCRYPT}, 'lib', 'algo', 'lib') . ':'
    . File::Spec->catfile($ENV{XCRYPT}, 'lib', 'cpan') . ':'
    . File::Spec->catfile($options{inventory_path});
if (defined $ENV{PERL5LIB}) {
    $ENV{PERL5LIB} = $ENV{PERL5LIB} . ':' . $added_path;
} else {
    $ENV{PERL5LIB} = $added_path;
}

mkdir $options{inventory_path}, 0755;
my($HEADER, $tmp_filename) = tempfile( 'tempXXXXX', DIR => "$options{inventory_path}", SUFFIX => '.pm' );
print $HEADER 'package xcropt;' . "\n";
my $dumper = Data::Dumper->Dump([\%options],['options_tmp']);
print $HEADER 'my ' . $dumper . "\n";
print $HEADER 'our %options = %$options_tmp;' . "\n";
print $HEADER '1;' . "\n";
close($HEADER);
until (-e $tmp_filename) {
    sleep 2;
    print "a header file is being generated, please wait...\n";
}
open(my $USER, "<", $xcrfile) or die "Can't open $xcrfile\n";
my @header = split(/\.pm/, File::Spec->catfile(basename($tmp_filename)));
my $TMP;
if (defined $options{compile_only}) {
    open($TMP , ">", $xcrfile . '.pl') or die $!;
} else {
    open($TMP , "| perl -m$header[0] - " . join(' ', @ARGV)) or die $!;
}
print $TMP 'package user;' . "\n";
print $TMP 'use builtin;' . "\n";
print $TMP 'use Coro;' . "\n";
print $TMP 'use jobsched;' . "\n";
print $TMP 'use data_generator;' . "\n";
print $TMP 'use data_extractor;' . "\n";
print $TMP 'our @VALUE = ();' . "\n";
print $TMP 'sub before_in_xcrypt {local ($self, @VALUE) = @_; if ($self->{before_in_xcrypt}) {&{$self->{before_in_xcrypt}}($self, @VALUE)};}' . "\n";
print $TMP 'sub before {local ($self, @VALUE) = @_; if ($self->{before}) {&{$self->{before}}($self, @VALUE)};}' . "\n";
print $TMP 'sub start  {my $self = shift;$self->SUPER::start();}' . "\n";
print $TMP 'sub after  {local ($self, @VALUE) = @_; if ($self->{after} ) {&{$self->{after}}($self, @VALUE)};}' . "\n";
print $TMP 'sub after_in_xcrypt  {local ($self, @VALUE) = @_; if ($self->{after_in_xcrypt} ) {&{$self->{after_in_xcrypt}}($self, @VALUE)};}' . "\n";
print $TMP '$SIG{INT} = sub {(bless{},"user")->EVERY::sigint_handler(); print "Xcrypt is aborted by SIGINT.\n"; exit(1);};'. "\n";
print $TMP '# Up to here Xcrypt\'s header.  From here your script.' . "\n";
print $TMP 'unless ($xcropt::options{scratch}) { &jobsched::read_log(); }' . "\n";
print $TMP '&jobsched::invoke_abort_check();' . "\n";
print $TMP '&jobsched::invoke_left_message_check();' . "\n";
#print $TMP '&jobsched::invoke_watch();' . "\n";
print $TMP '$builtin::env_d = &add_host({"host" => $xcropt::options{host}, "wd" => $xcropt::options{wd}, "sched" => $xcropt::options{sched}, "xd" => $xcropt::options{xd}, "queue" => $xcropt::options{queue}});' . "\n";
foreach (<$USER>) { print $TMP "$_"; }
print $TMP '# Up to here your script.  From here Xcrypt\'s footer.' . "\n";
close($TMP);
close($USER);

#my $exitcode = system("perl -m$header[0] $xcrfile.pl " . join(' ', @ARGV));
#unless ($exitcode == 0) { die "Can't perl $xcrfile.pl\n"; }

#unlink $tmp_filename;
