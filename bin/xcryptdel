#!/usr/bin/env perl
package jobsched;

use strict;
use Cwd;
use File::Basename;
use File::Spec;
use Getopt::Long;

my %opts = ();
GetOptions(\%opts, 'all');

##############################
sub cmd_executable {
    my ($cmd) = @_;
    my @cmd0 = split(/\s+/,$cmd);
    qx/which $cmd0[0]/;
    my $ex_code = $? >> 8;
    # print "$? $ex_code ";
    return ($ex_code==0)? 1 : 0;
}
##############################

my $write_command = undef;
my $inventory_port = 9999;
if ($inventory_port > 0) {
    $write_command=File::Spec->catfile($ENV{'XCRYPT'}, 'bin', 'inventory_write_sock.pl');
} else {
    $write_command=File::Spec->catfile($ENV{'XCRYPT'}, 'bin', 'pjo_inventory_write.pl');
}

# Load jobscheduler config files.
my $jobsched = undef;
my $jobsched_config_dir = undef;
our %jobsched_config = undef;
if ( $ENV{XCRYPT} ) {
    $jobsched_config_dir = File::Spec->catfile ($ENV{XCRYPT}, 'lib', 'config');
} else {
    die "Set the environment varialble XCRYPT\n";
}
unless ( $ENV{XCRJOBSCHED} ) {
    die "Set the environment varialble XCRJOBSCHED.\n";
} else {
    $jobsched = $ENV{XCRJOBSCHED};
    unless ( -f File::Spec->catfile ($jobsched_config_dir, $jobsched . ".pm") ) {
        die "No config file for $jobsched ($jobsched.pm) in $jobsched_config_dir";
    }
}
foreach ( glob (File::Spec->catfile ($jobsched_config_dir, "*" . ".pm")) ) {
    do $_;
}

# Get qdel command
my $qdel_command = $jobsched_config{$jobsched}{qdel_command};
unless ( defined $qdel_command ) {
    die "qdel_command is not defined in $jobsched.pm";
}
unless (cmd_executable ($qdel_command)) {
    die "$qdel_command not executable";
}

# Get request ID from jobname
if ($opts{'all'}) {
    my $current_directory=Cwd::getcwd();
    my $inventory_path=File::Spec->catfile($current_directory, 'inv_watch');
    my $idfiles = File::Spec->catfile($inventory_path, '.request_ids');
    open ( REQIDS, "< $idfiles" );
    my $reqid_jobids = <REQIDS>;
    my @reqid_jobids_array = split(/ /, $reqid_jobids);
    my %reqid_jobids_hash = @reqid_jobids_array;
    close ( REQIDS );

    my @value = values(%reqid_jobids_hash);
    foreach (@value) {
	&command($_);
    }
} else {
    &command($ARGV[0]);
}

sub command {
    my $tmp = File::Spec->catfile($_[0], "request_id");
    my $temp;
    open (DEL, "< $tmp");
    $temp = <DEL>;
    close (DEL);
    system ("$qdel_command $temp");
    system (inventory_write_cmdline($_[0], "aborted"));
}

sub inventory_write_cmdline {
    my ($jobname, $stat) = @_;
    my $inventory_host = qx/hostname/;
    $inventory_host =~ s/\n//g;
#    status_name_to_level ($stat); # 有効な名前かチェック
    if ( $inventory_port > 0 ) {
        return "$write_command $inventory_host $inventory_port $jobname $stat";
    } else {
	my $current_directory=Cwd::getcwd();
	my $inventory_path=File::Spec->catfile($current_directory, 'inv_watch');
        my $file = File::Spec->catfile($inventory_path, $jobname);
        my $jobspec = "\"spec: $jobname\"";
        return "$write_command $file \"$stat\" $jobspec";
    }
}
