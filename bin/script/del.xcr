use base qw(core);
use File::Spec;
use Getopt::Long;
use common;
use Net::OpenSSH;

our %options = ();

my %keys = ('help' => '        show all the options',
	    'all' => "         delete all the jobs",
	    'clean' => "       delete all the jobs and clean the history",
	    'cancel' => "      the same as uninitialized",
	    'invalidate' => "  the same as finish",
	    'uninitialize' => "delete jobs with making uninitialized",
	    'finish' => "      delete jobs with making finished",
    );
GetOptions(\%options, keys(%keys));

my $Inventory_Path = $xcropt::options{inventory_path};
if (defined $options{'help'}) {
    foreach my $key (keys(%keys)) {
	print $key . '  ' . $keys{$key}, "\n";
    }
} else {
    if (defined $options{'clean'} || defined $options{'all'}) {
	foreach my $id (&jobsched::get_last_job_id) {
	    &del($id);
	}
	if (defined $options{'clean'}) {
	    my $count = 0;
	    while (-e "$Inventory_Path.$count") {
		$count++;
	    }
	    rename $Inventory_Path, "$Inventory_Path.$count";
	}
    } else {
	foreach my $id (@ARGV) {
	    &del($id);
	}
    }
}

sub del {
    my $id = shift;
    &qdel($id);
    print "$id is deleted by user.\n";
    if ($options{'invalidate'} || $options{'finish'}) {
	unlink File::Spec->catfile($Inventory_Path, $id . '_to_be_uninitialized');
	system('touch '. File::Spec->catfile($Inventory_Path, $id .'_to_be_finished'));
	print "$id is finished by user.\n";
    }
    if ($options{'cancel'} || $options{'uninitialize'}) {
	unlink File::Spec->catfile($Inventory_Path, $id . '_to_be_finished');
	system('touch '. File::Spec->catfile($Inventory_Path, $id.'_to_be_uninitialized'));
	print "$id is uninitialized by user.\n";
    }
}

sub qdel {
    my ($id) = @_;
    my $user;
    my $host;
    my $ssh;
    if (defined &jobsched::get_last_job_request_id($id)) {
	unless (&jobsched::get_last_job_userhost($id) eq 'local') {
	    ($user, $host) = split(/@/, &jobsched::get_last_job_userhost($id));
	    $ssh = Net::OpenSSH->new($host, (user => $user));
	}
	my $running_file =
	    File::Spec->catfile(&jobsched::get_last_job_prefix($id),
				&jobsched::get_last_job_workdir($id),
				$id . '_is_running');
	my $done_file =
	    File::Spec->catfile(&jobsched::get_last_job_prefix($id),
				&jobsched::get_last_job_workdir($id),
				$id . '_is_done');
	if (&jobsched::get_last_job_userhost($id) eq 'local') {
	    unlink $running_file;
	    unlink $done_file;
	} else {
	    $ssh->system("rm -f $running_file") or warn $ssh->error;
	    $ssh->system("rm -f $done_file") or warn $ssh->error;
	}
	if ((&jobsched::get_last_job_state($id) eq 'queued') ||
	    (&jobsched::get_last_job_state($id) eq 'running')) {
	    my $qdel_command = $jsconfig::jobsched_config{&jobsched::get_last_job_sched($id)}{qdel_command};
	    unless ( defined $qdel_command ) {
		die "qdel_command isn't defined in " . &jobsched::get_last_job_sched($id) . '.pm';
	    }
	    # execute qdel
	    my $command_string = any_to_string_spc ("$qdel_command ", &jobsched::get_last_job_request_id($id));
	    if (&jobsched::get_last_job_userhost($id) eq 'local') {
#        if (cmd_executable ($command_string, $self->{env})) {
		exec_async ($command_string);
#        } else {
#            warn "$command_string not executable.";
#        }
	    } else {
		print "Deleting $id (request ID: " . &jobsched::get_last_job_request_id($id) . ")\n";
		$ssh->system("$command_string") or warn $ssh->error;
	    }
	}
    } else {
	die "any job of id:$id doesn't exist";
    }
}
