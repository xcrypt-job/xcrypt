use base qw(core);
use File::Spec;
use Getopt::Long;
use common;

our %options = ();
my @job_statuses = qw(initialized prepared submitted queued running done finished aborted); # ジョブ状態一覧

my @help = (
    q /xcryptdel [--help] [--all] [--clean]/,
    q /          [--cancel] [--invalidate] [--ununinitialize] [--finish]/,
    q /          [--name regexp] [--status regexp]/,
    q //,
    q /Options:/,
    q /--help          shows this message/,
    q //,
    q /[delete options]/,
    q /--all           delete all the jobs./,
    q /--clean         delete all the jobs and clean the history./,
    q /--name          delete jobs the name matches of regexp./,
    q /--status        delete jobs the status name matches the regexp./,
    q //,
    q /[state options]/,
    q /--cancel        the same as uninitialized./,
    q /--invalidate    the same as finish./,
    q /--uninitialize  delete jobs with making uninitialized./,
    q /--finish        delete jobs with making finished./,
);


my %keys = ('help', 'all', 'clean', 'cancel', 'invalidate', 'uninitialize', 'finish', 'name', 'status');
GetOptions(\%options,
            'help'   ,
            'all'   ,
            'clean'   ,
            'cancel'   ,
            'invalidate'   ,
            'uninitialize'   ,
            'finish'   ,
	    'name=s'   => \&set_regexp_option,
	    'status=s' => \&set_regexp_option,
    );

my %Host_Ssh_Hash;
my $Inventory_Path = $xcropt::options{inventory_path};
if (defined $options{'help'}) {
    foreach (@help) {
        print $_ . "\n";
    }
    exit;
}
if (defined $options{'clean'} || defined $options{'all'}) {
    foreach my $id (&jobsched::get_last_job_id) {
        &del($id);
    }
    if (defined $options{'clean'}) {
        my $count = 0;
        while (-e "$Inventory_Path.$count") {
            $count++;
        }
        rename $Inventory_Path, "$Inventory_Path.$count";
    }
} elsif (defined $options{'name'} || defined $options{'status'}) {
    my @last_ids = &jobsched::get_last_job_id;
    unless (@last_ids) {
        print "logfile or job's info not exists\n";
        exit;
    }
    if (defined $options{'name'}) {
        foreach my $id (@{$options{'name'}}) {
            my @del_job_ids = grep {$_ =~ /$id/} @last_ids;
            foreach my $id (@del_job_ids) {
                &del($id);
            }
        }
    } else {
        foreach my $id (@last_ids) {
            my $last_job_state = &jobsched::get_last_job_state($id);
            if (grep {&jobsched::get_last_job_state($id) =~ /$_/} @{$options{'status'}}) {
                &del($id);
            }
        }
    }
} else {
    foreach my $id (@ARGV) {
        &del($id);
    }
}

sub set_regexp_option {
    my ($optname, @regexps) = @_;
    
    foreach my $regexp (@regexps) {
        if ($optname eq 'status' and (!grep {$_ =~ $regexp} @job_statuses)) {
            print STDERR 'error status regexp' . "\n";
        }
        if (exists $options{$optname}) {
            push (@{$options{$optname}}, $regexp);
        } else {
            $options{$optname} = [$regexp];
        }
    }
}

sub del {
    my $id = shift;
    &qdel($id);
    print "$id is deleted by user.\n";
    if ($options{'invalidate'} || $options{'finish'}) {
	unlink File::Spec->catfile($Inventory_Path, $id . '_to_be_uninitialized');
	system('mkdir '. File::Spec->catfile($Inventory_Path, $id .'_to_be_finished'));
	print "$id is finished by user.\n";
    }
    if ($options{'cancel'} || $options{'uninitialize'}) {
	unlink File::Spec->catfile($Inventory_Path, $id . '_to_be_finished');
	system('mkdir '. File::Spec->catfile($Inventory_Path, $id.'_to_be_uninitialized'));
	print "$id is uninitialized by user.\n";
    }
}

sub qdel {
    my ($id) = @_;
    if (defined &jobsched::get_last_job_request_id($id)) {
	if (&jobsched::get_last_job_location($id) eq 'remote') {
	    unless (exists $Host_Ssh_Hash{&jobsched::get_last_job_userhost($id)}) {
		my ($user, $host) = split(/@/, &jobsched::get_last_job_userhost($id));
		my $ssh = Net::OpenSSH->new($host, (user => $user));
		$ssh->error and die "Unable to establish SSH connection: " . $ssh->error;
		$Host_Ssh_Hash{&jobsched::get_last_job_userhost($id)} = $ssh;
	    }
	}
	my $running_file =
	    File::Spec->catfile(&jobsched::get_last_job_prefix($id),
				&jobsched::get_last_job_workdir($id),
				$id . '_is_running');
	my $done_file =
	    File::Spec->catfile(&jobsched::get_last_job_prefix($id),
				&jobsched::get_last_job_workdir($id),
				$id . '_is_done');
	if (&jobsched::get_last_job_location($id) eq 'local') {
	    unlink $running_file;
	    unlink $done_file;
	} else {
	    my $ssh = $Host_Ssh_Hash{&jobsched::get_last_job_userhost($id)};
	    $ssh->system("rm -rf $running_file") or warn $ssh->error;
#	    Net::SSH::ssh(&jobsched::get_last_job_userhost($id), "rm -f $running_file");
	    $ssh->system("rm -rf $done_file") or warn $ssh->error;
#	    Net::SSH::ssh(&jobsched::get_last_job_userhost($id), "rm -f $done_file");
	}
	if ((&jobsched::get_last_job_state($id) eq 'queued') ||
	    (&jobsched::get_last_job_state($id) eq 'running')) {
	    my $qdel_command = $jsconfig::jobsched_config{&jobsched::get_last_job_sched($id)}{qdel_command};
	    unless ( defined $qdel_command ) {
		die "qdel_command isn't defined in " . &jobsched::get_last_job_sched($id) . '.pm';
	    }
	    # execute qdel
	    my $command_string = any_to_string_spc ("$qdel_command ", &jobsched::get_last_job_request_id($id));
	    if (&jobsched::get_last_job_location($id) eq 'local') {
#        if (cmd_executable ($command_string, $self->{env})) {
		exec_async ($command_string);
#        } else {
#            warn "$command_string not executable.";
#        }
	    } else {
		print "Deleting $id (request ID: " . &jobsched::get_last_job_request_id($id) . ")\n";
		my $ssh = $Host_Ssh_Hash{&jobsched::get_last_job_userhost($id)};
		$ssh->system("$command_string") or warn $ssh->error;
#		Net::SSH::ssh(&jobsched::get_last_job_userhost($id), "$command_string");
	    }
	}
    } 
#   else {
#       die "any job of id:$id doesn't exist";
#   }
}
