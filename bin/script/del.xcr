use base qw(core);
use File::Spec;
use Getopt::Long;
use common;
use Net::OpenSSH;

our %options = ();

my %keys = ('help' => '      show all the options',
	    'all' => "       delete all the jobs",
	    'clean' => "     delete all the jobs and clean the history",
	    'cancel' => "    delete jobs with making aborted",
	    'invalidate' => "delete jobs with making finished",
    );
GetOptions(\%options, keys(%keys));

my $Inventory_Path = $xcropt::options{inventory_path};
if (defined $options{'help'}) {
    foreach my $key (keys(%keys)) {
	print $key . '  ' . $keys{$key}, "\n";
    }
} else {
    if (defined $options{'clean'} || defined $options{'all'}) {
	foreach my $id (keys(%jobsched::Last_State)) {
	    &del($id);
	}
	if (defined $options{'clean'}) {
	    my $count = 0;
	    while (-e "$Inventory_Path.$count") {
		$count++;
	    }
	    rename $Inventory_Path, "$Inventory_Path.$count";
	}
    } else {
	foreach my $id (@ARGV) {
	    &del($id);
	}
    }
}

sub del {
    my $id = shift;
    &qdel($id);
    print "$id is deleted by user.\n";
    if ($options{'invalidate'}) {
	unlink File::Spec->catfile($Inventory_Path, $id . '_to_be_cancelled');
	system('touch '. File::Spec->catfile($Inventory_Path, $id .'_to_be_invalidated'));
	print "$id is invalidated by user.\n";
    }
    if ($options{'cancel'}) {
	unlink File::Spec->catfile($Inventory_Path, $id . '_to_be_invalidated');
	system('touch '. File::Spec->catfile($Inventory_Path, $id.'_to_be_cancelled'));
	print "$id is cancelled by user.\n";
    }
}

sub qdel {
    my ($id) = @_;
    my $user;
    my $host;
    my $ssh;
    if (defined $jobsched::Last_Userhost_ID{$id}) {
    unless ($jobsched::Last_Userhost_ID{$id} eq 'local') {
	($user, $host) = split(/@/, $jobsched::Last_Userhost_ID{$id});
	$ssh = Net::OpenSSH->new($host, (user => $user));
    }

    my $running_file = File::Spec->catfile($jobsched::Last_Workdir{$id}, $id . '_is_running');
    my $done_file = File::Spec->catfile($jobsched::Last_Workdir{$id}, $id . '_is_done');
    if ($jobsched::Last_Userhost_ID{$id} eq 'local') {
	unlink $running_file;
	unlink $done_file;
    } else {
	$ssh->system("rm -f $running_file") or warn $ssh->error;
	$ssh->system("rm -f $done_file") or warn $ssh->error;
    }
    if (($jobsched::Last_State{$id} eq 'queued') || ($jobsched::Last_State{$id} eq 'running')) {
	my $qdel_command = $jsconfig::jobsched_config{$jobsched::Last_Sched_ID{$id}}{qdel_command};
	unless ( defined $qdel_command ) {
    die "qdel_command isn't defined in $jobsched::Last_Sched_ID{$id}.pm";
	}
	# execute qdel
	my $command_string = any_to_string_spc ("$qdel_command ", $jobsched::Last_Request_ID{$id});
	if ($jobsched::Last_Userhost_ID{$id} eq 'local') {
#        if (cmd_executable ($command_string, $self->{env})) {
	    exec_async ($command_string);
#        } else {
#            warn "$command_string not executable.";
#        }
	} else {
	    print "Deleting $id (request ID: $jobsched::Last_Request_ID{$id})\n";
	    $ssh->system("$command_string") or warn $ssh->error;
	}
    }
    } else {
	die "any job of id:$id doesn't exist";
    }
}

