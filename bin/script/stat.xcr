use base qw(core);
use Getopt::Long;
use jobsched;
use common;
use Net::OpenSSH;

our %options = ();

my %keys = ('help' => '    show all the options',
	    'match=s' => ' show matched jobs',
	    'status=s' => 'show jobs of the state',
	    'output' => "  show standard outputs",
	    'error' => "   show standard errors",
	    'batch' => "   show batch job scripts",
    );
GetOptions(\%options, keys(%keys));

my $Inventory_Path = $xcropt::options{inventory_path};
if (defined $options{'help'}) {
    foreach my $key (keys(%keys)) {
	print $key . '  ' . $keys{$key}, "\n";
    }
} else {
    if ($#ARGV == -1) {
	foreach my $id (&jobsched::get_last_job_id) {
	    if (defined $options{'match'}) {
		if ($id =~ /$options{match}/) {
		    &print_stat($id);
		}
	    } elsif (defined $options{'status'}) {
		if (&jobsched::get_last_job_state($id) =~ /$options{status}/) {
		    &print_stat($id);
		}
	    } else {
		&print_stat($id);
	    }
	}
    } else {
	foreach my $id (@ARGV) {
	    if (defined $options{'match'}) {
		if ($id =~ /$options{match}/) {
		    &print_stat($id);
		}
	    } elsif (defined $options{'status'}) {
		if (&jobsched::get_last_job_state($id) =~ /$options{status}/) {
		    &print_stat($id);
		}
	    } else {
		&print_stat($id);
	    }
	}

    }
}

my %ssh_opts = (
    copy_attrs => 1,      # -p preserver file attributes
    recursive => 1,       # -r recursive copy
    bwlimit => 10000000,  # -l the max size of a copied file
    glob => 1,            # enable globs (e.g. '*' for all files)
    quiet => 1,           # Quiet. Does not show progress
    );

sub print_stat {
    my $id = shift;
    print "$id = ". &jobsched::get_last_job_state($id);
    if ( &jobsched::get_last_job_request_id($id) ) {
	print " (request_ID=" . &jobsched::get_last_job_request_id($id) . "_at_" . &jobsched::get_last_job_userhost($id) . ")";
    }
    print "\n";
    if (defined $options{'output'}) {
	my $tmp = File::Spec->catfile(&jobsched::get_last_job_workdir($id),
				      &jobsched::get_last_job_stdout($id));
	&print_stat_body($id, 'output', $tmp);
    }
    if (defined $options{'error'}) {
	my $tmp = File::Spec->catfile(&jobsched::get_last_job_workdir($id),
				      &jobsched::get_last_job_stderr($id));
	&print_stat_body($id, 'error', $tmp);
    }
    if (defined $options{'batch'}) {
	my $tmp = File::Spec->catfile(&jobsched::get_last_job_workdir($id),
				      &jobsched::get_last_job_script($id));
	&print_stat_body($id, 'batch', $tmp);
    }
}


sub print_stat_body {
    my ($id, $type, $file) = @_;
    print '=' . $id . "'s $type" . "=\n";
    unless (&jobsched::get_last_job_userhost($id) eq 'local') {
	unless(-e $file) {
	    my ($user, $host) = split(/@/, &jobsched::get_last_job_userhost($id));
	    $ssh = Net::OpenSSH->new($host, (user => $user));
	    $ssh->scp_get(\%ssh_opts, File::Spec->catfile(&jobsched::get_last_job_prefix($id), $file), $file) or warn $ssh->error;
	}
    }
    open(my $out, $file) or die $!;
    foreach (<$out>) { print "$_"; }
    close($out);
}
