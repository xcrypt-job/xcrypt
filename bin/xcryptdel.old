#!/usr/bin/env perl
package xcryptdel;

use strict;
use Cwd;
use File::Basename;
use File::Spec;
use Getopt::Long;
use common;
use jsconfig;

foreach ('XCRYPT', 'XCRJOBSCHED','PERL5LIB') {
    unless (defined $ENV{"$_"}) {
	die "Set the environment varialble $_\n";
    }
}

my %opts = ();
GetOptions(\%opts, 'all');

# Get qdel command
my $qdel_command
    = $jsconfig::jobsched_config{$ENV{'XCRJOBSCHED'}}{qdel_command};
unless ( defined $qdel_command ) {
    die "qdel_command is not defined in $ENV{'XCRJOBSCHED'}.pm";
}
unless (&common::cmd_executable ($qdel_command)) {
    die "$qdel_command not executable";
}

# Get request ID from jobname
unless ($opts{'all'}) {
    &command(@ARGV);
} else {
    my $current_directory=Cwd::getcwd();
    my $inventory_path=File::Spec->catfile($current_directory, 'inv_watch');
    my $idfiles = File::Spec->catfile($inventory_path, '.request_ids');
    open ( REQIDS, "< $idfiles" );
    my $reqid_jobids = <REQIDS>;
    my @reqid_jobids_array = split(/ /, $reqid_jobids);
    my %reqid_jobids_hash = @reqid_jobids_array;
    close ( REQIDS );

    my @value = values(%reqid_jobids_hash);
    &command(@value);
}

sub get_job_request_id_from_file {
    my $current_directory=Cwd::getcwd();
    my $idfile=File::Spec->catfile($current_directory, "$_[0]", 'request_id');
    my $id;
    open(ID, $idfile) or warn "Can't open $idfile.";
    $id = <ID>;
    close(ID);
    return $id;
}

sub get_job_status_from_file {
    my $current_directory=Cwd::getcwd();
    my $inventory_path=File::Spec->catfile($current_directory, 'inv_watch');
    my $statfile = File::Spec->catfile($inventory_path, "$_[0]");
    my $stat;
    open(STAT, $statfile) or warn "Can't open $statfile.";
    while (<STAT>) {
	if ($_ =~ /^status\:\s(.+)/) {
	    chomp($_);
	    my @tmp = split(' ', $_);
	    $stat = $tmp[1];
	}
    }
    close(STAT);
    return $stat;
}

sub command {
    my @args = @_;
    foreach my $arg (@args) {
	my $stat = &get_job_status_from_file($arg);
	if (($stat eq 'active'   ) ||
	    ($stat eq 'prepared' ) ||
	    ($stat eq 'submitted')) {
# 何をする？
	} elsif (($stat eq 'done'    ) ||
		 ($stat eq 'finished') ||
		 ($stat eq 'aborted' )) {
	    warn "$arg has already been finished.";
	} elsif (($stat eq 'queued' ) ||
		 ($stat eq 'running')) {
	    my $tmp = &get_job_request_id_from_file($arg);
	    system ("$qdel_command $tmp");
	} else {
	    warn "$arg is in an unexpected state."
	}
    }
}
