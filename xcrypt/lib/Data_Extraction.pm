############################################
# ＜＜出力データ抽出＞＞                   #
# Copyright FUJITSU LIMITED 2009           #
# Ver=0.2 2009/09/08                       #
############################################
package Data_Extraction;
use Exporter;
@ISA    = (Exporter);
@EXPORT = qw(EF);
use strict;
#use warnings;
use File::Basename;
use Cwd;

###################################################################################################
#   ＜＜ 抽出対象ファイル定義 ＞＞                                                                #
###################################################################################################
sub EF {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 入力データ情報                                                          #
    #                 ・変数指定    ）変数名                                                  #
    #                 ・ファイル指定）file:ファイル名                                         #
    # 処理 ： 入力データチェック、オブジェクト定義（抽出対象ファイル定義）                    #
    # 返却 ： オブジェクト                                                                    #
    #-----------------------------------------------------------------------------------------#
    my %line_pos      = ();
    my $line_now      = 0;
    my $line_seek     = 1;
    my @cond_data     = ();
    my @out_data_line = ();
    my @out_data      = ();
    
    # 入力データチェック
    my @in_data = &check_in_data($_[0]);
    
    # 行数取得
    my $line_max = &get_line_max(@in_data);
    
    # オブジェクト定義
    my $Job = {"in_kbn"        =>$in_data[0],                 # 入力区分（ファイルor変数）
               "in_name"       =>$in_data[1],                 # 入力データ名（ファイル名or変数名）
               "line_pos"      =>\%line_pos,                  # 入力データの先頭バイト位置（直近１００レコード分）
               "line_now"      =>$line_now,                   # 処理中行番号
               "line_seek"     =>$line_seek,                  # 入力行番号
               "line_max"      =>$line_max,                   # データ行数
               "cond_data"     =>\@cond_data,                 # 抽出条件
               "out_data_line" =>\@out_data_line,             # 抽出対象データの行番号
               "out_data"      =>\@out_data};                 # 抽出対象データ
    bless $Job;
    return $Job;
}
###################################################################################################
#   ＜＜ 入力データチェック ＞＞                                                                  #
###################################################################################################
sub check_in_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 入力データ情報                                                          #
    # 処理 ： 変数指定    ）変数存在チェック、データ存在チェック                              #
    #         ファイル指定）ファイル存在チェック、読込み権限チェック、データ存在チェック      #
    # 返却 ： 入力区分、入力データ名                                                          #
    #-----------------------------------------------------------------------------------------#
    my @in_data = ();
    
    if ($_[0] !~ /file:/) {
        # 変数指定
        $in_data[0] = '';
        $in_data[1] = '${main::'.$_[0].'}';
        if (! defined eval($in_data[1])) {
            # 変数なし
            print STDERR "Input variable($_[0]) not found\n";
            exit 99;
        }
        if (eval($in_data[1]) eq '') {
            # 変数に値なし
            print STDERR "There are not the input data($_[0])\n";
            exit 99;
        }
    } else {
        # ファイル指定
        $in_data[0] = 'file';
        $in_data[1] = substr $_[0], 5;
        if (!-e "$in_data[1]") {
            # ファイルなし
            print STDERR "Input file($_[0]) not found\n";
            exit 99;
        } elsif (!-r "$in_data[1]") {
            # ファイルに読込み権限なし
            print STDERR "Input file($_[0]) is not read authority\n";
            exit 99;
        }
        my @in_file_information = stat $in_data[1];
        if ($in_file_information[7] == 0) {
            # ファイルが空
            print STDERR "There are not the input data($_[0])\n";
            exit 99;
        }
    }
    return @in_data;
}
###################################################################################################
#   ＜＜ 抽出条件定義 ＞＞                                                                        #
###################################################################################################
sub ED {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = オブジェクト                                                           #
    #         $_[1〜]= 抽出データ指示                                                         #
    # 処理 ： 抽出条件チェック、抽出条件設定                                                  #
    #-----------------------------------------------------------------------------------------#
    # 抽出データ指示                                                                          #
    #   行抽出                                                                                #
    #     行番号指定  ：[!]L/行番号[/[範囲][/列抽出]]                                         #
    #     正規表現指定：[!]LR/抽出条件[/範囲][/列抽出]]                                       #
    #     ※条件以外の抽出は、先頭に"!"を付与                                                 #
    #   列抽出                                                                                #
    #     列番号指定  ：[!]C/列番号[/範囲]                                                    #
    #     正規表現指定：[!]CR/抽出条件[/範囲]                                                 #
    #     ※条件以外の抽出は、先頭に"!"を付与                                                 #
    #   ユーザー抽出  ：［"パッケージ名::サブルーチン名"[, "ユーザー抽出条件", ･･･ ]］        #
    #                   ※大外の［］は、配列定義を意味する                                    #
    #-----------------------------------------------------------------------------------------#
    # 抽出条件チェック
    my @cond_data = &check_extraction_cond(@_);
    
    # 抽出条件設定
    push(@{$_[0]->{cond_data}}, [@cond_data]);
}
###################################################################################################
#   ＜＜ 抽出条件チェック ＞＞                                                                    #
###################################################################################################
sub check_extraction_cond {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = オブジェクト                                                           #
    #         $_[1〜]= 抽出データ指示                                                         #
    # 処理 ： 抽出条件チェック、定型抽出条件の記述チェック                                    #
    #-----------------------------------------------------------------------------------------#
    my $obj       = shift;
    my @cond_data = ();
    
    foreach (@_) {
        if (/^\!{0,1}[CLcl][Rr]*\//) {
            # 定型抽出
            my @in_cond = split /[\/]/, $_;
            my @in_kbn  = ();
            
            if ((substr $in_cond[0], 0, 1) ne '!') {
                $in_kbn[0] = '';
                $in_kbn[1] = uc(substr $in_cond[0], 0);
            } else {
                $in_kbn[0] = substr $in_cond[0], 0, 1;
                $in_kbn[1] = uc(substr $in_cond[0], 1);
            }
            &check_fixed_form_cond($obj, $in_kbn[0], $in_kbn[1], $in_cond[1], $in_cond[2]);
            
            if ($in_cond[3] eq "") {
                push(@cond_data, ["$in_kbn[1]", "$in_kbn[0]", "$in_cond[1]", "$in_cond[2]", "", "", "", ""]);
            } elsif ($in_cond[3] =~ /^\!{0,1}[Cc][Rr]*$/) {
                if ((substr $in_cond[3], 0, 1) ne '!') {
                    $in_kbn[2] = '';
                    $in_kbn[3] = uc(substr $in_cond[3], 0);
                } else {
                    $in_kbn[2] = substr $in_cond[3], 0, 1;
                    $in_kbn[3] = uc(substr $in_cond[3], 1);
                }
                &check_fixed_form_cond($obj, $in_kbn[2], $in_kbn[3], $in_cond[4], $in_cond[5]);
                push(@cond_data, ["$in_kbn[1]", "$in_kbn[0]", "$in_cond[1]", "$in_cond[2]", "$in_kbn[3]", "$in_kbn[2]", "$in_cond[4]", "$in_cond[5]"]);
            } else {
                # 抽出区分誤り
                print STDERR "Extraction Division is an Error \($_\)\n";
                exit 99;
            }
        } elsif ($_ =~ /^ARRAY\(.*\)/) {
            my @in_cond_user = @{$_};
            # ユーザー抽出
            if ($in_cond_user[0] =~ /\:\:/) {
                push(@cond_data, ["USER", @in_cond_user]);
            } else {
                # 抽出区分誤り
                print STDERR "Extraction Division is an Error \(@{$_}\)\n";
                exit 99;
            }
        } else {
            # 抽出区分誤り
            print STDERR "Extraction Division is an Error \($_\)\n";
            exit 99;
        }
    }
    return @cond_data;
}
###################################################################################################
#   ＜＜ 定型抽出条件の記述チェック ＞＞                                                          #
###################################################################################################
sub check_fixed_form_cond {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 肯定否定区分                                                            #
    #         $_[2] = 抽出区分                                                                #
    #         $_[3] = 起点                                                                    #
    #         $_[4] = 範囲                                                                    #
    # 処理 ： 定型抽出条件の記述チェック                                                      #
    #-----------------------------------------------------------------------------------------#
    if ($_[1] ne '' and $_[1] ne '!') {
        # 肯定否定区分誤り
        print STDERR "Affirmation Negation Division is an Error \($_[1]\)\n";
        exit 99;
    }
    if ($_[2] eq 'L' and ($_[3] eq 'E' or $_[3] eq 'e')) {
        $_[3] = $_[0]->{line_max};
    }
    if ($_[2] eq 'C' and ($_[3] eq 'E' or $_[3] eq 'e')) {
    } elsif (($_[2] eq 'L' and ($_[3] !~ /^\d+$/ or $_[3] == 0)) or
            ($_[2] eq 'C' and ($_[3] !~ /^\d+$/ or $_[3] <= 0))) {
        # 起点番号誤り
        print STDERR "Starting Point Number is an Error \($_[3]\)\n";
        exit 99;
    }
    if ($_[2] =~ /R/ and $_[3] eq '') {
        # 起点正規表指定現無し
        print STDERR "Regular Expression Character string is not Found\n";
        exit 99;
    }
    if ($_[2] =~ /R/ and $_[4] =~ /^[\+-]\d+/ and ($_[4] !~ /^[\+-]\d+$/ or $_[4] == 0))  {
        # 抽出範囲誤り
        print STDERR "End Range Number is an Error \($_[4]\)\n";
        exit 99;
    }
    ############################################################################################＜ver0.2制限チェック＞
    if ($_[2] eq 'LR' and $_[4] =~ /^-\d+$/)  {
        # ver0.2制限（正規表現のマイナス範囲）
        print STDERR "Ver0.2 restrictions is an Error \($_[4]\)\n";
        exit 99;
    }
    if ($_[2] eq 'LR' and $_[1] eq '!')  {
        # ver0.2制限（正規表現の否定）
        print STDERR "Ver0.2 restrictions is an Error \($_[4]\)\n";
        exit 99;
    }
    ############################################################################################＜ver0.2制限チェック＞
    if ($_[2] eq 'L' or $_[2] eq 'C') {
        if ($_[4] eq '') {
            $_[4] = $_[3];
        } elsif ($_[4] =~ /^\d+$/ and $_[4] > 0) {
            if ($_[3] > $_[4]) {
                my $temp_su = $_[3];
                $_[3] = $_[4];
                $_[4] = $temp_su;
            }
        } elsif ($_[4] =~ /^-\d+$/ and $_[4] != 0) {
            my $temp_su = $_[3];
            $_[3] = $_[3] + $_[4];
            $_[4] = $temp_su;
        } elsif ($_[4] =~ /^\+\d+$/ and $_[4] != 0) {
            $_[4] = $_[3] + $_[4];
        } elsif ($_[4] eq 'E' or $_[4] eq 'e') {
            if ($_[2] eq 'L') {
                $_[4] = $_[0]->{line_max};
            }
        } else {
            # 抽出範囲誤り
            print STDERR "End Range Number is an Error \($_[4]\)\n";
            exit 99;
        }
    }
}
###################################################################################################
#   ＜＜ 抽出実行 ＞＞                                                                            #
###################################################################################################
sub ER {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 定型抽出（行・列・ブロック抽出）、ユーザー抽出（ユーザー関数呼出し）            #
    # 返却 ： 抽出結果                                                                        #
    #-----------------------------------------------------------------------------------------#
    my $obj = shift;
    
    ##############
    # 抽出前処理 #
    ##############
    if ($obj->{in_kbn} eq 'file') {
        # ファイルOPEN
        &in_file_open($obj->{in_name});
    }
    
    ############
    # 抽出処理 #
    ############
    while (my $line_data = &get_line_data($obj)){
        # 登録済情報かチェック
        next if (&check_existence_data($obj, $obj->{line_now}));
        # 抽出
        &cut_last_0a($obj, $line_data);
        my $extraction_data = undef;
        foreach my $cond_data(@{$obj->{cond_data}}) {
            # 正規表現による行抽出を行番号指定に変換
            push(@{$cond_data}, &get_cond_lr_s($obj->{line_now}, $line_data, grep{${$_}[0] eq 'LR' and $line_data =~ /${$_}[2]/}@{$cond_data}));
            &get_cond_lr_e($obj->{line_now}, $line_data, grep{${$_}[0] eq 'r' and $line_data =~ /${$_}[3]/}@{$cond_data});
            
            # ユーザー抽出
            $extraction_data = &init_extraction_data("", "$line_data") | &get_cond_user($obj, grep{${$_}[0] eq 'USER'}@{$cond_data});
            if (&check_existence_data($obj, $obj->{line_now})) {
                $extraction_data = '';
                last;
            }
            # 定型抽出
            if (&change_Bto2($extraction_data) !~ /^1/) {
                # 行抽出、ブロック抽出
                $extraction_data = $extraction_data | &get_cond_lc($line_data,
                                                                   grep{((${$_}[0] eq "L" and ((${$_}[1] eq "" and ${$_}[2] <= $obj->{line_now} and $obj->{line_now} <= ${$_}[3])
                                                                                            or (${$_}[1] ne "" and ($obj->{line_now} < ${$_}[2] or ${$_}[3] < $obj->{line_now}))))
                                                                      or (${$_}[0] eq "r" and ((${$_}[1] eq "" and ${$_}[2] <= $obj->{line_now})
                                                                                            or (${$_}[1] ne "" and $obj->{line_now} < ${$_}[2]))))}@{$cond_data});
                # 列抽出
                if (&change_Bto2($extraction_data) !~ /^1/) {
                    $extraction_data = $extraction_data | &get_cond_c($line_data, grep{${$_}[0] eq 'C'}@{$cond_data});
                    $extraction_data = $extraction_data | &get_cond_cr($line_data, grep{${$_}[0] eq 'CR'}@{$cond_data});
                }
            }
            
            # 抽出対象かチェック
            last if (&change_Bto2($extraction_data) == 0);
            # 抽出データを取得
            $line_data = &get_extraction_data($line_data, &change_Bto2($extraction_data));
        }
        
        # 抽出結果（抽出データ）を登録
        if (&change_Bto2($extraction_data) > 0) {
            &add_data($obj, "$obj->{line_now}", "$line_data");
        }
    }
    
    ##############
    # 抽出後処理 #
    ##############
    if ($obj->{in_kbn} eq 'file') {
        # ファイルCLOSE
        &in_file_close;
    }
    # 抽出結果を返却
    return @{$obj->{out_data}};
}
###################################################################################################
#   ＜＜ 入力ファイルＯＰＥＮ ＞＞                                                                #
###################################################################################################
sub in_file_open {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 入力ファイル名                                                          #
    # 処理 ： 入力ファイルのファイルＯＰＥＮ                                                  #
    #-----------------------------------------------------------------------------------------#
    if (! open (EXTRACTION_FILE, "< $_[0]")) {
        # 入力ファイルOPENエラー
        print STDERR "Input File($_[0]) cannot Open\n";
        exit 99;
    }
    flock(EXTRACTION_FILE, 1);
}
###################################################################################################
#   ＜＜ 入力ファイルＣＬＯＳＥ ＞＞                                                              #
###################################################################################################
sub in_file_close {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 入力ファイル名                                                          #
    # 処理 ： 入力ファイルのファイルＣＬＯＳＥ                                                #
    #-----------------------------------------------------------------------------------------#
    if (! close (EXTRACTION_FILE)) {
        # 入力ファイルCLOSEエラー
        print STDERR "Input File($_[0]) cannot Close\n";
        exit 99;
    }
}
###################################################################################################
#   ＜＜ 処理中行番号取得 ＞＞                                                                    #
###################################################################################################
sub get_line_num {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 処理中の行番号を取得                                                            #
    #-----------------------------------------------------------------------------------------#
    return $_[0]->{line_now};
}
###################################################################################################
#   ＜＜ 行数取得 ＞＞                                                                            #
###################################################################################################
sub get_line_max {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 入力区分（ファイルor変数）                                              #
    # 引数 ： $_[1] = 入力データ名（ファイル名or変数名）                                      #
    # 処理 ： 抽出対象データの行数を取得                                                      #
    #-----------------------------------------------------------------------------------------#
    my $line_max = 0;
    
    if ($_[0] eq 'file') {
        &in_file_open($_[1]);
        while (<EXTRACTION_FILE>) {
            $line_max++;
        }
        &in_file_close();
    } else {
        $line_max = split /[\n]/, (eval($_[1]));
    }
    return $line_max;
}
###################################################################################################
#   ＜＜ 行番号チェック ＞＞                                                                      #
###################################################################################################
sub check_line_num {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 行番号                                                                  #
    # 処理 ： 行番号の記述チェック                                                            #
    #-----------------------------------------------------------------------------------------#
    if ($_[0] !~ /^\d+$/ or $_[0] <= 0) {
        print STDERR "Line Number Error($_[0]), \n";
        exit 99;
    }
}
###################################################################################################
#   ＜＜ データ取得区分チェック ＞＞                                                              #
###################################################################################################
sub check_data_acquisition_flag {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = データ取得区分                                                          #
    # 処理 ： データ取得区分の記述チェック                                                    #
    #-----------------------------------------------------------------------------------------#
    if ($_[0] ne "org" and $_[0] ne "now") {
        print STDERR "Data Acquisition division Error($_[0]), \n";
        exit 99;
    }
}
###################################################################################################
#   ＜＜ 抽出データ存在チェック ＞＞                                                              #
###################################################################################################
sub check_existence_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 行番号                                                                  #
    # 処理 ： オブジェクトに保存している抽出データに指定行が存在するかチェック                #
    #-----------------------------------------------------------------------------------------#
    foreach (@{$_[0]->{out_data_line}}) {
        if ($_[1] == (&change_16to10("$_"))) {
            return 1;
        }
    }
    return 0;
}
###################################################################################################
#   ＜＜ １０進数→１６進数変換 ＞＞                                                              #
###################################################################################################
sub change_10to16{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = １０進数の文字列                                                        #
    # 処理 ： １０進数の文字列を１６進数の文字列に変換                                        #
    #-----------------------------------------------------------------------------------------#
    if (((length $_[0]) % 2) == 0) {
        return pack("H*", "$_[0]");
    } else {
        return pack("H*", "0$_[0]");
    }
}
###################################################################################################
#   ＜＜ １６進数→１０進数変換 ＞＞                                                              #
###################################################################################################
sub change_16to10{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = １６進数の文字列                                                        #
    # 処理 ： １６進数の文字列を１０進数の文字列に変換                                        #
    #-----------------------------------------------------------------------------------------#
    return unpack("H*", "$_[0]");
}
###################################################################################################
#   ＜＜ ２進数→バイナリ変換 ＞＞                                                                #
###################################################################################################
sub change_2toB{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = ２進数の文字列                                                          #
    # 処理 ： ２進数の文字列をバイナリ文字列に変換                                            #
    #-----------------------------------------------------------------------------------------#
    return pack("B*", "$_[0]");
}
###################################################################################################
#   ＜＜ バイナリ→２進数変換 ＞＞                                                                #
###################################################################################################
sub change_Bto2{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = バイナリ文字列                                                          #
    # 処理 ： バイナリ文字列を２進数の文字列に変換                                            #
    #-----------------------------------------------------------------------------------------#
    return unpack("B*", "$_[0]");
}
###################################################################################################
#   ＜＜ 抽出対象データ取得位置指定 ＞＞                                                          #
###################################################################################################
sub seek_line {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 行番号                                                                  #
    # 処理 ： 行番号チェック、抽出対象データの読込む位置を指定行へ移動                        #
    #-----------------------------------------------------------------------------------------#
    &check_line_num("$_[1]");
    
    if ($_[1] == 1) {
        seek EXTRACTION_FILE, (0), 0 or "$!($_[0]->{in_name})";
    } elsif (exists ${$_[0]->{line_pos}}{$_[1]}) {
        seek EXTRACTION_FILE, (${$_[0]->{line_pos}}{$_[1]}), 0 or "$!($_[0]->{in_name})";
    } elsif ($_[0]->{line_seek} < $_[1]) {
        for (my $index=$_[0]->{line_seek}; $index < $_[1]; $index++) {
            <EXTRACTION_FILE>;
        }
    } elsif ($_[0]->{line_now} < $_[1] and $_[0]->{line_seek} >= $_[1]) {
        seek EXTRACTION_FILE, (${$_[0]->{line_pos}}{$_[0]->{line_now}}), 0 or "$!($_[0]->{in_name})";
        for (my $index=$_[0]->{line_now}; $index < $_[1]; $index++) {
            <EXTRACTION_FILE>;
        }
    } else {
        seek EXTRACTION_FILE, (0), 0 or "$!($_[0]->{in_name})";
        for (my $index=1; $index < $_[1]; $index++) {
            <EXTRACTION_FILE>;
        }
    }
    $_[0]->{line_seek} = $_[1];
}
###################################################################################################
#   ＜＜ 抽出対象データ取得 ＞＞                                                                  #
###################################################################################################
sub get_line {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = データ取得区分（org：オリジナル／now：抽出結果）                        #
    # 処理 ： データ取得区分チェック、抽出対象データの取得                                    #
    # 返却 ： 抽出対象データ                                                                  #
    #-----------------------------------------------------------------------------------------#
    &check_data_acquisition_flag("$_[1]");
    my $line = "";
    
    if ($_[1] eq "org") {
        # オリジナル
        if ($_[0]->{in_kbn} eq "") {
            # 変数指定
            my $check = '^';
            for (my $index=1; $index <= ($_[0]->{line_seek} - 1); $index++) {
                $check .= '.*\n';
            }
            $check .= '(.*\n{0,1})';
            if ((eval($_[0]->{in_name})) =~ /$check/) {
                $line = $1;
            }
        } else {
            # ファイル指定
            $line = <EXTRACTION_FILE>;
        }
    } else {
        # 抽出結果
        for (my $index1=0 ; $index1 <= $#{$_[0]->{out_data_line}}; $index1++) {
            if ($_[0]->{line_seek} == (&change_16to10(${$_[0]->{out_data_line}}[$index1]))) {
                $line = $_[0]->{out_data}[$index1];
                last;
            }
        }
    }
    if ($line ne "") {
        $_[0]->{line_seek}++;
    }
    return $line;
}
###################################################################################################
#   ＜＜ 抽出対象データnext取得 ＞＞                                                              #
###################################################################################################
sub get_line_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 抽出対象データ取得、直近１００レコード分のレコード先頭位置を退避                #
    # 返却 ： 抽出対象データ                                                                  #
    #-----------------------------------------------------------------------------------------#
    my $line = &get_line($_[0], "org");
    
    if ($line ne "") {
        $_[0]->{line_now}++;
        # レコード先頭位置を退避（直近１００レコード分）
        ${$_[0]->{line_pos}}{($_[0]->{line_now} + 1)} = tell EXTRACTION_FILE;
        if ($_[0]->{line_now} > 100) {
            delete ${$_[0]->{line_pos}}{($_[0]->{line_now} - 100)};
        }
    }
    return $line;
}
###################################################################################################
#   ＜＜ 抽出区分初期化 ＞＞                                                                    #
###################################################################################################
sub init_extraction_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 行データ                                                                #
    # 処理 ： 行データを区切り文字で分割                                                      #
    # 返却 ： 配列化した行データ                                                              #
    #-----------------------------------------------------------------------------------------#
    my $extraction_data = "0" x (&get_col_data("", "$_[1]") + 1);
    return &change_2toB($extraction_data);
}
###################################################################################################
#   ＜＜ 行データ配列変換 ＞＞                                                                    #
###################################################################################################
sub get_col_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 行データ                                                                #
    # 処理 ： 行データを区切り文字で分割                                                      #
    # 返却 ： 配列化した行データ                                                              #
    #-----------------------------------------------------------------------------------------#
    return (split /\s+\,*\s*|\,+\s*/, $_[1]);
}
###################################################################################################
#   ＜＜ 抽出データ追加・更新 ＞＞                                                                #
###################################################################################################
sub add_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 行番号                                                                  #
    #      ： $_[2] = 行データ                                                                #
    # 処理 ： 行データをオブジェクトの抽出データに追加・更新                                  #
    #-----------------------------------------------------------------------------------------#
    for (my $index1=0 ; $index1 <= $#{$_[0]->{out_data_line}}; $index1++) {
        if ($_[1] == (&change_16to10(${$_[0]->{out_data_line}}[$index1]))) {
            $_[0]->{out_data}[$index1] = "$_[2]";
            return;
        } elsif ($_[1] < (&change_16to10(${$_[0]->{out_data_line}}[$index1]))) {
            splice(@{$_[0]->{out_data_line}}, $index1, 0, (&change_10to16($_[1])));
            splice(@{$_[0]->{out_data}}, $index1, 0, "$_[2]");
            return;
        }
    }
    push(@{$_[0]->{out_data_line}}, &change_10to16($_[1]));
    push(@{$_[0]->{out_data}}, $_[2]);
}
###################################################################################################
#   ＜＜ 抽出データ削除 ＞＞                                                                      #
###################################################################################################
sub del_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 行番号                                                                  #
    # 処理 ： オブジェクトの抽出データから指定行を削除                                        #
    #-----------------------------------------------------------------------------------------#
    if ($_[0]->{line_now} > $_[1]) {
        for (my $index1=0 ; $index1 <= $#{$_[0]->{out_data_line}}; $index1++) {
            if ($_[1] == (&change_16to10(${$_[0]->{out_data_line}}[$index1]))) {
                splice(@{$_[0]->{out_data_line}}, $index1, 1);
                splice(@{$_[0]->{out_data}}, $index1, 1);
                return;
            }
        }
    }
    return;
}
###################################################################################################
#   ＜＜ 行末改行コード削除 ＞＞                                                                  #
###################################################################################################
sub cut_last_0a{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #         $_[1] = 行データ                                                                #
    # 処理 ： 行末の改行コードを削除                                                          #
    # 返却 ： 行データ                                                                        #
    #-----------------------------------------------------------------------------------------#
    if ((substr $_[1], -1) eq "\n") {
        chop $_[1];
    }
}
###################################################################################################
#   ＜＜ 正規表現指定による行抽出の起点行検出 ＞＞                                                #
###################################################################################################
sub get_cond_lr_s {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 行番号                                                                 #
    #      ： $_[1]  = 行データ                                                               #
    #      ： $_[2〜]= 抽出条件（正規表現による列抽出）                                       #
    # 処理 ： 範囲指定なし）行番号指定（抽出区分＝"L"）に変換                                 #
    #         範囲指定あり）起点を行番号指定（抽出区分＝"r"）に変換                           #
    # 返却 ： 起点を行番号指定に変換した抽出条件                                              #
    #-----------------------------------------------------------------------------------------#
    my $line_now  = shift;
    my $line_data = shift;
    my @add_cond  = ();
    
    # 正規表現指定を行番号指定に変換（起点行）
    foreach (@_) {
        if (${$_}[3] eq '') {
            push(@add_cond, ['L', "${$_}[1]", "$line_now", "$line_now", "${$_}[4]", "${$_}[5]", "${$_}[6]", "${$_}[7]"]);
        } elsif (${$_}[3] =~ /^\+\d+$/ ) {
            push(@add_cond, ['L', "${$_}[1]", "$line_now", ($line_now + ${$_}[3]), "${$_}[4]", "${$_}[5]", "${$_}[6]", "${$_}[7]"]);
        } elsif (${$_}[3] =~ /^-\d+$/ ) {
            push(@add_cond, ['L', "${$_}[1]", ($line_now + ${$_}[3]), "$line_now", "${$_}[4]", "${$_}[5]", "${$_}[6]", "${$_}[7]"]);
        } else {
            push(@add_cond, ['r', "${$_}[1]", "$line_now", "${$_}[3]", "${$_}[4]", "${$_}[5]", "${$_}[6]", "${$_}[7]"]);
        }
    }
    # 検出情報を返却
    return @add_cond;
}
###################################################################################################
#   ＜＜ 正規表現指定による行抽出の範囲行検出 ＞＞                                                #
###################################################################################################
sub get_cond_lr_e {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 行番号                                                                 #
    #      ： $_[1]  = 行データ                                                               #
    #      ： $_[2〜]= 抽出条件                                                               #
    # 処理 ： 正規表現（範囲）を行番号指定に変換                                              #
    #-----------------------------------------------------------------------------------------#
    my $line_now  = shift;
    my $line_data = shift;
    
    # 正規表現指定を行番号指定に変換（範囲行）
    foreach (@_) {
        ${$_}[0] = 'L';
        ${$_}[3] = $line_now;
    }
}
###################################################################################################
#   ＜＜ ユーザー抽出 ＞＞                                                                        #
###################################################################################################
sub get_cond_user {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = オブジェクト                                                           #
    #      ： $_[1〜]= ユーザー引数                                                           #
    # 処理 ： ユーザー関数の呼出し                                                            #
    # 返却 ： ユーザー関数が返却した抽出対象区分                                              #
    #-----------------------------------------------------------------------------------------#
    my $obj             = shift;
    my $extraction_data = "";
    
    foreach (@_) {
        &seek_line($obj, $obj->{line_now});
        # ユーザー関数の呼出し
        my $user_sub = '&'.${$_}[1].'(';
        for (my $index1=2 ; $index1 <= $#{$_}; $index1++) {
            if ($index1 > 2) {
                $user_sub .= ', ';
            }
            $user_sub .= '"'.${$_}[$index1].'"';
        }
        $user_sub .= ');';
        $extraction_data = $extraction_data | eval($user_sub);
    }
    &seek_line($obj, ($obj->{line_now} + 1));
    return &change_2toB("$extraction_data");
}
###################################################################################################
#   ＜＜ 行・ブロック抽出 ＞＞                                                                    #
###################################################################################################
sub get_cond_lc {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 行データ                                                               #
    #      ： $_[1〜]= 抽出条件（処理行の行・ブロック抽出）                                   #
    # 処理 ： 行抽出、列抽出（列番号指定による列抽出、正規表現指定による列抽出）              #
    # 返却 ： 抽出対象区分                                                                    #
    #-----------------------------------------------------------------------------------------#
    my $line_data = shift;
    
    if ((grep{${$_}[4] eq ''}@_) > 0) {
        # 行抽出
        return &change_2toB("1");
    } else {
        # 列抽出
        my $extraction_data = &get_cond_c($line_data, grep{${$_}[4] eq 'C'}@_);
        $extraction_data = $extraction_data | &get_cond_cr($line_data, grep{${$_}[4] eq 'CR'}@_);
        return $extraction_data;
    }
}
###################################################################################################
#   ＜＜ 列番号指定による列抽出 ＞＞                                                              #
###################################################################################################
sub get_cond_c {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 行データ                                                               #
    #      ： $_[1〜]= 抽出条件（列番号による列抽出）                                         #
    # 処理 ： 列番号指定による列抽出                                                          #
    # 返却 ： 抽出対象区分                                                                    #
    #-----------------------------------------------------------------------------------------#
    my $col_su          = &get_col_data("", shift);
    my $col_start       = undef;
    my $col_end         = undef;
    my $col_add         = undef;
    my $in_kbn          = undef;
    my $in_start        = undef;
    my $in_end          = undef;
    my $extraction_data = "0" x $col_su;
    
    foreach (@_) {
        # 抽出判定対象をチェック
        if (${$_}[0] eq 'C') {
            $col_add = 0;
        } else {
            $col_add = 4;
        }
        # 起点を設定
        if (${$_}[2] eq 'E' or ${$_}[2] eq 'e') {
            $col_start = $col_su;
        } else {
            $col_start = ${$_}[(2 + $col_add)];
        }
        # 範囲を算出
        if (${$_}[(3 + $col_add)] eq '') {
            # 範囲なし
            $col_end = $col_start;
        } elsif (${$_}[(3 + $col_add)] eq 'E' or ${$_}[(3 + $col_add)] eq 'e') {
            # 最終列まで
            if ($col_start <= $col_su) {
                $col_end = $col_su;
            } else {
                $col_end = $col_start;
            }
        } elsif (${$_}[(3 + $col_add)] =~ /^\-(\d+)$/) {
            # −ｎ列まで
            $col_end   = $col_start;
            $col_start = $col_start + ${$_}[(3 + $col_add)];
        } elsif (${$_}[(3 + $col_add)] =~ /^\+(\d+)$/) {
            # ＋ｎ列まで
            $col_end   = $col_start + ${$_}[(3 + $col_add)];
        } elsif (${$_}[(2 + $col_add)] <= ${$_}[(3 + $col_add)]) {
            # 後続指定列まで
            $col_end   = ${$_}[(3 + $col_add)];
        } else {
            # 先行指定列まで
            $col_end   = $col_start;
            $col_start = ${$_}[(3 + $col_add)];
        }
        if ($col_start < 0) {$col_start = 0}
        if ($col_end   < 0) {$col_end   = 0}
        # 抽出対象列を設定
        for (my $index2=1; $index2 <= $col_su; $index2++) {
            if ((${$_}[(1 + $col_add)] eq '' and $index2 >= $col_start and $index2 <= $col_end) or (${$_}[(1 + $col_add)] ne '' and ($index2 < $col_start or $index2 > $col_end))) {
                substr($extraction_data, $index2, 1) = "1";
            }
        }
    }
    return &change_2toB("$extraction_data");
}
###################################################################################################
#   ＜＜ 正規表現指定による列抽出 ＞＞                                                            #
###################################################################################################
sub get_cond_cr {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 行データ                                                               #
    #      ： $_[1〜]= 抽出条件（正規表現による列抽出）                                       #
    # 処理 ： 正規表現指定による列抽出                                                        #
    # 返却 ： 抽出対象区分                                                                    #
    #-----------------------------------------------------------------------------------------#
    my $line_data       = shift;
    my $col_su          = &get_col_data("", "$line_data");
    my $col_start       = undef;
    my $col_end         = undef;
    my $col_add         = undef;
    my $in_kbn          = undef;
    my $in_start        = undef;
    my $in_end          = undef;
    my $extraction_data = "0" x $col_su;
    
    foreach (@_) {
        # 抽出判定対象をチェック
        if (${$_}[0] eq 'CR') {
            $col_add = 0;
        } else {
            $col_add = 4;
        }
        # 正規表現を補正
        my $check_key1 = '';
        ${$_}[(2 + $col_add)] =~  s/^\\s\*|^\\,\*|^,\*|^\[\\s\]\*|^\[\\,\]\*|^\[,\]\*|^\[\\,\\s\]\*|^\[,\\s\]\*|^\[\\s\\,\]\*|^\[\\s,\]\*//;
        ${$_}[(2 + $col_add)] =~  s/^(\[.*)\\s(.*\]\*)/$1$2/;
        ${$_}[(2 + $col_add)] =~  s/^(\[.*)\\,(.*\]\*)/$1$2/;
        ${$_}[(2 + $col_add)] =~  s/^(\[.*),(.*\]\*)/$1$2/;
        if (${$_}[(2 + $col_add)] !~ /^\^|^\\s|^\\,|^,|^\[.*\\s|^\[.*\\,|^\[.*,/) {
            $check_key1 .= '[^\s\,]*';
        }
        $check_key1 .= ${$_}[(2 + $col_add)];
        if (${$_}[(2 + $col_add)] !~ /\$$|\\s\*$|\\s\+$|\\s$|,\*$|,\+$|,$|\[.*\\s.*\]\*$|\[.*\\s.*\]\+$|\[.*,.*\]\*$|\[.*,.*\]\+$/) {
            $check_key1 .= '[^\s\,]*';
        }
        my $check_key2 = '';
        if (${$_}[(3 + $col_add)] ne '' and ${$_}[(3 + $col_add)] !~ /^[\+-]\d+$/) {
      ##if (${$_}[(3 + $col_add)] ne '' and ${$_}[(3 + $col_add)] !~ /^\+\d+$/) {
            ${$_}[(3 + $col_add)] =~  s/^\\s\*|^\\,\*|^,\*|^\[\\s\]\*|^\[\\,\]\*|^\[,\]\*|^\[\\,\\s\]\*|^\[,\\s\]\*|^\[\\s\\,\]\*|^\[\\s,\]\*//;
            ${$_}[(3 + $col_add)] =~  s/^(\[.*)\\s(.*\]\*)/$1$2/;
            ${$_}[(3 + $col_add)] =~  s/^(\[.*)\\,(.*\]\*)/$1$2/;
            ${$_}[(3 + $col_add)] =~  s/^(\[.*),(.*\]\*)/$1$2/;
            if (${$_}[(3 + $col_add)] !~ /^\^|^\\s|^\\,|^,|^\[.*\\s|^\[.*\\,|^\[.*,/) {
                $check_key2 .= '[^\s\,]*';
            }
            $check_key2 .= ${$_}[(3 + $col_add)];
            if (${$_}[(3 + $col_add)] !~ /\$$|\\s\*$|\\s\+$|\\s$|,\*$|,\+$|,$|\[.*\\s.*\]\*$|\[.*\\s.*\]\+$|\[.*,.*\]\*$|\[.*,.*\]\+$/) {
                $check_key2 .= '[^\s\,]*';
            }
        }
        
        my @cond_c_new = ();
        $col_start = 0;
        $col_end   = 0;
        while ($line_data =~ /($check_key1)(.*)/) {
            my $next_data = $2;
            # 抽出範囲を算出
            my @split_out1 = split /($check_key1)/, $line_data, 3;
            my $split_out1_add = 0;
            if ($split_out1[0] =~ /^\s+\,*\s*$|^\,+\s*$/) {
            } else {
                if ($split_out1[0] =~ /^\s+\,*\s*|^\,+\s*/ and $split_out1[0] =~ /\s+\,*\s*$|\,+\s*$/) {
                    $split_out1_add--;
                }
            }
            $col_start = $col_start + (&get_col_data("", "$split_out1[0]")) + $split_out1_add + 1;
            my $col_split_out1 = &get_col_data("", "$split_out1[1]");
            my $col_end2 = $col_start + $col_split_out1 - 1;
            if (${$_}[(3 + $col_add)] eq '') {
                # 範囲なし
                $col_end = $col_end2;
            } elsif (${$_}[(3 + $col_add)] =~ /^\+(\d+)$/) {
                # ＋ｎ列まで
                $col_end = $col_end2 + ${$_}[(3 + $col_add)];
            } elsif (${$_}[(3 + $col_add)] =~ /^-(\d+)$/) {
                # −ｎ列まで
                $col_start = $col_start + ${$_}[(3 + $col_add)];
                $col_end   = $col_end2;
            } else {
                # 正規表現の列まで
                if ($next_data =~ /($check_key2)(.*)/) {
                    my $back_data = $2;
                    my @split_out2 = split /($check_key2)/, $next_data, 3;
                    $col_end = $col_su - (&get_col_data("", "$back_data")) + 1;
                } else {
                    $col_end = $col_su;
                }
            }
            if ($col_start < 0) {$col_start = 0}
            if ($col_end   < 0) {$col_end   = 0}
            for (my $index3=$col_start; $index3 <= $col_end; $index3++) {
                $cond_c_new[$index3] = '1';
            }
            $col_start = $col_end2;
            $line_data = $next_data;
        }
        # 抽出対象列を設定
        for (my $index2=1; $index2 <= $col_su; $index2++) {
            if ((${$_}[(1 + $col_add)] eq '' and $cond_c_new[$index2] eq '1') or (${$_}[(1 + $col_add)] ne '' and $cond_c_new[$index2] eq '')) {
                substr($extraction_data, $index2, 1) = "1";
            }
        }
    }
    return &change_2toB("$extraction_data");
}
###################################################################################################
#   ＜＜ 抽出データを取得 ＞＞                                                                    #
###################################################################################################
sub get_extraction_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 行データ                                                                #
    #      ： $_[1] = 抽出対象区分                                                            #
    # 処理 ： 抽出対象区分から抽出データを取得                                                #
    # 返却 ： 抽出データ                                                                      #
    #-----------------------------------------------------------------------------------------#
    if ($_[1] =~ /^1/) {
        # 行抽出
        return $_[0];
    } else {
        # 列抽出
        my @col_data = &get_col_data("", "$_[0]"); unshift @col_data, '';
        my $out_data = "";
        for (my $index=1; $index <= $#col_data; $index++) {
            if ((substr $_[1], $index, 1) eq "1") {
                $out_data .= "$col_data[$index] ";
            }
        }
        chop $out_data;
        return $out_data;
    }
}
1;
