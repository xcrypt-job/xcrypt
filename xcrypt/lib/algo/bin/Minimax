#!/usr/bin/env perl

my $word = &minimax(@ARGV);
print $word;

sub isMyTurn { # Int -> Bool
    if ($_[0] == 0) {return 1;}
    else {
	my $i = 0;
	while (2 ** ($i + 1) - 2 < $_[0]) {
	    $i = $i + 1;
	}
	return ($i + 1) % 2;
    }
}

sub minimax { # Int -> Int -> Int
    my $depth    = $_[0];
    my $inf      = - (2 ** 31) + 1;
    my $sup      = (2 ** 31) - 1;
    my $position = $_[1];
    return minimaxBody($depth, $inf, $sup, $position, $_[2], $_[3]);
}

sub minimaxBody { # Int -> Int -> Int -> Int -> Int
    my $depth    = $_[0];
    my $max      = $_[1];
    my $min      = $_[2];
    my $position = $_[3];
    my $getChildren = $_[4];
    my $staticEvaluation = $_[5];
    my $gc ='./' . $getChildren;
    my $pre_children = qx/$gc $position/;
    my @children = split(/ /, $pre_children);
    if (($depth == 0) || ($#children == -1)) {
	my $se ='./' . $staticEvaluation;
	my $result = qx/$se $position/;
	return $result;
    }
    if (main::isMyTurn($position)) {
	foreach (@children) {
	    my $score = minimaxBody(($depth - 1), $_[1], $_[2], $_, $getChildren, $staticEvaluation);
	    if ($score > $max) {$max = $score;}
	}
	return $max;
    }
    else {
	foreach (@children) {
	    my $score = minimaxBody(($depth - 1), $_[1], $_[2], $_, $getChildren, $staticEvaluation);
	    if ($score < $min) {$min = $score;}
	}
     return $min;
    }
}
