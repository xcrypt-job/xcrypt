#!/usr/bin/env perl
package jobsched;

use strict;
use Cwd;
use File::Basename;
use File::Spec;
#use jobsched;

##############################
sub cmd_executable {
    my ($cmd) = @_;
    my @cmd0 = split(/\s+/,$cmd);
    qx/which $cmd0[0]/;
    my $ex_code = $? >> 8;
    # print "$? $ex_code ";
    return ($ex_code==0)? 1 : 0;
}
##############################

if ( $ENV{XCRYPT} ) {
    if ($ENV{PERL5LIB} eq '') { $ENV{PERL5LIB} = File::Spec->catfile($ENV{XCRYPT}, 'lib'); }
    else { $ENV{PERL5LIB} = File::Spec->catfile($ENV{XCRYPT}, 'lib') . ":" . $ENV{PERL5LIB}; }
} else {
    die "Set the environment varialble XCRYPT.\n";
}

# Load jobscheduler config files.
my $jobsched = undef;
my $jobsched_config_dir = undef;
our %jobsched_config = undef;
if ( $ENV{XCRYPT} ) {
    $jobsched_config_dir = File::Spec->catfile ($ENV{XCRYPT}, 'lib', 'config');
} else {
    die "Set the environment varialble XCRYPT.\n";
}
unless ( $ENV{XCRJOBSCHED} ) {
    die "Set the environment varialble XCRJOBSCHED.\n";
} else {
    $jobsched = $ENV{XCRJOBSCHED};
    unless ( -f File::Spec->catfile ($jobsched_config_dir, $jobsched . ".pm") ) {
        die "No config file for $jobsched ($jobsched.pm) in $jobsched_config_dir";
    }
}
foreach ( glob (File::Spec->catfile ($jobsched_config_dir, "*" . ".pm")) ) {
    do $_;
}

my $qstat_command = $jobsched_config{$jobsched}{qstat_command};
unless ( defined $qstat_command ) {
    die "qstat_command is not defined in $jobsched.pm";
}
unless (cmd_executable ($qstat_command)) {
    die "$qstat_command not executable";
}

my $qstat_extractor = $jobsched_config{$jobsched}{extract_req_ids_from_qstat_output};
unless ( defined $qstat_extractor ) {
    die "extract_req_ids_from_qstat_output is not defined in $jobsched.pm";
} elsif ( ref ($qstat_extractor) ne 'CODE' ) {
    die "Error in $jobsched.pm: extract_req_ids_from_qstat_output must be a function.";
}

my $current_directory=Cwd::getcwd();
my $inventory_path=File::Spec->catfile($current_directory, 'inv_watch');
my $idfiles = File::Spec->catfile($inventory_path, '.request_ids');
my @qstat_out = qx/$qstat_command/;
my @ids = &$qstat_extractor (@qstat_out);
foreach my $req_id (@ids) {
    open (REQIDS, "< $idfiles");
    my $line = <REQIDS>;
    my @array = split(/ /, $line);
    my %hash = @array;
    close (REQIDS);
    my $hoge = $hash{"$req_id"};
    print "$hoge is waiting or running.\n";
}
#print "--- 8< --- 8< --- 8< ---\n";
