#!/usr/bin/env perl

my $branch = 4;

my %val;
open(TREE, "< $ARGV[2]");
my $line = <TREE>;
my @array = split(' ', $line);
%val = @array;
close(TREE);

my $word = &alphabeta((- (2 ** 31) + 1), ((2 ** 31) - 1),
		      (- (2 ** 31) + 1), ((2 ** 31) - 1),
		      @ARGV);
print $word;

sub isMyTurn { # Int -> Bool
    my $i = 1;
    while ((($branch ** $i - 1) / 3) <= $_[0]) { $i = $i + 1; }
    return ($i) % 2;
}

sub getchildren {
    my @bar;
    foreach (1..$branch) {
	my $foo = $branch * $_[0] + $_;
	push(@bar, $foo);
    }
    return @bar;
}

sub inverse {
    return (10000000 / $_[0]);
}

sub alphabeta {
    my ($inf, $sup, $alpha, $beta, $depth, $pos,
	$staticevaluation, $getchildren) = @_;

#    my $gc ='./' . $getchildren;
#    my $pre_children = qx/$gc $pos/;
#    my @children = split(/ /, $pre_children);
    my @children = &getchildren($pos);
    if (($depth == 0) || ($#children == -1)) {
	my $se ='./' . $staticevaluation;
#	my $result = qx/$se $pos/;
	my $result = &inverse($pos);
#	my $result = int(rand(1000));
#	my $result = $val{"$pos"};
	return $result;
    }
    my $max = $inf;
    my $min = $sup;
    if (isMyTurn($pos)) {
	foreach (@children) {
	    my $score = alphabeta($max, $min, $alpha, $beta, ($depth - 1), $_,
				  $staticevaluation, $getchildren);
	    if ($alpha <= $score) {
		$alpha = $score;}
	    if ($beta <= $alpha) {
		return $beta;
	    }
	    if ($score > $max) { $max = $score; }
	}
	return $max;
    } else {
	foreach (@children) {
	    my $score = alphabeta($max, $min, $alpha, $beta, ($depth - 1), $_,
				  $staticevaluation, $getchildren);
	    if ($score <= $beta) {
		$beta = $score;
	    }
	    if ($beta <= $alpha) {
		return $alpha;
	    }
	    if ($score < $min) { $min = $score; }
	}
     return $min;
    }
}
