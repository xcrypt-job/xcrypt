\documentclass[report]{jsbook}

\usepackage{tascmac}
\usepackage[all]{xy}

\title{Xcrypt マニュアル}
\author{京大中島研e-scienceグループ}

\begin{document}
\maketitle
\tableofcontents

\paragraph{メモ}

Daniel Muey 氏の Recursive.pm を使用している．ライセンス的には問題ない
はず．

\part{総論}
\chapter{はじめに}

\section{機能}

通常，ある一つの大きな処理を行うには，その処理を小分け（ジョブと呼ぶ）
にし，それらの処理をジョブスケジューラに依頼する．具体的には，
\begin{enumerate}
\item ジョブスケジューラが理解できるスクリプトを作成し，
\item そのスクリプトをジョブスケジューラに渡し，
\item ジョブスケジューラが返す結果からまた別のスクリプトを作成し，それ
      をジョブスケジューラに渡す，
\end{enumerate}
という一連の操作を繰り返すというものである．

しかし，この方法は処理の繰り返しごとに人手による介入を要し，作業効率が
悪い．そこで，人手で行うところを適当なスクリプト言語により記述すること
で自動実行を実現することが考えられる．Xcrypt はそのスクリプト言語とし
て Perl を採用し，パラメタ指定によるジョブの生成や投入を Perl の関数と
して提供することで，ユーザがジョブ処理を容易に行うことを補助する．

TODO: サーチアルゴリズム等のアルゴリズムモジュールの提供についても記述
する．

\section{動作環境}

・sh 系（sh，bash，zsh 等）または csh 系（csh，tcsh 等）シェル

・Perl 5.10.0（GUI 利用時には Perl/Tk 8.4 も要）


\chapter{Xcrypt スクリプトの記述}

Xcrypt は Perl の拡張である．よって，全ての Perl スクリプトは Xcryptス
クリプトである．しかし，Xcrypt はジョブに関する操作の補助を行うものと考
えられ，Xcrypt スクリプトは典型的には以下の順に記述される．

\def\usemodule{モジュールに関する記述}
\def\setglobalvar{大域変数に関する記述}
\def\defjobdefhash{ジョブ定義ハッシュに関する記述}
\def\operation{ジョブ処理に関する記述}

\begin{enumerate}
 \item \usemodule
 \item \setglobalvar
 \item \defjobdefhash
 \item \operation
\end{enumerate}

\section{\usemodule}

モジュールは
\begin{boxnote}
\begin{verbatim}
use base qw(core);
\end{verbatim}
\end{boxnote}
\noindent
と記述して読み込む．複数読み込む場合は読み込みたい順に
\begin{boxnote}
\begin{verbatim}
use base qw(dry core);
\end{verbatim}
\end{boxnote}
\noindent
と記述して読み込む．利用可能なモジュールに関しては\ref{chapmodule}章で
述べる．

\section{\setglobalvar}

Xcrypt スクリプトの動作全体に関わる大域変数（例えば
\texttt{\$separator} ）は
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}
\noindent
と記述してセットする．

\section{\defjobdefhash}

Xcrypt ではジョブはハッシュ（ジョブハッシュと呼ぶ）で実現されている．ジョ
ブを定義するにあたり，ハッシュ自身を記述してもよいが，ジョブ定義ハッシュ
と呼ばれるハッシュを記述すれば，ジョブを生成する際，さらにパラメタを与
えることで多数のジョブを一度に生成できる．例えば，
\begin{boxnote}
\begin{verbatim}
%xyz = (
    'id' => 'job100',
    'exe' => './kempo',
    'arg0' => '100',
    'arg1' => 'plasma.inp',
    'linkedfile0' => 'kempo',
    'copiedfile0' => 'plasma.inp',
    'stdofile' => 'hogeout',
    'stdefile' => 'hogeerr',
    'queue' => 'gh10034',
    'option' => '# @$-g gh10034'
);
\end{verbatim}
\end{boxnote}
\noindent
と記述する．定義可能なジョブ定義ハッシュのキーに関しては
\ref{chapjobdefhash}章で述べる．

\section{\operation}

通常，人手で行う処理で，今回，Xcrypt に行わせたい処理について記述す
る．Xcrypt で利用可能な関数については\ref{chapfun}章で述べる．

\section{記述例}\label{secscriptexample}

本章で前節までの説明を踏まえたスクリプト記述例を以下に示す．

\begin{boxnote}
\begin{verbatim}
use base qw(limit core);

$limit::smph=Thread::Semaphore->new(10);
$separator = '-';

%xyz = (
    'id' => 'job100',
    'exe' => './kempo',
    'arg0' => 'plasma.inp',
    'arg1' => '100',
    'copieddir0' => 'forcopieddir',
    'linkedfile0' => 'kempo',
    'copiedfile0' => 'plasma.inp',
    'stdofile' => 'hogeout',
    'stdefile' => 'hogeerr',
    'queue' => 'gh10034',
    'option' => '# @$-g gh10034'
);

my @jobs = &prepare(%xyz, 'arg1S' => [2,4]);
my @thrds = &submit(@jobs);
my @results  = &sync(@thrds);
\end{verbatim}
\end{boxnote}

\chapter{ジョブ処理の流れ}

実際のジョブ処理の流れについて概観する．

\section{概念図}

{\large
\[
\entrymodifiers={+[F-:<10pt>]}
\xymatrix@=100pt{
  *{}
  \ar[r]|(.4){\txt{\small オブジェクト生成}} &
  \txt{active} \ar[rrd]|(.3){\txt{\small \texttt{xcryptdel}入力}}|\hole \ar[r]|{\txt{\small \texttt{qsub}実行}} &
  \txt{submitted} \ar[rd]|!{[r];[dl]}\hole|{\txt{\small \texttt{qsub}失敗}} \ar[r]|{\txt{\small \texttt{qsub}成功}} &
  \txt{queued} \ar[lld]|(.7){\txt{\small スクリプト開始}} \ar[d]|{\txt{\small 当該ジョブ消滅}}\\
  *{} &
  \txt{running} \ar[r]|{\txt{\small スクリプト終了}} \ar@/_5pc/[rr]|{\txt{\small 当該ジョブ消滅}}&
  \txt{done} &
  \txt{aborted}
}
\]
}

\section{実行方法}

環境変数 \texttt{XCRYPT} を Xcrypt をインストールしたディレクトリで定義
する（ここでは \texttt{/usr/share/xcrypt} と仮定する）．シェルが bash
なら，
\begin{screen}
\texttt{\$ XCRYPT=/usr/share/xcrypt; export XCRYPT}
\end{screen}

環境変数 \texttt{XCRJOBSCHED} をジョブスケジューラの名前
\footnote{\texttt{NQS}と\texttt{SGE}とが利用可能である．また，環境変数
\texttt{XCRJOBSCHED} に \texttt{sh} も利用可能である．この場合，ジョブ
をOSのプロセスとして扱い，ジョブスケジューラが導入されていない環境にお
けるジョブの投入・削除・状態取得を行う．}に設定する．シェルが bash
なら，例えば，
\begin{screen}
\texttt{\$ XCRJOBSCHED=SGE; export XCRJOBSCHED}
\end{screen}
とする．

作業ディレクトリに移動する（ここでは \texttt{\$HOME/wd} とする）．
\begin{screen}
\texttt{\$ cd \$HOME/e-science/wd}
\end{screen}

Xcrypt スクリプト（\ref{secscriptexample}節参照）を作成する（ここでは
\texttt{sample.xcr} とする）．

実行する．
\begin{screen}
\texttt{\$ \$XCRYPT/xcrypt sample.xcr}
\end{screen}

\section{作成される物}

Xcrypt を実行した際，作業ディレクトリ以下に作成される物について説明する．

\subsection*{ディレクトリ}

Xcrypt はジョブごとにディレクトリ（ジョブ作業ディレクトリと呼ぶ）を作成
する．ディレクトリの名前はジョブハッシュの\texttt{id}キーの値である．
ジョブ処理はジョブ作業ディレクトリで行われる．

\subsection*{ジョブリンク・ジョブファイル}

ジョブ作業ディレクトリからジョブハッシュの
\texttt{linkedfile0,...,linkedfile255}キーの値で指定されているファイル
へシンボリックリンクを張り，\texttt{copiedfile0,...,copiedfile255}キー
の値で指定されている作業ディレクトリ中のファイルのコピーをジョブ作業ディ
レクトリに作成する．

\subsection*{\texttt{nqs.sh}}

ジョブスケジューラが NQS である際，NQS に渡されるスクリプトである．

\subsection*{\texttt{sge.sh}}

ジョブスケジューラが Sun Grid Engine である際，Sun Grid Engine に渡され
るスクリプトである．

\subsection*{\texttt{sh.sh}}

シェルをジョブスケジューラとして仮想的に利用す際，シェルに渡されるスク
リプトである．

\subsection*{\texttt{request\_id}}

Xcrypt によるジョブの投入に対し，ジョブスケジューラが返すジョブのリクエ
ストIDを格納する．

\subsection*{\texttt{stdout}}

ジョブの実行コマンドの標準出力が格納される．ジョブハッシュの
\texttt{stdofile}キーの値が指定されている場合，その値のファイル名で作成
される．

\subsection*{\texttt{stderr}}

ジョブの実行コマンドの標準エラー出力が格納される．ジョブハッシュの
\texttt{stdefile}キーの値が指定されている場合，その値のファイル名で作成
される．

\part{各論}
\chapter{モジュール}\label{chapmodule}

\section{\texttt{core}}

コアモジュールを全て読み込む．Xcrypt 特有のもの（ジョブ定義ハッシュ等）
を使用する場合には必ず読み込まないといけない．

\section{\texttt{dry}}

Xcrypt をドライモード（コマンドの実行のみ行わないモード）で動作させるこ
とができる．

ジョブ定義ハッシュに $\texttt{dry}$ というキーが使えるようになる．ジョ
ブ定義ハッシュに
\begin{boxnote}
\begin{verbatim}
...
'dry' => 1,
...
\end{verbatim}
\end{boxnote}
\noindent
と記述することでジョブがドライモードで動作する．

\if0
また，
\begin{screen}
\texttt{\$ xcrypt -d sample.xcr}
\end{screen}
\noindent
とオプションつきで実行することでドライモードで動作させることもできる．
\fi

\section{\texttt{limit}}

一度に投入されるジョブの数の上限を指定する．

\begin{boxnote}
\begin{verbatim}
$limit::smph=Thread::Semaphore->new(100);
\end{verbatim}
\end{boxnote}

\if0
\section{\texttt{minimax}}

あるノードからその子ノードを与えるプログラムと，ノードに対する評価関数
であるプログラムとを与えることで，木アルゴリズムであるミニマックス法を
行う．

例えば，前者のプログラムを \texttt{getchildren}，後者のプログラムを
\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari} とする
時，

\begin{boxnote}
\begin{verbatim}
%xyz = (
    'id'          => 'job10',
    'linkedfile0' => 'getchildren',
    'linkedfile1' => 'komadoku',
    'linkedfile2' => 'kuraidori',
    'linkedfile3' => 'ikiataribattari',
    'arg0'        => '9',               # depth of lookahead
    'arg1'        => '0',               # position
    'arg2'        => 'getchildren'      # get next positions
);

@results = &prepare_submit_sync(%xyz, 'arg3S' => ['komadoku',
				                  'kuraidori',
				                  'ikiataribattari']);
\end{verbatim}
\end{boxnote}

\noindent
と記述すること
で，\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari}，の
三つの評価関数下における \texttt{0} の位置のノードから \texttt{9} の深
さで先読みした際の値をそれぞれ返す．
\fi

\chapter{大域変数}\label{globalvar}

\section{\texttt{separator}}

ジョブ作業ディレクトリ以下にジョブ定義ハッシュにおける
\texttt{id,arg0,\ldots,arg255}を\texttt{\$separator}で区切った
名前のディレクトリを作成する．\texttt{\$separator}のデフォルト
値は「\texttt{\_}」である．「\texttt{-}」に変えたい場合は，
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}
とする．

使用できるシンボルは \verb*+ "$%&'/:;<=>?[\]`{|}+ を除く ASCII 印字可能文字とする．

\section{\texttt{separator\_nocheck}}

この値を $1$ にすると \texttt{\$separator} が使用できるシンボルである
かのチェックを飛ばす．デフォルト値は $0$ である．

\chapter{ジョブ定義ハッシュ}\label{chapjobdefhash}

ジョブ定義ハッシュにおいて利用可能なキーについて紹介する．

\section{\texttt{id}}

実行されるジョブを識別する語を記述する．

使用できるシンボルは \verb*+ "$%&'/:;<=>?[\]`{|}+ を除く ASCII 印字可能文字とする．

\section{\texttt{exe}}

実行されるジョブの実行コマンドを記述する．後述の\texttt{arg0,...,arg255}とともに
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}
といった形で実行される．

\section{\texttt{arg0,...,arg255}}

実行されるジョブの実行コマンドの引数を記述する．前述の\texttt{exe}とと
もに
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}
といった形で実行される．

\section{\texttt{linkedfile0,...,linkedfile255}}

この値のリンク名でジョブ作業ディレクトリから作業ディレクトリのファイル
へシンボリックリンクを張る．

\section{\texttt{copiedfile0,...,copiedfile255}}

この値のファイル名でジョブ作業ディレクトリから作業ディレクトリにコピー
をつくる．

\section{\texttt{copieddir0,...,copieddir255}}

この値の名前であるディレクトリ中のファイルから作業ディレクトリにコピー
をつくる．

\section{\texttt{stdofile}}

この値のファイル名で実行プログラムとジョブスケジューラの標準出力を格納
する．空の場合は「stdout」というファイル名になる．

\section{\texttt{stdefile}}

この値のファイル名で実行プログラムとジョブスケジューラの標準エラー出力
を格納する．空の場合は「stderr」というファイル名になる．

\section{\texttt{queue}}

実行するジョブを投入するキューの名前を記述する．

\section{\texttt{cpu}}

使用するコア数を指定する．

\section{\texttt{proc}}

使用するプロセス数を指定する．

\section{\texttt{option}}

ジョブスケジューラのオプションを記述する．

\section{\texttt{predecessor}}

ジョブを，値であるところのジョブたちの処理が終わるまで投入しないものと
する．

\section{\texttt{successor}}

ジョブ処理後，値であるところのジョブたちを生成する．

\chapter{組込み関数}\label{chapfun}

Xcrypt で利用可能な組込み関数のうち，Perl の組込み関数でないものについ
て紹介する．

\def\format{書式}
\def\example{記述例}
\def\advanced{発展}


\section{\texttt{prepare}}

ジョブ定義ハッシュと（リファレンス\footnote{本稿ではリファレンスは型グ
ロブを含まないものとする．}またはスカラで与えられる）パラメタを受け取
り，適当なジョブリファレンスの配列を返す．特に，ジョブの\texttt{id}は後
述の\texttt{RANGE0,...,RANGE255}により生成される．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
prepare(ジョブ定義ハッシュ[,'RANGE0' => (配列リファレンス)]
                      ...[,'RANGE255' => (配列リファレンス)]
                         [,'ジョブ定義ハッシュキーS' => (リファレンス||スカラ)]
                      ...[,'ジョブ定義ハッシュキーS' => (リファレンス||スカラ)]);
\end{verbatim}
\end{boxnote}

ただし，「ジョブ定義ハッシュキー\texttt{S}」はジョブ定義ハッシュキー
（\texttt{arg0}等）の語尾に\texttt{S}をつけ加えたもの
（\texttt{arg0S}等）を意味するものとする．

\texttt{RANGE0,...,RANGE255}の値であるところの配列リファレンスにおける配列に使用できるシンボルは \verb*+ "$%&'/:;<=>?[\]`{|}+ を除く ASCII 印字可能文字とする．

\subsection{\example}

\begin{boxnote}
\begin{verbatim}
@jobs = prepare('id' => 'xyz', 'exe' => './kempo', 'arg0S' => [10,20]);
\end{verbatim}
\end{boxnote}

これは以下と同義である．

\begin{boxnote}
\begin{verbatim}
@jobs = ();
push(@jobs, {'id' => 'xyz_0', 'exe' => './kempo', 'arg0' => '10'});
push(@jobs, {'id' => 'xyz_1', 'exe' => './kempo', 'arg0' => '20'});
\end{verbatim}
\end{boxnote}

宣言的に書くこともできる．

\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo',
    'arg0S' => [10,20]
);
prepare(%abc);
\end{verbatim}
\end{boxnote}

ジョブ定義ハッシュとパラメタを分けて書くこともできる．

\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
prepare(%abc, 'arg0S' => [10,20]);
\end{verbatim}
\end{boxnote}

\texttt{RANGE0}と関数リファレンスを使うことでさまざまなパラメタでジョブ
を生成することができる．例えば，
\begin{boxnote}
\begin{verbatim}
@jobs = prepare(%abc, 'RANGE0' => [0..99], 'arg0S' => sub { 2 * $_[0] });
\end{verbatim}
\end{boxnote}
は\texttt{prepare(\%abc, 0), prepare(\%abc, 2),..., prepare(\%abc,
198)}を順番に行ったものと同義である．


\subsection{\advanced}

パラメタは複数書くことができる．複数パラメタの配列の頭からジョブは生成
される．例えば，

\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
@jobs = prepare(%abc, 'arg0S' => [0,1], 'arg1S' => [2,3]);
\end{verbatim}
\end{boxnote}
は以下と同義である．
\begin{boxnote}
\begin{verbatim}
@jobs = ();
push(@jobs, {'id' => 'xyz_0', 'exe' => './kempo', 'arg0' => '0', 'arg1' => '2'});
push(@jobs, {'id' => 'xyz_1', 'exe' => './kempo', 'arg0' => '1', 'arg1' => '3'});
\end{verbatim}
\end{boxnote}

\texttt{RANGE0}等と関数リファレンスを使うことでパラメタをかけ合わせてジョ
ブを生成することができる．例えば，
\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
@jobs = prepare(%abc, 'RANGE0' => [0,1], 'RANGE1' => [2,4],
                'arg0S' => sub { $_[0] + $_[1] });
\end{verbatim}
\end{boxnote}
は以下と同義である．
\begin{boxnote}
\begin{verbatim}
@jobs = ();
push(@jobs, {'id' => 'xyz_2', 'exe' => './kempo', 'arg0' => '2'});
push(@jobs, {'id' => 'xyz_4', 'exe' => './kempo', 'arg0' => '4'});
push(@jobs, {'id' => 'xyz_3', 'exe' => './kempo', 'arg0' => '3'});
push(@jobs, {'id' => 'xyz_5', 'exe' => './kempo', 'arg0' => '5'});
\end{verbatim}
\end{boxnote}

引数がリファレンスでなくスカラである時，引数は \texttt{eval} される．ゆ
えに，上記は，
\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
@jobs = prepare(%abc, 'RANGE0' => [0,1], 'RANGE1' => [2,4],
                'arg0S' => '$_[0] + $_[1]');
\end{verbatim}
\end{boxnote}
とも書くこともできる．

\section{\texttt{submit}}

ジョブリファレンスの配列を受け取り，各ジョブをジョブスケジューラに渡
し，ジョブスケジューラからジョブスレッドを受け取り，それらの配列を返す．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
submit(ジョブリファレンスの配列);
\end{verbatim}
\end{boxnote}

\subsection{\example}

典型的には\texttt{prepare}の返り値を引数にとる．

\begin{boxnote}
\begin{verbatim}
@jobs = prepare('id' => 'xyz', 'exe' => './kempo', 'arg0S' => [10,20]);
submit(@jobs);
\end{verbatim}
\end{boxnote}

自力でジョブリファレンスの配列を書いてもよい．

\begin{boxnote}
\begin{verbatim}
submit({'id' => 'xyz_0', 'exe' => './kempo', 'arg0' => '10'},
       {'id' => 'xyz_1', 'exe' => './kempo', 'arg0' => '20'});
\end{verbatim}
\end{boxnote}

\section{\texttt{sync}}

ジョブスレッドの配列を受け取り，ジョブ処理後のジョブリファレンスの配列
を返す．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
sync(ジョブスレッドの配列);
\end{verbatim}
\end{boxnote}

\subsection{\example}

典型的には\texttt{submit}の返り値を引数にとる．

\begin{boxnote}
\begin{verbatim}
@jobs = prepare('id' => 'xyz', 'exe' => './kempo', 'arg0S' => [10,20]);
@thrds = submit(@jobs);
sync(@thrds);
\end{verbatim}
\end{boxnote}

\section{\texttt{prepare\_submit\_sync}}

\texttt{prepare}，\texttt{submit}，\texttt{sync}を順に行う．\format は
\texttt{prepare}に準ずる．

\section{\texttt{prepare\_submit}}

\texttt{prepare}，\texttt{submit}を順に行う．\format は
\texttt{prepare}に準ずる．

\section{\texttt{submit\_sync}}

\texttt{submit}，\texttt{sync}を順に行う．\format は\texttt{submit}に準
ずる．

\end{document}
