\documentclass[a4paper,10pt]{report}

%\addtolength{\topmargin}{-50pt}
%\addtolength{\textheight}{80pt}
\addtolength{\oddsidemargin}{-35pt}
\addtolength{\textwidth}{70pt}

\usepackage{tascmac}
\usepackage{alltt}
\usepackage[all]{xy}

%
\def\|{\verb|} %|
%

\title{Xcrypt Manual}
\author{E-Science Group, Nakashima Laboratory, Kyoto University}

\begin{document}
\maketitle
\tableofcontents

\part{General}
\chapter{Introduction}

\section{Overview}

In using a high-performance computer, we usually commit job processing
to a job scheduler.  At this time, we often go through the following
procedures:
\begin{itemize}
\item to create a script in its writing style depending on the
      job scheduler,
\item to pass the script to the job scheduler, and
\item to extract data from its result, create another script from
      the data, and pass it to the job scheduler.
\end{itemize}

However, such procedures require manual intervention cost.  It
therefore seems better to remove manual intervention in mid-processing
by using an appropriate script language.  Xcrypt is a script language
for job parallelization.  We can deal with jobs as objects (called
\textit{job objects}) in Xcrypt and manipulate the jobs as well as
objects in an object-oriented language.  Xcrypt provides some
functions and modules for facilitating job generation, submission,
synchronization, etc.  Xcrypt makes it easy to write scripts to process
job, and supports users to process jobs easily.

\section{Environment}

Xcrypt requires a superset of Bourne shell, Perl 5.10.0 or any later
version, and Perl/Tk 8.4 for GUI.

Xcrypt also requires the following outer modules:
\begin{itemize}
\item Marc Lehmann's Coro (where conftest.c is not contained), EV,
\item Joshua Nathaniel Pritikin's Event, and
\item Daniel Muey's Recursive,
\end{itemize}
and wants Marc Lehmann's AnyEvent, common::sense, and Guard (warns if
none).


\chapter{Script}

Xcrypt is a script language, and an extension of Perl.  Xcrypt provides
some functions and modules (not in Perl) which support how to deal
with \textit{jobs}.

An Xcrypt script consists of descriptions of
\begin{enumerate}
 \item module,
 \item template, and
 \item procedure.
\end{enumerate}

\section{Module}

Modules for job objects are used as follows,
\begin{boxnote}
\begin{verbatim}
use base qw(core);
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}

When you use multiple modules, it is enough to write
\begin{boxnote}
\begin{alltt}
use base qw(\textit{mymodule} core);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
Every module should be used in order.
The details of the modules are described in Chapter~\ref{chapmodule}.

Commonly-used modules can be loaded as follows,
\begin{boxnote}
\begin{verbatim}
use builtin;
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}
\noindent
similarly to how to use modules in Perl.

Some modules define variables.
In order to use such variables, it is enough to write e.g.,
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}

\section{Template}

Xcrypt's templates are implemented as Perl's hashes.  For example,
\begin{boxnote}
\begin{alltt}
%myjob = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}',
    'arg0' => '100',
    'arg1' => '\textit{myinput}',
    'linkedfile0' => '\textit{myexe}',
    'copiedfile0' => '\textit{myinput}',
    'stdofile' => '\textit{myout}',
    'stdefile' => '\textit{myerr}',
    'queue' => '\textit{myqueue}',
    'option' => '\textit{myoption}'
);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

Keys in templates are described in Chapter~\ref{chapjobdefhash} in
detail.

\section{Procedure}

Procedures of job processing are described in Xcrypt (and Perl)
instead of manually carried out.
Xcrypt's functions are described in Chapter~\ref{chapfun}.

\section{Example}\label{secscriptexample}

An example script is as follows,
\begin{boxnote}
\begin{alltt}
use base qw(limit core);

&limit::initialize(10);
$separator = '-';

%myjob = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}',
    'arg0' => '100',
    'arg1' => '\textit{myinput}',
    'linkedfile0' => '\textit{myexe}',
    'copiedfile0' => '\textit{myinput}',
    'stdofile' => '\textit{myout}',
    'stdefile' => '\textit{myerr}',
    'queue' => '\textit{myqueue}',
    'option' => '\textit{myoption}'
);
&prepare_submit_sync(%myjob, 'arg0@' => [2,4]);

\end{alltt}
\end{boxnote}


\chapter{Flow}

In this chapter, we introduce how jobs are processed.

\section{Model}\label{sec:states}

Any job transits to \textit{states} as follows,
\[
\entrymodifiers={+[F-:<10pt>]}
\xymatrix@=100pt{
  *{} \ar[r]|(.4){\txt{\small job object generation}} &
  \txt{initialized} \ar[r]|{\txt{\small pre-processing}} \ar[d]|{\txt{\small \texttt{\$ xcryptdel}}}&
  \txt{prepared} \ar[d]|{\txt{\small \texttt{\$ qsub}}} \ar[ld]|{\txt{\small \texttt{\$ xcryptdel}}}\\
  \txt{finished} &
  \txt{aborted} &
  \txt{submitted} \ar[d]|{\txt{\small \texttt{qsub} ok\\job generated}} \ar[l]|{\txt{\small \texttt{qsub} failed}}\\
  \txt{done} \ar[u]|{\txt{\small post-processing}} &
  \txt{running} \ar[l]|{\txt{\small job script done}} \ar[u]|{\txt{\small job aborted}} &
  \txt{queued} \ar[l]|{\txt{\small job started}} \ar[lu]|{\txt{\small job aborted}}
}
\]

\section{Execution}

Edit \texttt{xcrypt/source-me.sh} in order to set some environment
variables where \texttt{XCRJOBSCHED}\footnote{\texttt{SGE},
\texttt{TSUKUBA}, \texttt{TOKYO}, \texttt{KYOTO}, and \texttt{sh} are
available.  In the case of \texttt{sh}, jobs are dealt with as
processes in OS.  The default is \texttt{sh}} should be set to your
job scheduler, and
\begin{screen}
\texttt{\$ source source-me.sh}
\end{screen}
In addition, continue the following installation procedure:
\begin{screen}
\texttt{\$ cd \$XCRYPT/cpan; ./do-install.sh}
\end{screen}

Next, move to the working directory (e.g., \texttt{\$HOME/wd})
\begin{screen}
\texttt{\$ cd \$HOME/wd}
\end{screen}
and write an Xcrypt script (e.g., \texttt{sample.xcr}).  See
Section~\ref{secscriptexample} in order to know how to write.

Finally, execute Xcrypt with the script:
\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcrypt sample.xcr}
\end{screen}

\section{Interactive Usage}

\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcryptstat}
\end{screen}
\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcryptdel myjob}
\end{screen}



\section{Product}\label{sec:created}

Xcrypt creates the following in the working directory
during and after its execution.

\subsection*{directory}

is created for each job (called a \textit{job working directory}).  It is
named by the value of the job hash's key \texttt{id}.  Job-processing
is done in the job working directory.

\subsection*{\textit{myscript}\texttt{.pl}}

is a Perl script created from the Xcrypt script \textit{myscript}.

\subsection*{file and soft link}

of the names (which are the values of \texttt{copiedfile}\textit{i}
and \texttt{linkedfile}\textit{i}) are copied and created in the job
working directory, respectively.

\subsection*{\texttt{\$XCRJOBSCHED.sh} or \texttt{sh.sh}}

is a job script passed to a job scheduler or a Bourne shell script
executed, regarding OS as a job scheduler, respectively.

\subsection*{\texttt{stdout}}

is a file storing the job's standard output.  When \texttt{stdofile}
is defined, the file is renamed as its value.

\subsection*{\texttt{stderr}}

is a file storing the job's standard error.  When \texttt{stdefile}
is defined, the file is renamed as its value.

\part{Details}

\chapter{Option}\label{chapoption}

\section{\texttt{--port}}
\section{\texttt{--scheduler}}
\section{\texttt{--abort\_check\_interval}}
\section{\texttt{--inventory\_path}}
\section{\texttt{--verbose}}
\section{\texttt{--stack\_size}}
\section{\texttt{--rsh}}
\section{\texttt{--rcp}}
\section{\texttt{--rhost}}
\section{\texttt{--rwd}}

\chapter{Module}\label{chapmodule}

In this chapter, we introduce some modules available in Xcrypt scripts.

\section{\texttt{core}}

This module is the Xcrypt core module, and required to be read in
order to use anything particular to Xcrypt.

It creates a directory of the name
\begin{center}
 \texttt{\$myjob->\{id\}} \texttt{\$separator}
 \texttt{\$myjob->\{arg0\}} \texttt{\$separator} ...
\end{center}
under the job working directory, where \texttt{\%myjob} is a template.
The default of \texttt{\$separator} is \texttt{\_}.  In order to
redefine \texttt{\$separator} to be \texttt{-}, for example, it is
enough to write as follows,
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}

Any word composed of ASCII printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available.

This module also makes the variable $\texttt{\$separator\_nocheck}$,
which becomes available in Xcrypt scripts.  When the value of
$\texttt{\$separator\_nocheck}$ is $1$, Xcrypt skips a check of
whether \texttt{\$separator} consists of only available characters or not.
The default is $0$.

\section{\texttt{limit}}

This module limits the number of jobs submitted simultaneously.
In order to limit the number of jobs to $10$, for example, it is enough to
write as follows,
\begin{boxnote}
\begin{verbatim}
&limit::initialize(10);
\end{verbatim}
\end{boxnote}

\section{\texttt{successor}}

This module indicates job objects which can be defined declaratively.
For example, in order to define job objects of the name \texttt{\%x,
\%y}, write:
\begin{boxnote}
\begin{verbatim}
...
'successors' => ['x', 'y'],
...
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}
\noindent
using the key \texttt{successors} in the template.

\section{\texttt{convergence}}

This module provides a function for a Plan-Do-Check-Action (PDCA)
cycle, to deal with convergence of difference of job's results.  The
keys \texttt{initialvalue}, \texttt{isConvergent}, \texttt{inputfile},
\texttt{sweepname}, \texttt{outputfile}, and \texttt{extractrules} can
be used in templates.

\section{\texttt{n\_section\_method}}

This module provides \textit{n}-section method, a root-finding
algorithm. The only difference from bisection
method\footnote{\texttt{http://en.wikipedia.org/wiki/Bisection\_method/}}
is the number of sections.

The values \texttt{partition} and \texttt{epsilon} denote
    a partition number and an error, respectively.  An interval is
    expressed by \texttt{x\_left} and \texttt{x\_right}.  The values
    \texttt{y\_left} and \texttt{y\_right} are values on \texttt{x\_left}
    and \texttt{x\_right}.  Typically, we can call the function
    \texttt{n\_section\_method} with these keys, e.g.,
\begin{boxnote}
\begin{verbatim}
&n_section_method::n_section_method(%job,
    'partition' => 12, 'epsilon' => 0.01,
    'x_left'  => -1,  'x_right' => 10,
    'y_left'  => 0.5, 'y_right' => -5
);
\end{verbatim}
\end{boxnote}

\section{\texttt{dry}}

This module provides job-processing in dry mode (skipping any command
execution).  Description in a template
\begin{boxnote}
\begin{verbatim}
...
'dry' => 1,
...
\end{verbatim}
\end{boxnote}
\noindent
makes any job (derived from this hash) to be processed in dry mode.

\section{\texttt{minimax}}

This module provides a function of a tree algorithm \textit{minimax}.
This function takes a tree and a static function on nodes.

The following is a sample script:
\begin{boxnote}
\begin{verbatim}
%myjob = (
    'id'          => 'job10',
    'linkedfile0' => 'getchildren',
    'linkedfile1' => 'strategy1',
    'linkedfile2' => 'strategy2',
    'linkedfile3' => 'strategy3',
    'arg0'        => '9',               # depth of lookahead
    'arg1'        => '0',               # position
    'arg2'        => 'getchildren'      # get next positions
);

&prepare_submit_sync(%myjob,
                     'arg3@' => ['strategy1', 'strategy2', 'strategy3']);
\end{verbatim}
\end{boxnote}
\noindent
where \texttt{strategy1}, \texttt{strategy2}, and
\texttt{strategy3} are static functions.

\chapter{Template}\label{chapjobdefhash}

In this chapter, we introduce keys and values available in templates
by default.

\section{\texttt{id}}

Its value is a word.  The value is used for creating job objects and
identifying the job objects as their prefixes.  Any word of ASCII
printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available.

\section{\texttt{exe}}

Its value denotes a command.  The command is executed as follows,
\begin{screen}
\texttt{\$ } \textit{myexe myarg0 myarg1 ... myarg255}
\end{screen}
with \texttt{arg}\textit{i} explained below.

\section{\texttt{arg}\textit{i}}

Its values are arguments of a command.  The command is executed as
follows,
\begin{screen}
\texttt{\$ } \textit{myexe myarg0 myarg1 ... myarg255}
\end{screen}

\section{\texttt{linkedfile}\textit{i}}

A soft link of the file (whose name is its value) is created in the
job working directory.

\section{\texttt{copiedfile}\textit{i}}

The indicated file is copied to the job working directory.

\section{\texttt{copieddir}\textit{i}}

All files in the indicated directory are copied
in the job working directory.

\section{\texttt{stdofile}}

The standard output is stored in the indicated file.
The default is \texttt{stdout}.

\section{\texttt{stdefile}}

The standard error is stored in the indicated file.
The default is \texttt{stderr}.

\section{\texttt{queue}}

Its values is a name of a queue.

\section{\texttt{cpu}}

Its value is the number of cores used exclusively.

\section{\texttt{proc}}

Its value is the number of processes used exclusively.

\section{\texttt{option}}

Its value is an option of a job scheduler.

\section{\texttt{successor}}

Its values' jobs are generated after the job is done.

\chapter{Built-in Function}\label{chapfun}

In this chapter, we introduce built-in functions.

\def\format{Format}
\def\example{Example}
\def\advanced{Advanced}

\section{\texttt{prepare}}\label{sec:prepare}

This function takes a job definition hash and parameters of
references\footnote{In this manual, references do not denote type
globs.}, and returns an array of job objects.  The \texttt{id}s of job
objects are generated by \texttt{RANGE}\textit{i} as described later.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
prepare(\textit{%template}
        [,'RANGE0' => \verb+\+@\textit{myparam0s}]...[,'RANGE255' => \verb+\+@\textit{myparam255s}]
        [,'\textit{key}@' => \verb+\+@\textit{myparams}]...);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
where \textit{key}\texttt{@} denotes the one whose postfix is the
character \texttt{@} (e.g., \texttt{arg0@}).

Any word of ASCII printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available for \texttt{RANGE}\textit{i}'s values.

\subsubsection{\example}

\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}', 'arg0@' => [10,20]);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

This is almost the same as
\begin{boxnote}
\begin{alltt}
@jobs = ();
push(@jobs, \{'id' => '\textit{myjob_0}', 'exe' => '\textit{./myexe}', 'arg0' => '10'\});
push(@jobs, \{'id' => '\textit{myjob_1}', 'exe' => '\textit{./myexe}', 'arg0' => '20'\});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

Declarative description is also available as follows,
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}', 'arg0@' => [10,20]);
prepare(%template);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

Description of a template can be separated from parameters:
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
prepare(%template, 'arg0@' => [10,20]);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

Multiple job objects with various parameter values can be generated by using
\texttt{RANGE}\textit{i}s.  For example,
\begin{boxnote}
\begin{verbatim}
@jobs = prepare(%template, 'RANGE0' => [0..99], 'arg0@' => '2 * $R0');
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}
\noindent
is the same as a sequence of \texttt{prepare(\%template, 'arg0' => 0),
prepare(\%template, 'arg0' => 2),..., prepare(\%template, 'arg0' => 198)}.

\subsubsection{\advanced}

It is possible to generate job objects by using multiple parameters.
For example,
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
@jobs = prepare(%template, 'arg0@' => [0,1], 'arg1@' => [2,3]);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
is almost the same as
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
@jobs = ();
@job0 = prepare(%template, 'arg0' => '0', 'arg1' => '2');
push(@jobs, $job0[0]);
@job1 = prepare(%template, 'arg0' => '1', 'arg1' => '3');
push(@jobs, $job1[0]);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

To use \texttt{RANGE}\textit{i}s makes it to generate job products by
multiple parameters, e.g.,
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
@jobs = prepare(%template, 'RANGE0' => [0,1], 'RANGE1' => [2,4],
                           'arg0@' => '$R0 + $R1');
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
is almost the same as
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
@jobs = ();
@job0 = prepare(%template, 'arg0' => '0', 'arg1' => '2');
push(@jobs, $job0[0]);
@job1 = prepare(%template, 'arg0' => '0', 'arg1' => '4');
push(@jobs, $job1[0]);
@job2 = prepare(%template, 'arg0' => '1', 'arg1' => '2');
push(@jobs, $job2[0]);
@job3 = prepare(%template, 'arg0' => '1', 'arg1' => '4');
push(@jobs, $job3[0]);
\end{alltt}
\end{boxnote}

\section{\texttt{submit}}\label{sec:submit}

This function takes an array of job objects and passes the jobs
(corresponding to the job objects) to a job scheduler.  Its return
value is also the array of job objects.

\subsubsection{\format}
\begin{boxnote}
\begin{alltt}
submit(@\textit{myjobs});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\subsubsection{\example}
Typically, this function takes a return value of \texttt{prepare}.
\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}', 'arg0@' => [10,20]);
submit(@jobs);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
It is possible to define job references without using
\texttt{prepare} (although not recommended).
\begin{boxnote}
\begin{alltt}
submit({'id' => '\textit{myjob_0}', 'exe' => '\textit{./myexe}', 'arg0' => '10'},
       {'id' => '\textit{myjob_1}', 'exe' => '\textit{./myexe}', 'arg0' => '20'});
\end{alltt}
\end{boxnote}

\section{\texttt{sync}}

This function takes an array of job objects and synchronizes the job objects.
Its return value is also the array of job objects.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
sync(\textit{@myjobs});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\subsubsection{\example}

Typically, this function takes a return value of \texttt{prepare}
(same as \texttt{submit}).
\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}', 'arg0@' => [10,20]);
submit(@jobs);
sync(@jobs);
\end{alltt}
\end{boxnote}

\section{\texttt{add\_key}}

This function takes an array of words and makes it available as keys in job
definition hashes.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
add_key(@\textit{words});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{repeat}}

This function takes an Xcrypt's script code (denoted as
\textit{mystring}) and an integer $i$, and evaluates it each $i$ seconds.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
repeat(\textit{mystring}, \textit{i});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{prepare\_submit}}

This function is an abbreviation of \texttt{prepare} and
\texttt{submit}.  Its format follows \texttt{prepare}.

\section{\texttt{submit\_sync}}

This function is an abbreviation of \texttt{submit} and
\texttt{sync}.  Its format follows \texttt{submit}.

\section{\texttt{prepare\_submit\_sync}}

This function is an abbreviation of \texttt{prepare\_submit} and
\texttt{sync}.  Its format follows \texttt{prepare}.

\appendix
\chapter{How to Implement Job Class Extension Modules}

Any job object generated by the Xcrypt's function \|prepare| belongs
to the class \|core|, defined by \|$XCRYPT/lib/core.pm|.
Xcrypt users and developers can extend the class \|core| by defining
modules and consequently expand the function of Xcrypt.
In this chapter, we introduce how to implement such extension modules.

\section{How to Define and Use Extension Modules}

In order to define an extension module of the name \textit{mymodule},
it is enough for Xcrypt developers to put it into any directory
designated by \|$XCRYPT/lib/| (or \|$PERL5LIB|).

Then Xcrypt users can use the extension module by simply indicating
their name on the header of his/her script as follows:
\begin{screen}
\begin{alltt}
use base (\ldots {\it mymodule} \ldots core);
\end{alltt}
\end{screen}


\section{Scripts of Extension Modules}

A definition script for an extension module is typically described as follows,
\begin{boxnote}
  \begin{alltt}
package {\it mymodule};
  \end{alltt}
\begin{verbatim}
use strict;
use ...;

&add_key('my_instance_member', ...);

my $my_class_member;

# special methods
sub new {
  my $class = shift;
  my $self = $class->NEXT::new(@_);
  ... 
  return bless $self, $class;
}

sub before { ... }

sub start
{
  my $self = shift;
  ...
  $self->NEXT::start();
  ...
}

sub after { ... }

# general methods
sub another_method
{
  ...
}
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}

In the following, we make an explanation for each component of the script.
\begin{enumerate}
  \item Definition of the module name: is designated by \|package|.
	The module name must coincide with the file name
        without its extension (\|.pm|).
  \item Use of Perl modules: is declared by using \|use|
        as in typical Perl programs.
  \item Addition of instance variables: is performed by the function
	\|add_key|.  The added instance variables are accessible as
	attributes of the job objects by writing, e.g.,
	\begin{center}
	 \|$job->{my_instance_member}|
	\end{center}
	in Xcrypt scripts and modules.  Also, by writing, e.g.,
	\begin{center}
	 \|  |\|%template = {| \ldots \|, my_instance_menber=>|{\it value}\|,| \ldots \|}|
	\end{center}
	users can set values to them.
 \item Definition of class variables: is done in the usual way in
       object-oriented programming, i.e., class variables are defined
       as global variables in packages.  The variables can be
       accessed, e.g.,
	 \begin{center}
	  \|$|{\it mymodule}\|::my_class_member|
	 \end{center}
  \item Definition of methods: is defined in the usual way, i.e.,
	methods added and extended in modules are defined as top-level
	functions in packages.  Note that some methods with
	particular names have special meanings as explained in the next
	section.
\end{enumerate}

\section{Special Methods}

Xcrypt gives special meanings to the following class methods.

\subsection{\texttt{new}}

The method \texttt{new} is a class method, the so-called
\textit{constructor}.  The method \|new| in the most specialized class
(the left-most module declared on the script header) is called.

The method \|new| takes the following arguments:
\begin{enumerate}
\item the package name ($=$ \|user|) to which an Xcrypt script belongs,
\item a reference to a job object\footnote{The object members has
      values in the template passed to the function \texttt{prepare}.}.
\end{enumerate}
Note that \|new| is applied to each of multiple objects
generated by \|prepare|.

In the body of a method, the method \|new| in the parent class is
called as
\begin{center}
 \|$class->NEXT::new($self,$obj)|
\end{center}
where \|$class| and \|$obj| are the class name and reference to the
object, the arguments of \|new|, respectively.

Typically, each \|new| calls \|new| in his parent class with the same
two arguments, processes its return value (an object), and returns
\|bless| \textit{reference to the object},
\textit{the class name} as return values.

In the module \|core|, \|new| is defined.  The \|new| creates a job
directory, soft links, and copies of files (explained in
Section~\ref{sec:created}).  Note that this required procedure is
skipped unless \|new|s in children classes call the \|new| in the
\|core|.

\if0
\subsection{\texttt{before\_isready}}

In Xcrypt, application of the function \|submit| (cf.\
Section~\ref{sec:submit}) makes a job object's state \|prepared|.  The
methods \texttt{before\_isready}s are applied to a job object of the
state \|prepared| (cf.\ Section~\ref{sec:states}).  Its argument is a
reference to the job object.  The order of calling
\texttt{before\_isready}s is in such a way from children to parents
classes.  Each method returns a boolean value.  When some
\texttt{before\_isready}s called in the object return false,
\texttt{before\_isready}s are called after a little interval time.

\subsection{\texttt{before}}

The methods \texttt{before}s are applied to a job object when all of
the methods \texttt{before\_isready}s applied to the job object return
true.  Its argument is a reference to the job object.  The order of calling
\texttt{before}s is in such a way from children to parents
classes.  Return values of the methods are abandoned.
\fi

\subsection{\texttt{before}}

In Xcrypt, application of the function \|submit| (cf.\
Section~\ref{sec:submit}) makes a job object's state \|prepared|.  The
methods \texttt{before}s are applied to a job object of the state
\|prepared| (cf.\ Section~\ref{sec:states}).  Its argument is a
reference to the job object.  The order of calling \texttt{before}s is
in such a way from children to parents classes.  Return values of the
methods are abandoned.

\subsection{\texttt{start}}

The methods \texttt{start}s are applied to a job object after
\texttt{before}s to the job objects are applied.  Its argument is a
reference of the job object.  The method \|start| in the most
specialized class (the left-most module declared on the script header)
is called.

In the body of a method, the method \|new| in the parent class is
called as
\begin{center}
 \|$obj->NEXT::start()|
\end{center}
where \|$obj| is the reference to the object.

In the module \|core|, \|start| is defined.  The \|start| creates a
job script and submits the job to a job scheduler.  Note that this
required procedure is skipped unless \|start|s in children classes call
the \|start| in the \|core|.

\if0
\subsection{\texttt{after\_isready}}

In Xcrypt, a completion notice of a job submitted by the method
 \|core::start| makes the job object's state \|done|.  The methods
 \texttt{after\_isready}s are applied to a job object with the state
 \|done| (cf.\ Section~\ref{sec:states}).  Its argument is a reference
 to the job object.  The order of calling \texttt{after\_isready}s is
 in such a way from parents to children classes.  Each method
 returns a boolean value.  When some \texttt{after\_isready}s called
 in the object return false, \texttt{after\_isready}s are called
 after a little interval time.

\subsection{\texttt{after}}

The methods \texttt{before}s are applied to a job object when all of
the methods \texttt{after\_isready}s applied to the job object return
true.  Its argument is a reference to the job object.  The order of
calling \texttt{after}s is in such a way from parents to children classes.
Return values of the methods are abandoned.
\fi

\subsection{\texttt{after}}

In Xcrypt, a completion notice of a job submitted by the method
 \|core::start| makes the job object's state \|done|.  The methods
 \texttt{after}s are applied to a job object with the state \|done|
 (cf.\ Section~\ref{sec:states}).  Its argument is a reference to the
 job object.  The order of calling \texttt{after}s is in such a way
 from parents to children classes.  Return values of the methods are
 abandoned.

\if0
\paragraph{Remark on Concurrency of \texttt{before\_isready}, \texttt{before}, \texttt{start}, \texttt{after\_isready}, and \texttt{after}.}
Each method is called in concurrently with Xcrypt main thread.
However, it is not necessary that each method is concurrently called
at each job object.  Xcrypt guarantees the following concurrency:
\begin{itemize}
  \item each of
	\texttt{before\_isready}s, \texttt{before}s, \texttt{start}s,
	\texttt{after\_isready}s, and \texttt{after}s
       method is called in concurrent with Xcrypt main thread,
  \item
    at most one method is simultaneously called in
	\texttt{before\_isready}s, \texttt{before}s, and
	\texttt{start}s,
  \item
    at most one method is simultaneously called in
	\texttt{after\_isready}s and \texttt{after}s,
  \item
       just after any \texttt{before\_isready} of a job object returns
	true, the \texttt{before}s of the job object are applied,
	i.e., no method is applied to the *other* job objects,
  \item
       just after \texttt{before}s are applied to a job object,
	\texttt{start}s are applied to the job object, i.e., no method
	is applied to the other job objects,
  \item
       just after any \texttt{after\_isready} of a job object returns
	true, the \texttt{after}s of the job object are applied ,
	i.e., no method is applied to the *other* job objects,
\end{itemize}
\fi

\end{document}
