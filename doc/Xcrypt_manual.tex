\documentclass[a4paper,10pt]{report}

%\addtolength{\topmargin}{-50pt}
%\addtolength{\textheight}{80pt}
\addtolength{\oddsidemargin}{-35pt}
\addtolength{\textwidth}{70pt}

\usepackage{tascmac}
\usepackage{alltt}
\usepackage[all]{xy}

% 
\def\|{\verb|} %|
%

\title{Xcrypt Manual}
\author{E-Science Group, Nakashima Laboratory, Kyoto University}

\begin{document}
\maketitle
\tableofcontents

\paragraph{Memo}

Xcrypt requires
\begin{itemize}
\item Marc Lehmann's AnyEvent, common::sense, Coro, EV, and Guard,
\item Joshua Nathaniel Pritikin's Event,
\item Daniel Muey's Recursive.
\end{itemize}


\part{General}
\chapter{Introduction}

\section{Overview}

通常，ある一つの大きな処理を行うには，その処理を小分け（ジョブと呼ぶ）
にし，それらの処理をジョブスケジューラに依頼する．具体的には，
\begin{enumerate}
\item ジョブスケジューラが理解できるスクリプトを作成し，
\item そのスクリプトをジョブスケジューラに渡し，
\item ジョブスケジューラが返す結果からまた別のスクリプトを作成し，それ
      をジョブスケジューラに渡す，
\end{enumerate}
という一連の操作を繰り返すというものである．

しかし，この方法は処理の繰り返しごとに人手による介入を要し，作業効率が
悪い．そこで，人手で行うところを適当なスクリプト言語により記述すること
で自動実行を実現することが考えられる．Xcrypt はそのスクリプト言語とし
て Perl を採用し，パラメタ指定によるジョブの生成や投入を Perl の関数と
して提供することで，ユーザがジョブ処理を容易に行うことを補助する．

TODO: サーチアルゴリズム等のアルゴリズムモジュールの提供についても記述
する．

\section{Environment}

Xcrypt requires a superset of Bourne or C shell, Perl 5.10.0 or any
later version, and Perl/Tk 8.4 for GUI.

\chapter{Description}

Xcrypt は Perl の拡張である．よって，全ての Perl スクリプトは Xcryptス
クリプトである．しかし，Xcrypt はジョブに関する操作の補助を行うものと考
えられ，Xcrypt スクリプトは典型的には以下の順に記述される．

\def\usemodule{Module}
\def\defjobdefhash{Job Definition Hash}
\def\operation{Job Processing}

\begin{enumerate}
 \item \usemodule
 \item \defjobdefhash
 \item \operation
\end{enumerate}

\section{\usemodule}

モジュールは
\begin{boxnote}
\begin{verbatim}
use base qw(core);
\end{verbatim}
\end{boxnote}
\noindent
と記述して読み込む．複数読み込む場合は読み込みたい順に
\begin{boxnote}
\begin{alltt}
use base qw(\textit{mymodule} core);
\end{alltt}
\end{boxnote}
\noindent
と記述して読み込む．利用可能なモジュールに関しては\ref{chapmodule}章で
述べる．

モジュールを読み込むことにより，利用可能になる変数（例えば
\texttt{\$separator}）は
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}
\noindent
と記述してセットする．

\section{\defjobdefhash}

Xcrypt ではジョブはハッシュ（ジョブハッシュと呼ぶ）で実現されている．ジョ
ブを定義するにあたり，ハッシュ自身を記述してもよいが，ジョブ定義ハッシュ
と呼ばれるハッシュを記述すれば，ジョブを生成する際，さらにパラメタを与
えることで多数のジョブを一度に生成できる．例えば，
\begin{boxnote}
\begin{alltt}
%myjob = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}',
    'arg0' => '100',
    'arg1' => '\textit{myinput}',
    'linkedfile0' => '\textit{myexe}',
    'copiedfile0' => '\textit{myinput}',
    'stdofile' => '\textit{myout}',
    'stdefile' => '\textit{myerr}',
    'queue' => '\textit{myqueue}',
    'option' => '\textit{myoption}'
);
\end{alltt}
\end{boxnote}
\noindent
と記述する．デフォルトで定義可能なジョブ定義ハッシュのキーに関
しては\ref{chapjobdefhash}章で述べる．

\if0
ジョブ定義ハッシュキー（例えば
\texttt{userdefinedkey0}と\texttt{userdefinedkey1}）をユーザ定義するに
はあらかじめ
\begin{boxnote}
\begin{verbatim}
addkeys('userdefinedkey0', 'userdefinedkey1');
\end{verbatim}
\end{boxnote}
と書いておく（\ref{chapfun}章を参照のこと）か，または，ジョブ定義ハッ
シュのキーを与える際，
\begin{boxnote}
\begin{verbatim}
':userdefinedkey0' => 0
\end{verbatim}
\end{boxnote}
とキー名を\texttt{:}で始める．
\fi

\section{\operation}

通常，人手で行う処理で，今回，Xcrypt に行わせたい処理について記述す
る．Xcrypt で利用可能な関数については\ref{chapfun}章で述べる．

\section{Example}\label{secscriptexample}

本章で前節までの説明を踏まえたスクリプト記述例を以下に示す．

\begin{boxnote}
\begin{alltt}
use base qw(limit core);

&limit::initialize(10);
$separator = '-';

%myjob = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}',
    'arg0' => '100',
    'arg1' => '\textit{myinput}',
    'linkedfile0' => '\textit{myexe}',
    'copiedfile0' => '\textit{myinput}',
    'stdofile' => '\textit{myout}',
    'stdefile' => '\textit{myerr}',
    'queue' => '\textit{myqueue}',
    'option' => '\textit{myoption}'
);
&prepare_submit_sync(%myjob, 'arg1@' => [2,4]);

\end{alltt}
\end{boxnote}


\chapter{Flow}

実際のジョブ処理の流れについて概観する．

\section{Model}\label{sec:states}

\[
\entrymodifiers={+[F-:<10pt>]}
\xymatrix@=100pt{
  *{} \ar[r]|(.4){\txt{\small オブジェクト生成}} &
  \txt{active} \ar[r]|{\txt{\small 前処理実行}} \ar[d]|{\txt{\small \texttt{xcryptdel}入力}}&
  \txt{prepared} \ar[d]|{\txt{\small \texttt{qsub}実行}} \ar[ld]|{\txt{\small \texttt{xcryptdel}入力}}\\
  \txt{finished} &
  \txt{aborted} &
  \txt{submitted} \ar[d]|{\txt{\small \texttt{qsub}成功}} \ar[l]|{\txt{\small \texttt{qsub}失敗}}\\
  \txt{done} \ar[u]|{\txt{\small 後処理}} &
  \txt{running} \ar[l]|{\txt{\small スクリプト終了}} \ar[u]|{\txt{\small 当該ジョブ消滅}} &
  \txt{queued} \ar[l]|{\txt{\small スクリプト開始}} \ar[lu]|{\txt{\small 当該ジョブ消滅}}
}
\]

\section{Execution}

環境変数 \texttt{XCRYPT} を Xcrypt をインストールしたディレクトリで定義
する（ここでは \texttt{/usr/share/xcrypt} と仮定する）．シェルが bash
なら，
\begin{screen}
\texttt{\$ XCRYPT=/usr/share/xcrypt; export XCRYPT}
\end{screen}

環境変数 \texttt{XCRJOBSCHED} をジョブスケジューラの名前
\footnote{\texttt{NQS}と\texttt{SGE}とが利用可能である．また，環境変数
\texttt{XCRJOBSCHED} に \texttt{sh} も利用可能である．この場合，ジョブ
をOSのプロセスとして扱い，ジョブスケジューラが導入されていない環境にお
けるジョブの投入・削除・状態取得を行う．}に設定する．シェルが bash
なら，例えば，
\begin{screen}
\texttt{\$ XCRJOBSCHED=SGE; export XCRJOBSCHED}
\end{screen}
とする．

環境変数 \texttt{PERL5LIB} に\texttt{\$XCRYPT/lib}と\texttt{\$XCRYPT/lib/algo/lib}とを追加する．


作業ディレクトリに移動する（ここでは \texttt{\$HOME/wd} とする）．
\begin{screen}
\texttt{\$ cd \$HOME/wd}
\end{screen}

Xcrypt スクリプト（\ref{secscriptexample}節参照）を作成する（ここでは
\texttt{sample.xcr} とする）．

実行する．
\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcrypt sample.xcr}
\end{screen}

\section{Product}\label{sec:created}

Xcrypt を実行した際，作業ディレクトリ以下に作成される物について説明する．

\subsection*{ディレクトリ}

Xcrypt はジョブごとにディレクトリ（ジョブ作業ディレクトリと呼ぶ）を作成
する．ディレクトリの名前はジョブハッシュの\texttt{id}キーの値である．
ジョブ処理はジョブ作業ディレクトリで行われる．

\subsection*{(Xcrypt スクリプト名)\texttt{.pl}}

Xcrypt が Xcrypt スクリプトから作成する Perl スクリプトである．Xcryptが
行う Xcryptスクリプトの実行は，Perl が行うこの Perl スクリプトの実行を
含む．

\subsection*{ジョブリンク・ジョブファイル}

ジョブ作業ディレクトリからジョブハッシュの
\texttt{linkedfile}\textit{i}キーの値で指定されているファイルへシンボリッ
クリンクを張り，\texttt{copiedfile}\textit{i}キーの値で指定されている作
業ディレクトリ中のファイルのコピーをジョブ作業ディレクトリに作成する．

\subsection*{\texttt{NQS.sh}}

ジョブスケジューラが NQS である際，NQS に渡されるスクリプトである．

\subsection*{\texttt{SGE.sh}}

ジョブスケジューラが Sun Grid Engine である際，Sun Grid Engine に渡され
るスクリプトである．

\subsection*{\texttt{sh.sh}}

シェルをジョブスケジューラとして仮想的に利用す際，シェルに渡されるスク
リプトである．

\subsection*{\texttt{request\_id}}

Xcrypt によるジョブの投入に対し，ジョブスケジューラが返すジョブのリクエ
ストIDを格納する．

\subsection*{\texttt{stdout}}

ジョブの実行コマンドの標準出力が格納される．ジョブハッシュの
\texttt{stdofile}キーの値が指定されている場合，その値のファイル名で作成
される．

\subsection*{\texttt{stderr}}

ジョブの実行コマンドの標準エラー出力が格納される．ジョブハッシュの
\texttt{stdefile}キーの値が指定されている場合，その値のファイル名で作成
される．

\part{Details}
\chapter{Module}\label{chapmodule}

In this chapter, we introduce some modules available in Xcrypt scripts.

\section{\texttt{core}}

This module is the Xcrypt core module, and required to be read in
order to use anything paricular to Xcrypt (e.g., a job definiton
hash).

It creates a directory of the name
\begin{center}
 \texttt{\$myjob->\{'id'\}} \texttt{\$separator}
 \texttt{\$myjob->\{'arg0'\}} \texttt{\$separator} ...
\end{center}
under the job working directory, where \texttt{\%myjob} is a job
definition hash.  The default of \texttt{\$separator} is \texttt{\_}.
In order to redefine \texttt{\$separator} to be \texttt{-}, for
example, it is enough to describe as follows,
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}

Any word of ASCII printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available.

This module also makes the variable $\texttt{\$separator\_nocheck}$ to
be available in Xcrypt scripts.  When the value of
$\texttt{\$separator\_nocheck}$ is $1$, Xcrypt skips to check
\texttt{\$separator} for availability.  The default is $0$.

\section{\texttt{limit}}

This module limits the number of jobs to be submitted.  In order to
limit the number of jobs to $10$, for example, it is enough to
describe as follows,
\begin{boxnote}
\begin{verbatim}
&limit::initialize(10);
\end{verbatim}
\end{boxnote}

\section{\texttt{successor}}

This module provides how to describe dependency of jobs declaratively.
For example, in order to define jobs of the name \texttt{\%x, \%y},
describe:
\begin{boxnote}
\begin{verbatim}
...
'successors' => ['x', 'y'],
...
\end{verbatim}
\end{boxnote}
\noindent
using the key \texttt{successors} in the job definition hash.

\if0
\section{\texttt{simple\_convergence}}

投入したジョブの今回値と前回値の差が一定値以下になるまで繰り返す
Plan-Do-Check-Action (PDCA) サイクルを容易に実現する関数を提供する．ジョ
ブ定義ハッシュに \texttt{initialvalue}（初期
値），\texttt{initialvalue}（初期値），\texttt{isConvergent}（収束条
件），\texttt{inputfile}（namelist形式の入力ファイル
名），\texttt{sweepname}（入力ファイルから取得する値の名
前），\texttt{outputfile}（出力ファイル名），\texttt{extractrules}（出
力ファイルから値を取得するためのData\_Extractionにおける規則群）という
キーが使えるようになる．
\fi

\section{\texttt{n\_section\_method}}

This module provides \textit{n}-section method, a root-finding
algorithm of the only difference from bisection
method\footnote{\texttt{http://en.wikipedia.org/wiki/Bisection\_method/}}
is the number of sections.

The values \texttt{partition} and \texttt{epsilon}, denote
    a partition number and an error, respectively.  An interval is
    expressed by \texttt{x\_left} and \texttt{x\_right}.  The values
    \texttt{y\_left} and \texttt{y\_right} are values on \texttt{x\_left}
    and \texttt{x\_right}.  Typically, we can call the function
    \texttt{n\_section\_method} with these keys, e.g.,
\begin{boxnote}
\begin{verbatim}
&n_section_method::n_section_method(%job,
    'partition' => 12, 'epsilon' => 0.01,
    'x_left'  => -1,  'x_right' => 10,
    'y_left'  => 0.5, 'y_right' => -5
);
\end{verbatim}
\end{boxnote}

\section{\texttt{dry}}

This module provides job processing in dry mode (skipping any command
exectution).  Description in a job definition hash
\begin{boxnote}
\begin{verbatim}
...
'dry' => 1,
...
\end{verbatim}
\end{boxnote}
\noindent
makes any job (derived from this hash) to process in dry mode.

\if0
また，
\begin{screen}
\texttt{\$ xcrypt -d sample.xcr}
\end{screen}
\noindent
とオプションつきで実行することでドライモードで動作させることもできる．
\fi

\if0
\section{\texttt{minimax}}

あるノードからその子ノードを与えるプログラムと，ノードに対する評価関数
であるプログラムとを与えることで，木アルゴリズムであるミニマックス法を
行う．

例えば，前者のプログラムを \texttt{getchildren}，後者のプログラムを
\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari} とする
時，

\begin{boxnote}
\begin{verbatim}
%myjob = (
    'id'          => 'job10',
    'linkedfile0' => 'getchildren',
    'linkedfile1' => 'komadoku',
    'linkedfile2' => 'kuraidori',
    'linkedfile3' => 'ikiataribattari',
    'arg0'        => '9',               # depth of lookahead
    'arg1'        => '0',               # position
    'arg2'        => 'getchildren'      # get next positions
);

@results = &prepare_submit_sync(%myjob, 'arg3@' => ['komadoku',
				                  'kuraidori',
				                  'ikiataribattari']);
\end{verbatim}
\end{boxnote}

\noindent
と記述すること
で，\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari}，の
三つの評価関数下における \texttt{0} の位置のノードから \texttt{9} の深
さで先読みした際の値をそれぞれ返す．
\fi

\chapter{Job Definition Hash}\label{chapjobdefhash}

In this chapter, we introduce keys and values available in job
definition hashes by default.

\section{\texttt{id}}

Its value is a word for identifying a job.  Any word of ASCII
printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available.

\section{\texttt{exe}}

Its value is a command for a job.  The command is executed as follows,
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}
with \texttt{arg}\textit{i} as explained below.

\section{\texttt{arg}\textit{i}}

Its values are arguments of a command.  The command is executed as
follows,
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}

\section{\texttt{linkedfile}\textit{i}}

A soft link of the file of the name its value is created in the job
working directory.

\section{\texttt{copiedfile}\textit{i}}

A file of the name its value is copied in the job working directory.

\section{\texttt{copieddir}\textit{i}}

All files in the directory of the name its value are copied in the job
working directory.

\section{\texttt{stdofile}}

The standard output is stored in a file of the name its value.  The
default is \texttt{stdout}.

\section{\texttt{stdefile}}

The standard error is stored in a file of the name its value.  The
default is \texttt{stderr}.

\section{\texttt{queue}}

Its values is a name of a queue.

\section{\texttt{cpu}}

Its value is the number of cores used exclusively.

\section{\texttt{proc}}

Its value is the number of processes used exclusively.

\section{\texttt{option}}

Its value is an option of a job scheduler.

\if0
\section{\texttt{predecessor}}

ジョブを，値であるところのジョブたちの処理が終わるまで投入しないものと
する．

\section{\texttt{successor}}

ジョブ処理後，値であるところのジョブたちを生成する．
\fi

\chapter{Built-in Function}\label{chapfun}

In this chapter, we introduce built-in functions.

\def\format{Format}
\def\example{Example}
\def\advanced{Advanced}

\section{\texttt{prepare}}\label{sec:prepare}

This function takes a job definition hash and parameters of references\footnote{In this manual, references do not denote type globs.}, and returns an array of job references.  The \texttt{id}s of
job objects are generated by \texttt{RANGE}\textit{i} as described
later.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
prepare(\textit{%myjob}
 [,'RANGE0' => \verb+\+@myparam0s]...[,'RANGE255' => \verb+\+@myparam255s]
 [,'\textit{key}@' => \verb+\+@myparams]...);
\end{alltt}
\end{boxnote}
\noindent
where \textit{key}\texttt{@} denotes the one whose postfix is the
character \texttt{@} (e.g., \texttt{arg0@}).

Any word of ASCII printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available for \texttt{RANGE}\textit{i}'s values.

\subsubsection{\example}

\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}',
                'arg0@' => [10,20]);
\end{alltt}
\end{boxnote}
This is almost the same as
\begin{boxnote}
\begin{alltt}
@jobs = ();
push(@jobs, {'id' => '\textit{myjob_0}', 'exe' => '\textit{./myexe}', 'arg0' => '10'});
push(@jobs, {'id' => '\textit{myjob_1}', 'exe' => '\textit{./myexe}', 'arg0' => '20'});
\end{alltt}
\end{boxnote}
Declarative description is as follows,
\begin{boxnote}
\begin{alltt}
%template = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}',
    'arg0@' => [10,20]
);
prepare(%template);
\end{alltt}
\end{boxnote}
Description fo a job definition hash can be separated
from parameters:
\begin{boxnote}
\begin{alltt}
%template = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}'
);
prepare(%template, 'arg0@' => [10,20]);
\end{alltt}
\end{boxnote}

Various job objects can be generated by using \texttt{RANGE0}.  For example,
\begin{boxnote}
\begin{verbatim}
@jobs = prepare(%template, 'RANGE0' => [0..99], 'arg0@' => '2 * $R0');
\end{verbatim}
\end{boxnote}
\noindent
is the same as a sequence of \texttt{prepare(\%template, 'arg0' => 0),
prepare(\%template, 'arg0' => 2),..., prepare(\%template, 'arg0' => 198)}.


\subsubsection{\advanced}

Multiple parameters can be available.  For example,

\begin{boxnote}
\begin{verbatim}
%template = (
    'id' => 'myjob',
    'exe' => './myexe'
);
@jobs = prepare(%template, 'arg0@' => [0,1], 'arg1@' => [2,3]);
\end{verbatim}
\end{boxnote}
\noindent
is almost the same as
\begin{boxnote}
\begin{verbatim}
%template = (
    'id' => 'myjob',
    'exe' => './myexe'
);
@jobs = ();
@job0 = prepare(%template, 'arg0' => '0', 'arg1' => '2');
push(@jobs, $job0[0]);
@job1 = prepare(%template, 'arg0' => '1', 'arg1' => '3');
push(@jobs, $job1[0]);
\end{verbatim}
\end{boxnote}
To use \texttt{RANGE}\textit{i}s makes it to generate job products by
multiple parameters, e.g.,
\begin{boxnote}
\begin{verbatim}
%template = (
    'id' => 'myjob',
    'exe' => './myexe'
);
@jobs = prepare(%template, 'RANGE0' => [0,1], 'RANGE1' => [2,4],
                           'arg0@' => '$R0 + $R1');
\end{verbatim}
\end{boxnote}
\noindent
is almost the same as
\begin{boxnote}
\begin{verbatim}
%template = (
    'id' => 'myjob',
    'exe' => './myexe'
);
@jobs = ();
@job0 = prepare(%template, 'arg0' => '0', 'arg1' => '2');
push(@jobs, $job0[0]);
@job1 = prepare(%template, 'arg0' => '0', 'arg1' => '4');
push(@jobs, $job1[0]);
@job2 = prepare(%template, 'arg0' => '1', 'arg1' => '2');
push(@jobs, $job2[0]);
@job3 = prepare(%template, 'arg0' => '1', 'arg1' => '4');
push(@jobs, $job3[0]);
\end{verbatim}
\end{boxnote}

\section{\texttt{submit}}\label{sec:submit}

This function takes an array of job references, passes jobs to a job
scheduler, and returns the array of job references.

\subsubsection{\format}
\begin{boxnote}
\begin{alltt}
submit(\textit{@myjobs});
\end{alltt}
\end{boxnote}

\subsubsection{\example}
Typically, this function takes a return value of \texttt{prepare}.
\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}',
                'arg0@' => [10,20]);
submit(@jobs);
\end{alltt}
\end{boxnote}
It is possible to describe job references without using
\texttt{prepare} (though not to be recommended).
\begin{boxnote}
\begin{alltt}
submit({'id' => '\textit{myjob_0}', 'exe' => '\textit{./myexe}', 'arg0' => '10'},
       {'id' => '\textit{myjob_1}', 'exe' => '\textit{./myexe}', 'arg0' => '20'});
\end{alltt}
\end{boxnote}

\section{\texttt{sync}}

This function takes an array of job references, syncs the jobs, and
returns the array of job references.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
sync(\textit{@myjobs});
\end{alltt}
\end{boxnote}

\subsubsection{\example}

Typically, this function takes \texttt{prepare} (the same as
\texttt{submit}).
\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}', 'arg0@' => [10,20]);
submit(@jobs);
sync(@jobs);
\end{alltt}
\end{boxnote}

\section{\texttt{addkeys}}

This function takes an array of words and makes it available as keys in job
definition hashes.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
addkeys(\textit{@words});
\end{alltt}
\end{boxnote}

\section{\texttt{addperiodic}}

This function takes a Xcrypt's code and an integer $i$, and evaluates
it each the $i$ seconds.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
addperiodic(\textit{string}, \textit{i});
\end{alltt}
\end{boxnote}

\section{\texttt{prepare\_submit}}

This function is an abbreviation of \texttt{prepare} and
\texttt{submit}.  Its format follows \texttt{prepare}.

\section{\texttt{submit\_sync}}

This function is an abbreviation of \texttt{submit} and
\texttt{sync}.  Its format follows \texttt{submit}.

\section{\texttt{prepare\_submit\_sync}}

This function is an abbreviation of \texttt{prepare\_submit} and
\texttt{sync}.  Its format follows \texttt{prepare}.

\appendix
\chapter{ジョブクラス拡張モジュール実装の手引}

\section{はじめに}
Xcryptの\|prepare|関数によって生成された全てのジョブオブジェクトは
\|$XCRYPT/lib/core.pm| %$
で定義された\|core|クラスに属する．
Xcryptのユーザや開発者は，拡張モジュールを定義して\|core|クラスを拡張
することでXcryptの機能を拡張することが可能である．
本章では，この拡張モジュールを開発するために必要な情報を示す．

\section{拡張モジュールの定義と利用}
\textit{mymodule}という名前の拡張モジュールを定義するためには，
\textit{mymodule}\|.pm| という名前の
ファイルを\|$XCRYPT/lib/|（または\|$PERL5LIB|で指定されている
  どこかのディレクトリ）に置く．
Xcryptユーザは，スクリプトの先頭で，
\begin{screen}
\begin{alltt}
use base (\ldots {\it mymodule} \ldots core);
\end{alltt}
\end{screen}
のようにモジュール名を指定することで，当該モジュールの機能を使用できる．


\section{拡張モジュールスクリプトの構成}

典型的な拡張モジュールの定義スクリプトは以下のように記述される．

\begin{boxnote}
  \begin{alltt}
package {\it mymodule};
  \end{alltt}
\begin{verbatim}
use strict;
use ...;

&addkeys('my_instance_member', ...);

my $my_class_member;

# special methods
sub new {
  my $class = shift;
  my $self = $class->NEXT::new(@_);
  ... 
  return bless $self, $class;
}

sub before_isready { ... }
sub before { ... }

sub start
{
  my $self = shift;
  ...
  $self->NEXT::start();
  ...
}

sub after { ... }
sub after_isready { ... }

# general methods
sub another_method
{
  ...
}
\end{verbatim}
\end{boxnote}

以下，スクリプトの各構成要素について説明する．

\begin{enumerate}
  \item モジュール名の定義：\|package|で指定する．ここで指定する名前は，
    モジュールファイル名の拡張子（\|.pm|）を除いた部分と同一でなければ
    ならない．
  \item Perlモジュールの取り込み：通常のPerlプログラムと同様に，必要なPerlモジュールを\|use|で取り込む．
  \item 追加するインスタンス変数の定義：ジョブクラスに新たに追加したい
    インスタンス変数の名前を\|addkeys|関数により定義する．ここで定義し
    たインスタンス変数は，ジョブオブジェクトの属性として，Xcryptスクリプトや
    モジュール内のメソッドから\|$job->{my_instance_menber}| %$
    などとしてアクセスできる．また，Xcryptユーザがジョブ定義ハッシュの記述時に，\\
    \|  |\|%template = {| \ldots \|, my_instance_menber=>|{\it value}\|,| \ldots \|}|\\
    のようにして値を設定することもできる．
  \item クラス変数の定義：通常のPerlのオブジェクト指向プログラミングと同様，
    クラス変数はパッケージ内のグローバル変数として定義する．ここで定義した変数は，
    \|$|{\it mymodule}\|::my_class_member|としてアクセスできる %$
  \item メソッドの定義：このモジュールにおいて追加，拡張するメソッドをパッケージ内の
    トップレベル関数として定義する．通常のPerlオブジェクト指向プログラミングと同様であるが，
    特定の名前を持つメソッドは特別な意味を持つので注意する．（次節で説明）
\end{enumerate}

\section{特別な意味を持つメソッド}
\subsection{\texttt{new}メソッド}
コンストラクタに相当するクラスメソッドであり，
Xcryptの\|prepare|関数（\ref{sec:prepare}節）の処理中に，
最もspecializedなクラス（Xcryptスクリプトのヘッダで宣言されているモジュール列
のうち最も左に書かれているもの）の\|new|メソッドが呼び出される．

このnewメソッドに渡される引数は以下の通りである．
\begin{enumerate}
\item Xcryptスクリプトが属するパッケージ名（＝\|user|）
\item ジョブオブジェクトへの参照．オブジェクトのメンバには，\|prepare|関数に渡されたジョブ定義ハッシュに対応する値がセットされている．
\end{enumerate}
ジョブ定義ハッシュの\|RANGE|等の指定により\|prepare|関数が複数のジョブオブジェクト
を生成した場合は，その各オブジェクトに対して\|new|が適用される．

メソッドの本体では，\|$class->NEXT::new($self,$obj)| %$
（\|$class|，\|$obj|はそれぞれ引数として渡されたクラス名およびオブジェクトへの参照）
のようにして親クラスの\|new|メソッドを呼び出すことができる．
典型的には，各\|new|メソッドはまず親クラスの\|new|メソッドを，
与えられた2つの引数をそのまま引き渡して呼び出し，
その返り値のオブジェクトにアクセスしつつ必要な処理を行った後，
\|bless オブジェクトへの参照, 渡されたクラス名|の値を
メソッドの返り値として\|return|すべきである．

\|core|モジュールでも\|new|メソッドが定義されており，ここでは
\ref{sec:created}節で説明したジョブの作業ディレクトリおよび
その中へのファイルのコピー・シンボリックリンクの生成処理を行う．
子クラスの\|new|メソッドにより\|core|モジュールの\|new|メソッド
が呼び出されないと，この処理が行われなくなるので注意すること．

\subsection{\texttt{before\_isready}メソッド}
状態（\ref{sec:states}節）が\|prepared|になったジョブオブジェクトに対して
適用される．一般にはXcryptスクリプト中の\|submit|関数（\ref{sec:submit}節）
の適用により，ジョブの状態が\|prepared|になる．
引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{before\_isready}メソッドが定義されて
いた場合は，{\bf 子クラス→親クラスの順で全ての}\texttt{before\_isready}メソッド
が呼び出される．

各メソッドは，真偽値を返す．
呼び出された\texttt{before\_isready}メソッド列のうち，1つでも偽を返したメソッドが
あれば，しばらくの時間待ち合わせた後，もう一度\texttt{before\_isready}メソッド列
の実行が行われる．

\subsection{\texttt{before}メソッド}
\texttt{before\_isready}メソッド列が適用され，その全てが真を返したジョブオブジェクト
に対して適用される．引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{before}メソッドが定義されて
いた場合は，{\bf 子クラス→親クラスの順で全ての}\texttt{before}メソッド
が呼び出される．

メソッドの返り値は破棄される．

\subsection{\texttt{start}メソッド}
\texttt{before}メソッドの処理が終わったジョブオブジェクトに対して適用される．
引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{start}メソッドが定義されていた場合は，
最もspecializedなクラスの\|start|メソッドが呼び出される．

メソッドの本体では，\|$obj->NEXT::start()| %$
（\|$obj|は引数として渡されたジョブオブジェクトへの参照）%$
のようにして親クラスの\|start|メソッドを呼び出すことができる．

\|core|モジュールでも\|start|メソッドが定義されており，ここでは
ジョブスクリプトの生成およびバッチスケジューラへのジョブ投入処理を行う．
子クラスの\|start|メソッドにより\|core|モジュールの\|start|メソッド
が呼び出されないと，この処理が行われなくなるので注意すること．

\subsection{\texttt{after\_isready}メソッド}
状態（\ref{sec:states}節）が\|done|になったジョブオブジェクトに対して
適用される．一般には，\|core::start|メソッドによってバッチスケジューラに
投入したジョブからのジョブ完了通知により，ジョブの状態が\|done|になる．
引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{after\_isready}メソッドが定義されて
いた場合は，{\bf 親クラス→子クラスの順で全ての}\texttt{after\_isready}メソッド
が呼び出される．

各メソッドは，真偽値を返す．
呼び出された\texttt{after\_isready}メソッド列のうち，1つでも偽を返したメソッドが
あれば，しばらくの時間待ち合わせた後，もう一度\texttt{after\_isready}メソッド列
の実行が行われる．

\subsection{\texttt{after}メソッド}
\texttt{after\_isready}メソッド列が適用され，その全てが真を返したジョブオブジェクト
に対して適用される．引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{after}メソッドが定義されて
いた場合は，{\bf 親クラス→子クラスの順で全ての}\texttt{after}メソッド
が呼び出される．

メソッドの返り値は破棄される．

\subsection{\texttt{before\_isready}，\texttt{before}，\texttt{start}，\texttt{after\_isready}，\texttt{after}の並行性}
\texttt{before}，\texttt{before\_isready}，\texttt{start}，\texttt{after}，\texttt{after\_isready}の各メソッドは
Xcryptのユーザスレッドとは並行に実行される．ただし，各ジョブオブジェクト間についてのこれらのメソッドの実行は
完全に並行に実行されるわけではない．Xcrypt処理系が保証する並行性は以下の通りである．
\begin{itemize}
  \item
    どのジョブオブジェクトの
    \texttt{before\_isready}，\texttt{before}，\texttt{start}，\texttt{after\_isready}，\texttt{after}メソッドも
    Xcryptのユーザスレッドとは並行に実行される．
  \item
    どのジョブオブジェクトの\texttt{before\_isready}，\texttt{before}，\texttt{start}メソッドも2つ以上並行に実行されることはない．
  \item
    どのジョブオブジェクトの\texttt{after\_isready}，\texttt{after}，メソッドも2つ以上並行に実行されることはない．
  \item
    あるオブジェクトに対して\texttt{before\_isready}メソッド列が全て真を返した際，
    それに続くそのオブジェクトへの\texttt{before}メソッド列の実行の前に，
    他のどのオブジェクトへの\texttt{before\_isready}，\texttt{before}，\texttt{start}
    メソッド適用も行われることはない．
  \item
    あるオブジェクトへの\texttt{before}メソッド列の適用と\texttt{start}メソッドの適用の間に，
    他のどのオブジェクトへの\texttt{before\_isready}，\texttt{before}，\texttt{start}
    メソッド適用も行われることはない．
  \item
    あるオブジェクトに対して\texttt{after\_isready}メソッド列が全て真を返した際，
    それに続くそのオブジェクトへの\texttt{after}メソッド列の実行の前に，
    他のどのオブジェクトへの\texttt{after\_isready}，\texttt{after}
    メソッド適用も行われることはない．
\end{itemize}

\end{document}
