\documentclass[report]{jsbook}

\usepackage{tascmac}
\usepackage[all]{xy}

% 

\title{Xcrypt マニュアル}
\author{京大中島研e-scienceグループ}

\begin{document}
\maketitle
\tableofcontents

\paragraph{メモ}

Daniel Muey 氏の Recursive.pm を使用している．ライセンス的には問題ない
はず．

\part{総論}
\chapter{はじめに}

\section{機能}

通常，ある一つの大きな処理を行うには，その処理を小分け（ジョブと呼ぶ）
にし，それらの処理をジョブスケジューラに依頼する．具体的には，
\begin{enumerate}
\item ジョブスケジューラが理解できるスクリプトを作成し，
\item そのスクリプトをジョブスケジューラに渡し，
\item ジョブスケジューラが返す結果からまた別のスクリプトを作成し，それ
      をジョブスケジューラに渡す，
\end{enumerate}
という一連の操作を繰り返すというものである．

しかし，この方法は処理の繰り返しごとに人手による介入を要し，作業効率が
悪い．そこで，人手で行うところを適当なスクリプト言語により記述すること
で自動実行を実現することが考えられる．Xcrypt はそのスクリプト言語とし
て Perl を採用し，パラメタ指定によるジョブの生成や投入を Perl の関数と
して提供することで，ユーザがジョブ処理を容易に行うことを補助する．

TODO: サーチアルゴリズム等のアルゴリズムモジュールの提供についても記述
する．

\section{動作環境}

・sh 系（sh，bash，zsh 等）または csh 系（csh，tcsh 等）シェル

・Perl 5.10.0（GUI 利用時には Perl/Tk 8.4 も要）


\chapter{Xcrypt スクリプトの記述}

Xcrypt は Perl の拡張である．よって，全ての Perl スクリプトは Xcryptス
クリプトである．しかし，Xcrypt はジョブに関する操作の補助を行うものと考
えられ，Xcrypt スクリプトは典型的には以下の順に記述される．

\def\usemodule{モジュールに関する記述}
\def\defjobdefhash{ジョブ定義ハッシュに関する記述}
\def\operation{ジョブ処理に関する記述}

\begin{enumerate}
 \item \usemodule
 \item \defjobdefhash
 \item \operation
\end{enumerate}

\section{\usemodule}

モジュールは
\begin{boxnote}
\begin{verbatim}
use base qw(core);
\end{verbatim}
\end{boxnote}
\noindent
と記述して読み込む．複数読み込む場合は読み込みたい順に
\begin{boxnote}
\begin{verbatim}
use base qw(dry core);
\end{verbatim}
\end{boxnote}
\noindent
と記述して読み込む．利用可能なモジュールに関しては\ref{chapmodule}章で
述べる．

モジュールを読み込むことにより，利用可能になる変数（例えば
\texttt{\$separator} ）は
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}
\noindent
と記述してセットする．

\section{\defjobdefhash}

Xcrypt ではジョブはハッシュ（ジョブハッシュと呼ぶ）で実現されている．ジョ
ブを定義するにあたり，ハッシュ自身を記述してもよいが，ジョブ定義ハッシュ
と呼ばれるハッシュを記述すれば，ジョブを生成する際，さらにパラメタを与
えることで多数のジョブを一度に生成できる．例えば，
\begin{boxnote}
\begin{verbatim}
%xyz = (
    'id' => 'job100',
    'exe' => './kempo',
    'arg0' => '100',
    'arg1' => 'plasma.inp',
    'linkedfile0' => 'kempo',
    'copiedfile0' => 'plasma.inp',
    'stdofile' => 'hogeout',
    'stdefile' => 'hogeerr',
    'queue' => 'gh10034',
    'option' => '# @$-g gh10034'
);
\end{verbatim}
\end{boxnote}
\noindent
と記述する．デフォルトで定義可能なジョブ定義ハッシュのキーに関
しては\ref{chapjobdefhash}章で述べる．

\if0
ジョブ定義ハッシュキー（例えば
\texttt{userdefinedkey0}と\texttt{userdefinedkey1}）をユーザ定義するに
はあらかじめ
\begin{boxnote}
\begin{verbatim}
addkeys('userdefinedkey0', 'userdefinedkey1');
\end{verbatim}
\end{boxnote}
と書いておく（\ref{chapfun}章を参照のこと）か，または，ジョブ定義ハッ
シュのキーを与える際，
\begin{boxnote}
\begin{verbatim}
':userdefinedkey0' => 0
\end{verbatim}
\end{boxnote}
とキー名を\texttt{:}で始める．
\fi

\section{\operation}

通常，人手で行う処理で，今回，Xcrypt に行わせたい処理について記述す
る．Xcrypt で利用可能な関数については\ref{chapfun}章で述べる．

\section{記述例}\label{secscriptexample}

本章で前節までの説明を踏まえたスクリプト記述例を以下に示す．

\begin{boxnote}
\begin{verbatim}
use base qw(core);

$smph=Thread::Semaphore->new(10);
$separator = '-';

%xyz = (
    'id' => 'job100',
    'exe' => './kempo',
    'arg0' => 'plasma.inp',
    'arg1' => '100',
    'copieddir0' => 'forcopieddir',
    'linkedfile0' => 'kempo',
    'copiedfile0' => 'plasma.inp',
    'stdofile' => 'hogeout',
    'stdefile' => 'hogeerr',
    'queue' => 'gh10034',
    'option' => '# @$-g gh10034'
);

&prepare_submit_sync(%xyz, 'arg1@' => [2,4]);
\end{verbatim}
\end{boxnote}

\chapter{ジョブ処理の流れ}

実際のジョブ処理の流れについて概観する．

\section{概念図}

\[
\entrymodifiers={+[F-:<10pt>]}
\xymatrix@=100pt{
  *{}
  \ar[r]|(.4){\txt{\small オブジェクト生成}} &
  \txt{active} \ar[rrd]|!{[rr];[dl]}\hole|(.6){\txt{\small \texttt{xcryptdel}入力}}
  \ar[r]|{\txt{\small \texttt{前処理・qsub}実行}} &
  \txt{submitted} \ar[rd]|!{[r];[dll]}\hole|(.6){\txt{\small \texttt{qsub}失敗}} \ar[r]|{\txt{\small \texttt{qsub}成功}} &
  \txt{queued} \ar[llld]|(.6){\txt{\small スクリプト開始}} \ar[d]|{\txt{\small 当該ジョブ消滅}}\\
  \txt{running} \ar[r]|{\txt{\small スクリプト終了}}
  \ar@/_5pc/[rrr]|{\txt{\small 当該ジョブ消滅}} & \txt{done}
  \ar[r]|{\txt{\small 後処理}} & \txt{finished} &
  \txt{aborted}
}
\]

\section{実行方法}

環境変数 \texttt{XCRYPT} を Xcrypt をインストールしたディレクトリで定義
する（ここでは \texttt{/usr/share/xcrypt} と仮定する）．シェルが bash
なら，
\begin{screen}
\texttt{\$ XCRYPT=/usr/share/xcrypt; export XCRYPT}
\end{screen}

環境変数 \texttt{XCRJOBSCHED} をジョブスケジューラの名前
\footnote{\texttt{NQS}と\texttt{SGE}とが利用可能である．また，環境変数
\texttt{XCRJOBSCHED} に \texttt{sh} も利用可能である．この場合，ジョブ
をOSのプロセスとして扱い，ジョブスケジューラが導入されていない環境にお
けるジョブの投入・削除・状態取得を行う．}に設定する．シェルが bash
なら，例えば，
\begin{screen}
\texttt{\$ XCRJOBSCHED=SGE; export XCRJOBSCHED}
\end{screen}
とする．

環境変数 \texttt{PERL5LIB} に\texttt{\$XCRYPT/lib}と\texttt{\$XCRYPT/lib/algo/lib}とを追加する．


作業ディレクトリに移動する（ここでは \texttt{\$HOME/wd} とする）．
\begin{screen}
\texttt{\$ cd \$HOME/wd}
\end{screen}

Xcrypt スクリプト（\ref{secscriptexample}節参照）を作成する（ここでは
\texttt{sample.xcr} とする）．

実行する．
\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcrypt sample.xcr}
\end{screen}

\section{作成物}

Xcrypt を実行した際，作業ディレクトリ以下に作成される物について説明する．

\subsection*{ディレクトリ}

Xcrypt はジョブごとにディレクトリ（ジョブ作業ディレクトリと呼ぶ）を作成
する．ディレクトリの名前はジョブハッシュの\texttt{id}キーの値である．
ジョブ処理はジョブ作業ディレクトリで行われる．

\subsection*{(Xcrypt スクリプト名)\texttt{.pl}}

Xcrypt が Xcrypt スクリプトから作成する Perl スクリプトである．Xcryptが
行う Xcryptスクリプトの実行は，Perl が行うこの Perl スクリプトの実行を
含む．

\subsection*{ジョブリンク・ジョブファイル}

ジョブ作業ディレクトリからジョブハッシュの
\texttt{linkedfile0,...,linkedfile255}キーの値で指定されているファイル
へシンボリックリンクを張り，\texttt{copiedfile0,...,copiedfile255}キー
の値で指定されている作業ディレクトリ中のファイルのコピーをジョブ作業ディ
レクトリに作成する．

\subsection*{\texttt{NQS.sh}}

ジョブスケジューラが NQS である際，NQS に渡されるスクリプトである．

\subsection*{\texttt{SGE.sh}}

ジョブスケジューラが Sun Grid Engine である際，Sun Grid Engine に渡され
るスクリプトである．

\subsection*{\texttt{sh.sh}}

シェルをジョブスケジューラとして仮想的に利用す際，シェルに渡されるスク
リプトである．

\subsection*{\texttt{request\_id}}

Xcrypt によるジョブの投入に対し，ジョブスケジューラが返すジョブのリクエ
ストIDを格納する．

\subsection*{\texttt{stdout}}

ジョブの実行コマンドの標準出力が格納される．ジョブハッシュの
\texttt{stdofile}キーの値が指定されている場合，その値のファイル名で作成
される．

\subsection*{\texttt{stderr}}

ジョブの実行コマンドの標準エラー出力が格納される．ジョブハッシュの
\texttt{stdefile}キーの値が指定されている場合，その値のファイル名で作成
される．

\part{各論}
\chapter{モジュール}\label{chapmodule}

Xcrypt スクリプトで利用可能なモジュールについて紹介する．

\section{\texttt{core}}

Xcrypt コアを読み込む．Xcrypt 特有のもの（ジョブ定義ハッシュ等）を使用
する場合には必ず読み込まないといけない．

Xcrypt スクリプトで $\texttt{\$separator}$という変数が使えるようになる．

ジョブ作業ディレクトリ以下にジョブ定義ハッシュにおける
\texttt{id,arg0,\ldots,arg255}を\texttt{\$separator}で区切った
名前のディレクトリを作成する．\texttt{\$separator}のデフォルト
値は「\texttt{\_}」である．「\texttt{-}」に変えたい場合は，
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}
とする．

使用できるシンボルは \verb*+@ "$%&'/:;<=>?[\]`{|}+ を除く ASCII 印字可
能文字とする．

また，Xcrypt スクリプトで$\texttt{\$separator\_nocheck}$という変数が使
えるようになる．


この値を $1$ にすると \texttt{\$separator} が使用できるシンボルである
かのチェックを飛ばす．デフォルト値は $0$ である．

\section{\texttt{limit}}

投入するジョブの数を制限する．Xcrypt スクリプトで $\texttt{\$initialize}$ と
いう関数が使えるようになるので，例えば，ジョブ数を$10$に制限したければ，
\begin{boxnote}
\begin{verbatim}
&limit::initialize(10);
\end{verbatim}
\end{boxnote}
\noindent
と記述して使う．

\section{\texttt{dry}}

Xcrypt をドライモード（コマンドの実行のみ行わないモード）で動作させるこ
とができる．

ジョブ定義ハッシュに
\begin{boxnote}
\begin{verbatim}
...
':dry' => 1,
...
\end{verbatim}
\end{boxnote}
\noindent
と記述することでジョブがドライモードで動作する．

\if0
また，
\begin{screen}
\texttt{\$ xcrypt -d sample.xcr}
\end{screen}
\noindent
とオプションつきで実行することでドライモードで動作させることもできる．
\fi

\if0
\section{\texttt{minimax}}

あるノードからその子ノードを与えるプログラムと，ノードに対する評価関数
であるプログラムとを与えることで，木アルゴリズムであるミニマックス法を
行う．

例えば，前者のプログラムを \texttt{getchildren}，後者のプログラムを
\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari} とする
時，

\begin{boxnote}
\begin{verbatim}
%xyz = (
    'id'          => 'job10',
    'linkedfile0' => 'getchildren',
    'linkedfile1' => 'komadoku',
    'linkedfile2' => 'kuraidori',
    'linkedfile3' => 'ikiataribattari',
    'arg0'        => '9',               # depth of lookahead
    'arg1'        => '0',               # position
    'arg2'        => 'getchildren'      # get next positions
);

@results = &prepare_submit_sync(%xyz, 'arg3@' => ['komadoku',
				                  'kuraidori',
				                  'ikiataribattari']);
\end{verbatim}
\end{boxnote}

\noindent
と記述すること
で，\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari}，の
三つの評価関数下における \texttt{0} の位置のノードから \texttt{9} の深
さで先読みした際の値をそれぞれ返す．
\fi

\chapter{ジョブ定義ハッシュ}\label{chapjobdefhash}

ジョブ定義ハッシュにおいてデフォルトで利用可能なキーについて紹介する．

\section{\texttt{id}}

実行されるジョブを識別する語を記述する．

使用できるシンボルは \verb*+@ "$%&'/:;<=>?[\]`{|}+ を除く ASCII 印字可
能文字とする．

\section{\texttt{exe}}

実行されるジョブの実行コマンドを記述する．後述の\texttt{arg0,...,arg255}とともに
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}
といった形で実行される．

\section{\texttt{arg0,...,arg255}}

実行されるジョブの実行コマンドの引数を記述する．前述の\texttt{exe}とと
もに
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}
といった形で実行される．

\section{\texttt{linkedfile0,...,linkedfile255}}

この値のリンク名でジョブ作業ディレクトリから作業ディレクトリのファイル
へシンボリックリンクを張る．

\section{\texttt{copiedfile0,...,copiedfile255}}

この値のファイル名でジョブ作業ディレクトリから作業ディレクトリにコピー
をつくる．

\section{\texttt{copieddir0,...,copieddir255}}

この値の名前であるディレクトリ中のファイルから作業ディレクトリにコピー
をつくる．

\section{\texttt{stdofile}}

この値のファイル名で実行プログラムとジョブスケジューラの標準出力を格納
する．空の場合は「stdout」というファイル名になる．

\section{\texttt{stdefile}}

この値のファイル名で実行プログラムとジョブスケジューラの標準エラー出力
を格納する．空の場合は「stderr」というファイル名になる．

\section{\texttt{queue}}

実行するジョブを投入するキューの名前を記述する．

\section{\texttt{cpu}}

使用するコア数を指定する．

\section{\texttt{proc}}

使用するプロセス数を指定する．

\section{\texttt{option}}

ジョブスケジューラのオプションを記述する．

\if0
\section{\texttt{predecessor}}

ジョブを，値であるところのジョブたちの処理が終わるまで投入しないものと
する．

\section{\texttt{successor}}

ジョブ処理後，値であるところのジョブたちを生成する．
\fi

\chapter{組込み関数}\label{chapfun}

Xcrypt で利用可能な組込み関数のうち，Perl の組込み関数でないものについ
て紹介する．

\def\format{書式}
\def\example{記述例}
\def\advanced{発展}


\section{\texttt{prepare}}

ジョブ定義ハッシュと（リファレンス\footnote{本稿ではリファレンスは型グ
ロブを含まないものとする．}またはスカラで与えられる）パラメタを受け取
り，適当なジョブリファレンスの配列を返す．特に，ジョブの\texttt{id}は後
述の\texttt{RANGE0,...,RANGE255}により生成される．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
prepare(ジョブ定義ハッシュ[,'RANGE0' => (配列リファレンス)]
                      ...[,'RANGE255' => (配列リファレンス)]
                         [,'ジョブ定義ハッシュキー@' => (リファレンス||スカラ)]
                      ...[,'ジョブ定義ハッシュキー@' => (リファレンス||スカラ)]);
\end{verbatim}
\end{boxnote}

ただし，「ジョブ定義ハッシュキー\texttt{@}」はジョブ定義ハッシュキー
（\texttt{arg0}等）の語尾に\texttt{@}をつけ加えたもの
（\texttt{arg0@}等）を意味するものとする．

\texttt{RANGE0,...,RANGE255}の値であるところの配列リファレンスにおける配列に使用できるシンボルは \verb*+@ "$%&'/:;<=>?[\]`{|}+ を除く ASCII 印字可能文字とする．

\subsection{\example}

\begin{boxnote}
\begin{verbatim}
@jobs = prepare('id' => 'xyz', 'exe' => './kempo', 'arg0@' => [10,20]);
\end{verbatim}
\end{boxnote}

これは以下と同義である．

\begin{boxnote}
\begin{verbatim}
@jobs = ();
push(@jobs, {'id' => 'xyz_0', 'exe' => './kempo', 'arg0' => '10'});
push(@jobs, {'id' => 'xyz_1', 'exe' => './kempo', 'arg0' => '20'});
\end{verbatim}
\end{boxnote}

宣言的に書くこともできる．

\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo',
    'arg0@' => [10,20]
);
prepare(%abc);
\end{verbatim}
\end{boxnote}

ジョブ定義ハッシュとパラメタを分けて書くこともできる．

\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
prepare(%abc, 'arg0@' => [10,20]);
\end{verbatim}
\end{boxnote}

\texttt{RANGE0}と関数リファレンスを使うことでさまざまなパラメタでジョブ
を生成することができる．例えば，
\begin{boxnote}
\begin{verbatim}
@jobs = prepare(%abc, 'RANGE0' => [0..99], 'arg0@' => sub { 2 * $_[0] });
\end{verbatim}
\end{boxnote}
は\texttt{prepare(\%abc, 0), prepare(\%abc, 2),..., prepare(\%abc,
198)}を順番に行ったものと同義である．


\subsection{\advanced}

パラメタは複数書くことができる．複数パラメタの配列の頭からジョブは生成
される．例えば，

\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
@jobs = prepare(%abc, 'arg0@' => [0,1], 'arg1@' => [2,3]);
\end{verbatim}
\end{boxnote}
は以下と同義である．
\begin{boxnote}
\begin{verbatim}
@jobs = ();
push(@jobs, {'id' => 'xyz_0', 'exe' => './kempo', 'arg0' => '0', 'arg1' => '2'});
push(@jobs, {'id' => 'xyz_1', 'exe' => './kempo', 'arg0' => '1', 'arg1' => '3'});
\end{verbatim}
\end{boxnote}

\texttt{RANGE0}等と関数リファレンスを使うことでパラメタをかけ合わせてジョ
ブを生成することができる．例えば，
\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
@jobs = prepare(%abc, 'RANGE0' => [0,1], 'RANGE1' => [2,4],
                'arg0@' => sub { $_[0] + $_[1] });
\end{verbatim}
\end{boxnote}
は以下と同義である．
\begin{boxnote}
\begin{verbatim}
@jobs = ();
push(@jobs, {'id' => 'xyz_2', 'exe' => './kempo', 'arg0' => '2'});
push(@jobs, {'id' => 'xyz_4', 'exe' => './kempo', 'arg0' => '4'});
push(@jobs, {'id' => 'xyz_3', 'exe' => './kempo', 'arg0' => '3'});
push(@jobs, {'id' => 'xyz_5', 'exe' => './kempo', 'arg0' => '5'});
\end{verbatim}
\end{boxnote}

引数がリファレンスでなくスカラである時，引数は \texttt{eval} される．ゆ
えに，上記は，
\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'xyz',
    'exe' => './kempo'
);
@jobs = prepare(%abc, 'RANGE0' => [0,1], 'RANGE1' => [2,4],
                'arg0@' => '$_[0] + $_[1]');
\end{verbatim}
\end{boxnote}
とも書くこともできる．

\section{\texttt{submit}}

\if0
ジョブリファレンスの配列を受け取り，各ジョブをジョブスケジューラに渡
し，ジョブスケジューラからジョブスレッドを受け取り，それらの配列を返す．
\fi

ジョブリファレンスの配列を受け取り，各ジョブをジョブスケジューラに渡
し，ジョブリファレンスの配列を返す．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
submit(ジョブリファレンスの配列);
\end{verbatim}
\end{boxnote}

\subsection{\example}

典型的には\texttt{prepare}の返り値を引数にとる．

\begin{boxnote}
\begin{verbatim}
@jobs = prepare('id' => 'xyz', 'exe' => './kempo', 'arg0@' => [10,20]);
submit(@jobs);
\end{verbatim}
\end{boxnote}

自力でジョブリファレンスの配列を書いてもよい．

\begin{boxnote}
\begin{verbatim}
submit({'id' => 'xyz_0', 'exe' => './kempo', 'arg0' => '10'},
       {'id' => 'xyz_1', 'exe' => './kempo', 'arg0' => '20'});
\end{verbatim}
\end{boxnote}

\section{\texttt{sync}}

\if0
ジョブスレッドの配列を受け取り，ジョブ処理後のジョブリファレンスの配列
を返す．
\fi

ジョブリファレンスの配列を受け取り，それらの同期をとり，ジョブリファレ
ンスの配列を返す．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
sync(ジョブリファレンスの配列);
\end{verbatim}
\end{boxnote}

\subsection{\example}

典型的には\texttt{submit}の返り値を引数にとる．

\begin{boxnote}
\begin{verbatim}
@jobs = prepare('id' => 'xyz', 'exe' => './kempo', 'arg0@' => [10,20]);
@objs = submit(@jobs);
sync(@objs);
\end{verbatim}
\end{boxnote}

\section{\texttt{addkeys}}

文字列の配列を受け取り，それらを\texttt{prepare}で展開されるジョブ定義ハッ
シュキーとして利用可能にする．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
addkeys(文字列の配列);
\end{verbatim}
\end{boxnote}

\section{\texttt{prepare\_submit}}

\texttt{prepare}，\texttt{submit}を順に行う．ただし，\texttt{prepare}で
生成したジョブリファレンスを即座に\texttt{submit}する（全てのジョブリファ
レンスが生成されるのを待たない）．\format は\texttt{prepare}に準ずる．

\section{\texttt{submit\_sync}}

\texttt{submit}，\texttt{sync}を順に行う．\format は\texttt{submit}に準
ずる．

\section{\texttt{prepare\_submit\_sync}}

\texttt{prepare\_submit}，\texttt{sync}を順に行う．\format は
\texttt{prepare}に準ずる．

\end{document}
