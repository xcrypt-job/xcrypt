\documentclass[a4paper,10pt]{report}

%\addtolength{\topmargin}{-50pt}
%\addtolength{\textheight}{80pt}
\addtolength{\oddsidemargin}{-35pt}
\addtolength{\textwidth}{70pt}

\usepackage{tascmac}
\usepackage{alltt}
\usepackage[all]{xy}

%
\def\|{\verb|} %|
%

\title{Xcrypt Manual}
\author{E-Science Group, Nakashima Laboratory, Kyoto University}

\begin{document}
\maketitle
\tableofcontents

\paragraph{Memo}

Xcrypt requires
\begin{itemize}
\item Marc Lehmann's EV,
\item Joshua Nathaniel Pritikin's Event, and
\item Daniel Muey's Recursive,
\end{itemize}
and wants Marc Lehmann's AnyEvent, common::sense, and Guard (warns if
none).

\part{General}
\chapter{Introduction}

\section{Overview}

In using a high-performance computer, we usually commit job processing
to a job scheduler.  At this time, we often go through the following
procedures:
\begin{itemize}
\item to create a script in its writing style depending on the
      job scheduler,
\item to pass the script to the job scheduler, and
\item to extract data from its result, create another script from
      the data, and pass it to the job scheduler.
\end{itemize}

However, such procedures require manual intervention cost.  It
therefore seems better to remove manual intervention in mid-processing
by using an appropriate script language.  Xcrypt is a script language
for job parallelization.  We can deal with jobs as objects (called
\textit{job objects}) in Xcrypt and manipulate the jobs as well as
objects in an object-oriented language.  Xcrypt provides some
functions and modules for facilitating job generation, submission,
syncronization, etc.  Xcrypt makes it easy to write scripts to process
job, and supports users to process jobs easily.

\section{Environment}

Xcrypt requires a superset of Bourne or C shell, Perl 5.10.0 or any
later version, and Perl/Tk 8.4 for GUI.

\chapter{Script}

\def\usemodule{Module}
\def\defjobdefhash{Template}
\def\operation{Procedure}

Xcrypt is a script language, and an extension of Perl.  Xcrypt provides
some functions and modules (not in Perl) which support how to deal
with \textit{jobs}.

An Xcrypt script consists of descriptions of
\begin{enumerate}
 \item \usemodule,
 \item \defjobdefhash, and
 \item \operation.
\end{enumerate}

\section{\usemodule}

Modules for job objects are used as follows,
\begin{boxnote}
\begin{verbatim}
use base qw(core);
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}

When you use multiple modules, it is enough to write
\begin{boxnote}
\begin{alltt}
use base qw(\textit{mymodule} core);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
Every module should be used in order.
The details of the modules are described in Chapter~\ref{chapmodule}.

Commonly-used modules can be loaded as follows,
\begin{boxnote}
\begin{verbatim}
use builtin;
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}
\noindent
similarly to how to use modules in Perl.

Some modules define variables.
In order to use such variables, it is enough to write e.g.,
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}

\section{\defjobdefhash}

Xcrypt's templates are implemented as Perl's hashes.  For example,
\begin{boxnote}
\begin{alltt}
%myjob = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}',
    'arg0' => '100',
    'arg1' => '\textit{myinput}',
    'linkedfile0' => '\textit{myexe}',
    'copiedfile0' => '\textit{myinput}',
    'stdofile' => '\textit{myout}',
    'stdefile' => '\textit{myerr}',
    'queue' => '\textit{myqueue}',
    'option' => '\textit{myoption}'
);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

Keys in templates are described in Chapter~\ref{chapjobdefhash} in
detail.

\section{\operation}

Procedures of job processing are described in Xcrypt (and Perl)
instead of manually carried out.
Xcrypt's functions are decribed in Chapter~\ref{chapfun}.

\section{Example}\label{secscriptexample}

An example script is as follows,
\begin{boxnote}
\begin{alltt}
use base qw(limit core);

&limit::initialize(10);
$separator = '-';

%myjob = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}',
    'arg0' => '100',
    'arg1' => '\textit{myinput}',
    'linkedfile0' => '\textit{myexe}',
    'copiedfile0' => '\textit{myinput}',
    'stdofile' => '\textit{myout}',
    'stdefile' => '\textit{myerr}',
    'queue' => '\textit{myqueue}',
    'option' => '\textit{myoption}'
);
&prepare_submit_sync(%myjob, 'arg0@' => [2,4]);

\end{alltt}
\end{boxnote}


\chapter{Flow}

In this chapter, we introduce how jobs are processed.

\section{Model}\label{sec:states}

Any job transits to \textit{states} as follows,
\[
\entrymodifiers={+[F-:<10pt>]}
\xymatrix@=100pt{
  *{} \ar[r]|(.4){\txt{\small job object generation}} &
  \txt{active} \ar[r]|{\txt{\small pre-processing}} \ar[d]|{\txt{\small \texttt{\$ xcryptdel}}}&
  \txt{prepared} \ar[d]|{\txt{\small \texttt{\$ qsub}}} \ar[ld]|{\txt{\small \texttt{\$ xcryptdel}}}\\
  \txt{finished} &
  \txt{aborted} &
  \txt{submitted} \ar[d]|{\txt{\small \texttt{qsub} ok\\job generated}} \ar[l]|{\txt{\small \texttt{qsub} failed}}\\
  \txt{done} \ar[u]|{\txt{\small post-processing}} &
  \txt{running} \ar[l]|{\txt{\small job script done}} \ar[u]|{\txt{\small job aborted}} &
  \txt{queued} \ar[l]|{\txt{\small job started}} \ar[lu]|{\txt{\small job aborted}}
}
\]

\section{Execution}

Set the following environment variables appropriately.
\texttt{XCRYPT} should be set to the installation directory of Xcrypt
(e.g., \texttt{/usr/share/xcrypt}).
For example, it is enough to type
\begin{screen}
\texttt{\$ XCRYPT=/usr/share/xcrypt; export XCRYPT}
\end{screen}
when you use Bourne shell.
\texttt{XCRJOBSCHED}\footnote{\texttt{NQS}, \texttt{hNQS},
\texttt{SGE}, and \texttt{tSGE} are available.  In addition, sh-mode
is supported (by being set to \texttt{sh}) for environments
without any job scheduler.  In that case, jobs are dealt with as
processes in OS.} should be set to a job scheduler.  \texttt{PERL5LIB}
should be set to \texttt{\$XCRYPT/lib} and \texttt{\$XCRYPT/lib/algo/lib}.

Next, move to the working directory (e.g., \texttt{\$HOME/wd})
\begin{screen}
\texttt{\$ cd \$HOME/wd}
\end{screen}
and write an Xcrpyt script (e.g., \texttt{sample.xcr}).  See
Section~\ref{secscriptexample} in order to know how to write.

Finally, execute Xcrypt with the script:
\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcrypt sample.xcr}
\end{screen}

\section{Product}\label{sec:created}

Xcrypt creates the following in the working directory
during and after its execution.

\subsection*{directory}

is created for each job (called a \textit{job working directory}).  It is
named by the value of the job hash's key \texttt{id}.  Job-processing
is done in the job working directory.

\subsection*{\textit{myscript}\texttt{.pl}}

is a Perl script created from the Xcrypt script \textit{myscript}.

\subsection*{file and soft link}

of the names (which are the values of \texttt{copiedfile}\textit{i}
and \texttt{linkedfile}\textit{i}) are copied and created in the job
working directory, respectively.

\subsection*{\texttt{\$XCRJOBSCHED.sh}}

is a job script, which is passed to a job scheduler.

\subsection*{\texttt{sh.sh}}

is a Bourne shell script, which is executed, regarding OS as a job
scheduler.

\subsection*{\texttt{request\_id}}

is a file storing the job's request ID (which the job scheduler
returns).

\subsection*{\texttt{stdout}}

is a file storing the job's standard output.  When \texttt{stdofile}
is defined, the file is renamed as its value.

\subsection*{\texttt{stderr}}

is a file storing the job's standard error.  When \texttt{stdefile}
is defined, the file is renamed as its value.

\part{Details}
\chapter{Module}\label{chapmodule}

In this chapter, we introduce some modules available in Xcrypt scripts.

\section{\texttt{core}}

This module is the Xcrypt core module, and required to be read in
order to use anything paricular to Xcrypt.

It creates a directory of the name
\begin{center}
 \texttt{\$myjob->\{'id'\}} \texttt{\$separator}
 \texttt{\$myjob->\{'arg0'\}} \texttt{\$separator} ...
\end{center}
under the job working directory, where \texttt{\%myjob} is a template.
The default of \texttt{\$separator} is \texttt{\_}.  In order to
redefine \texttt{\$separator} to be \texttt{-}, for example, it is
enough to write as follows,
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}

Any word composed of ASCII printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available.

This module also makes the variable $\texttt{\$separator\_nocheck}$,
which becomes available in Xcrypt scripts.  When the value of
$\texttt{\$separator\_nocheck}$ is $1$, Xcrypt skips a check of
whether \texttt{\$separator} consists of only available characters or not.
The default is $0$.

\section{\texttt{limit}}

This module limits the number of jobs submitted simultaneously.
In order to limit the number of jobs to $10$, for example, it is enough to
write as follows,
\begin{boxnote}
\begin{verbatim}
&limit::initialize(10);
\end{verbatim}
\end{boxnote}

\section{\texttt{successor}}

This module indicates job objects which can be defined declaratively.
For example, in order to define job objects of the name \texttt{\%x,
\%y}, write:
\begin{boxnote}
\begin{verbatim}
...
'successors' => ['x', 'y'],
...
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}
\noindent
using the key \texttt{successors} in the template.

\if0
\section{\texttt{simple\_convergence}}

投入したジョブの今回値と前回値の差が一定値以下になるまで繰り返す
Plan-Do-Check-Action (PDCA) サイクルを容易に実現する関数を提供する．ジョ
ブ定義ハッシュに \texttt{initialvalue}（初期
値），\texttt{initialvalue}（初期値），\texttt{isConvergent}（収束条
件），\texttt{inputfile}（namelist形式の入力ファイル
名），\texttt{sweepname}（入力ファイルから取得する値の名
前），\texttt{outputfile}（出力ファイル名），\texttt{extractrules}（出
力ファイルから値を取得するためのData\_Extractionにおける規則群）という
キーが使えるようになる．
\fi

\section{\texttt{n\_section\_method}}

This module provides \textit{n}-section method, a root-finding
algorithm. The only difference from bisection
method\footnote{\texttt{http://en.wikipedia.org/wiki/Bisection\_method/}}
is the number of sections.

The values \texttt{partition} and \texttt{epsilon} denote
    a partition number and an error, respectively.  An interval is
    expressed by \texttt{x\_left} and \texttt{x\_right}.  The values
    \texttt{y\_left} and \texttt{y\_right} are values on \texttt{x\_left}
    and \texttt{x\_right}.  Typically, we can call the function
    \texttt{n\_section\_method} with these keys, e.g.,
\begin{boxnote}
\begin{verbatim}
&n_section_method::n_section_method(%job,
    'partition' => 12, 'epsilon' => 0.01,
    'x_left'  => -1,  'x_right' => 10,
    'y_left'  => 0.5, 'y_right' => -5
);
\end{verbatim}
\end{boxnote}

\section{\texttt{dry}}

This module provides job-processing in dry mode (skipping any command
exectution).  Description in a template
\begin{boxnote}
\begin{verbatim}
...
'dry' => 1,
...
\end{verbatim}
\end{boxnote}
\noindent
makes any job (derived from this hash) to be processed in dry mode.

\if0
また，
\begin{screen}
\texttt{\$ xcrypt -d sample.xcr}
\end{screen}
\noindent
とオプションつきで実行することでドライモードで動作させることもできる．
\fi

\if0
\section{\texttt{minimax}}

あるノードからその子ノードを与えるプログラムと，ノードに対する評価関数
であるプログラムとを与えることで，木アルゴリズムであるミニマックス法を
行う．

例えば，前者のプログラムを \texttt{getchildren}，後者のプログラムを
\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari} とする
時，

\begin{boxnote}
\begin{verbatim}
%myjob = (
    'id'          => 'job10',
    'linkedfile0' => 'getchildren',
    'linkedfile1' => 'komadoku',
    'linkedfile2' => 'kuraidori',
    'linkedfile3' => 'ikiataribattari',
    'arg0'        => '9',               # depth of lookahead
    'arg1'        => '0',               # position
    'arg2'        => 'getchildren'      # get next positions
);

@results = &prepare_submit_sync(%myjob, 'arg3@' => ['komadoku',
				                  'kuraidori',
				                  'ikiataribattari']);
\end{verbatim}
\end{boxnote}

\noindent
と記述すること
で，\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari}，の
三つの評価関数下における \texttt{0} の位置のノードから \texttt{9} の深
さで先読みした際の値をそれぞれ返す．
\fi

\chapter{Template}\label{chapjobdefhash}

In this chapter, we introduce keys and values available in templates
by default.

\section{\texttt{id}}

Its value is a word.  The value is used for creating job objects and
identifying the job objects as their prefixes.  Any word of ASCII
printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available.

\section{\texttt{exe}}

Its value denotes a command.  The command is executed as follows,
\begin{screen}
\texttt{\$ } \textit{myexe myarg0 myarg1 ... myarg255}
\end{screen}
with \texttt{arg}\textit{i} explained below.

\section{\texttt{arg}\textit{i}}

Its values are arguments of a command.  The command is executed as
follows,
\begin{screen}
\texttt{\$ } \textit{myexe myarg0 myarg1 ... myarg255}
\end{screen}

\section{\texttt{linkedfile}\textit{i}}

A soft link of the file (whose name is its value) is created in the
job working directory.

\section{\texttt{copiedfile}\textit{i}}

The indicated file is copied to the job working directory.

\section{\texttt{copieddir}\textit{i}}

All files in the indicated directory are copied
in the job working directory.

\section{\texttt{stdofile}}

The standard output is stored in the indicated file.
The default is \texttt{stdout}.

\section{\texttt{stdefile}}

The standard error is stored in the indicated file.
The default is \texttt{stderr}.

\section{\texttt{queue}}

Its values is a name of a queue.

\section{\texttt{cpu}}

Its value is the number of cores used exclusively.

\section{\texttt{proc}}

Its value is the number of processes used exclusively.

\section{\texttt{option}}

Its value is an option of a job scheduler.

\if0
\section{\texttt{predecessor}}

ジョブを，値であるところのジョブたちの処理が終わるまで投入しないものと
する．

\section{\texttt{successor}}

ジョブ処理後，値であるところのジョブたちを生成する．
\fi

\chapter{Built-in Function}\label{chapfun}

In this chapter, we introduce built-in functions.

\def\format{Format}
\def\example{Example}
\def\advanced{Advanced}

\section{\texttt{prepare}}\label{sec:prepare}

This function takes a job definition hash and parameters of
references\footnote{In this manual, references do not denote type
globs.}, and returns an array of job objects.  The \texttt{id}s of job
objects are generated by \texttt{RANGE}\textit{i} as described later.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
prepare(\textit{%template}
        [,'RANGE0' => \verb+\+@\textit{myparam0s}]...[,'RANGE255' => \verb+\+@\textit{myparam255s}]
        [,'\textit{key}@' => \verb+\+@\textit{myparams}]...);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
where \textit{key}\texttt{@} denotes the one whose postfix is the
character \texttt{@} (e.g., \texttt{arg0@}).

Any word of ASCII printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available for \texttt{RANGE}\textit{i}'s values.

\subsubsection{\example}

\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}', 'arg0@' => [10,20]);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

This is almost the same as
\begin{boxnote}
\begin{alltt}
@jobs = ();
push(@jobs, \{'id' => '\textit{myjob_0}', 'exe' => '\textit{./myexe}', 'arg0' => '10'\});
push(@jobs, \{'id' => '\textit{myjob_1}', 'exe' => '\textit{./myexe}', 'arg0' => '20'\});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

Declarative description is also available as follows,
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}', 'arg0@' => [10,20]);
prepare(%template);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

Description of a template can be separated from parameters:
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
prepare(%template, 'arg0@' => [10,20]);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

Multiple job objects with various parameter values can be generated by using
\texttt{RANGE}\textit{i}s.  For example,
\begin{boxnote}
\begin{verbatim}
@jobs = prepare(%template, 'RANGE0' => [0..99], 'arg0@' => '2 * $R0');
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}
\noindent
is the same as a sequence of \texttt{prepare(\%template, 'arg0' => 0),
prepare(\%template, 'arg0' => 2),..., prepare(\%template, 'arg0' => 198)}.

\subsubsection{\advanced}

It is possible to generate job objects by using multiple parameters.
For example,
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
@jobs = prepare(%template, 'arg0@' => [0,1], 'arg1@' => [2,3]);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
is almost the same as
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
@jobs = ();
@job0 = prepare(%template, 'arg0' => '0', 'arg1' => '2');
push(@jobs, $job0[0]);
@job1 = prepare(%template, 'arg0' => '1', 'arg1' => '3');
push(@jobs, $job1[0]);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

To use \texttt{RANGE}\textit{i}s makes it to generate job products by
multiple parameters, e.g.,
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
@jobs = prepare(%template, 'RANGE0' => [0,1], 'RANGE1' => [2,4],
                           'arg0@' => '$R0 + $R1');
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
is almost the same as
\begin{boxnote}
\begin{alltt}
%template = ('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}');
@jobs = ();
@job0 = prepare(%template, 'arg0' => '0', 'arg1' => '2');
push(@jobs, $job0[0]);
@job1 = prepare(%template, 'arg0' => '0', 'arg1' => '4');
push(@jobs, $job1[0]);
@job2 = prepare(%template, 'arg0' => '1', 'arg1' => '2');
push(@jobs, $job2[0]);
@job3 = prepare(%template, 'arg0' => '1', 'arg1' => '4');
push(@jobs, $job3[0]);
\end{alltt}
\end{boxnote}

\section{\texttt{submit}}\label{sec:submit}

This function takes an array of job objects and passes the jobs
(corresponding to the job objects) to a job scheduler.  Its return
value is also the array of job objects.

\subsubsection{\format}
\begin{boxnote}
\begin{alltt}
submit(@\textit{myjobs});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\subsubsection{\example}
Typically, this function takes a return value of \texttt{prepare}.
\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}', 'arg0@' => [10,20]);
submit(@jobs);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
It is possible to define job references without using
\texttt{prepare} (although not recommended).
\begin{boxnote}
\begin{alltt}
submit({'id' => '\textit{myjob_0}', 'exe' => '\textit{./myexe}', 'arg0' => '10'},
       {'id' => '\textit{myjob_1}', 'exe' => '\textit{./myexe}', 'arg0' => '20'});
\end{alltt}
\end{boxnote}

\section{\texttt{sync}}

This function takes an array of job objects and synchronizes the job objects.
Its return value is also the array of job objects.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
sync(\textit{@myjobs});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\subsubsection{\example}

Typically, this function takes a return value of \texttt{prepare}
(same as \texttt{submit}).
\begin{boxnote}
\begin{alltt}
@jobs = prepare('id' => '\textit{myjob}', 'exe' => '\textit{./myexe}', 'arg0@' => [10,20]);
submit(@jobs);
sync(@jobs);
\end{alltt}
\end{boxnote}

\section{\texttt{addkeys}}

This function takes an array of words and makes it available as keys in job
definition hashes.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
addkeys(@\textit{words});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{addperiodic}}

This function takes an Xcrypt's script code (denoted as
\textit{mystring}) and an integer $i$, and evaluates it each $i$ seconds.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
addperiodic(\textit{mystring}, \textit{i});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{prepare\_submit}}

This function is an abbreviation of \texttt{prepare} and
\texttt{submit}.  Its format follows \texttt{prepare}.

\section{\texttt{submit\_sync}}

This function is an abbreviation of \texttt{submit} and
\texttt{sync}.  Its format follows \texttt{submit}.

\section{\texttt{prepare\_submit\_sync}}

This function is an abbreviation of \texttt{prepare\_submit} and
\texttt{sync}.  Its format follows \texttt{prepare}.

\appendix
\chapter{ジョブクラス拡張モジュール実装の手引}

\section{はじめに}
Xcryptの\|prepare|関数によって生成された全てのジョブオブジェクトは
\|$XCRYPT/lib/core.pm| %$
で定義された\|core|クラスに属する．
Xcryptのユーザや開発者は，拡張モジュールを定義して\|core|クラスを拡張
することでXcryptの機能を拡張することが可能である．
本章では，この拡張モジュールを開発するために必要な情報を示す．

\section{拡張モジュールの定義と利用}
\textit{mymodule}という名前の拡張モジュールを定義するためには，
\textit{mymodule}\|.pm| という名前の
ファイルを\|$XCRYPT/lib/|（または\|$PERL5LIB|で指定されている
  どこかのディレクトリ）に置く．
Xcryptユーザは，スクリプトの先頭で，
\begin{screen}
\begin{alltt}
use base (\ldots {\it mymodule} \ldots core);
\end{alltt}
\end{screen}
のようにモジュール名を指定することで，当該モジュールの機能を使用できる．


\section{拡張モジュールスクリプトの構成}

典型的な拡張モジュールの定義スクリプトは以下のように記述される．

\begin{boxnote}
  \begin{alltt}
package {\it mymodule};
  \end{alltt}
\begin{verbatim}
use strict;
use ...;

&addkeys('my_instance_member', ...);

my $my_class_member;

# special methods
sub new {
  my $class = shift;
  my $self = $class->NEXT::new(@_);
  ... 
  return bless $self, $class;
}

sub before_isready { ... }
sub before { ... }

sub start
{
  my $self = shift;
  ...
  $self->NEXT::start();
  ...
}

sub after { ... }
sub after_isready { ... }

# general methods
sub another_method
{
  ...
}
\end{verbatim}
\end{boxnote}

以下，スクリプトの各構成要素について説明する．

\begin{enumerate}
  \item モジュール名の定義：\|package|で指定する．ここで指定する名前は，
    モジュールファイル名の拡張子（\|.pm|）を除いた部分と同一でなければ
    ならない．
  \item Perlモジュールの取り込み：通常のPerlプログラムと同様に，必要なPerlモジュールを\|use|で取り込む．
  \item 追加するインスタンス変数の定義：ジョブクラスに新たに追加したい
    インスタンス変数の名前を\|addkeys|関数により定義する．ここで定義し
    たインスタンス変数は，ジョブオブジェクトの属性として，Xcryptスクリプトや
    モジュール内のメソッドから\|$job->{my_instance_menber}| %$
    などとしてアクセスできる．また，Xcryptユーザがジョブ定義ハッシュの記述時に，\\
    \|  |\|%template = {| \ldots \|, my_instance_menber=>|{\it value}\|,| \ldots \|}|\\
    のようにして値を設定することもできる．
  \item クラス変数の定義：通常のPerlのオブジェクト指向プログラミングと同様，
    クラス変数はパッケージ内のグローバル変数として定義する．ここで定義した変数は，
    \|$|{\it mymodule}\|::my_class_member|としてアクセスできる %$
  \item メソッドの定義：このモジュールにおいて追加，拡張するメソッドをパッケージ内の
    トップレベル関数として定義する．通常のPerlオブジェクト指向プログラミングと同様であるが，
    特定の名前を持つメソッドは特別な意味を持つので注意する．（次節で説明）
\end{enumerate}

\section{特別な意味を持つメソッド}
\subsection{\texttt{new}メソッド}
コンストラクタに相当するクラスメソッドであり，
Xcryptの\|prepare|関数（\ref{sec:prepare}節）の処理中に，
最もspecializedなクラス（Xcryptスクリプトのヘッダで宣言されているモジュール列
のうち最も左に書かれているもの）の\|new|メソッドが呼び出される．

このnewメソッドに渡される引数は以下の通りである．
\begin{enumerate}
\item Xcryptスクリプトが属するパッケージ名（＝\|user|）
\item ジョブオブジェクトへの参照．オブジェクトのメンバには，\|prepare|関数に渡されたジョブ定義ハッシュに対応する値がセットされている．
\end{enumerate}
ジョブ定義ハッシュの\|RANGE|等の指定により\|prepare|関数が複数のジョブオブジェクト
を生成した場合は，その各オブジェクトに対して\|new|が適用される．

メソッドの本体では，\|$class->NEXT::new($self,$obj)| %$
（\|$class|，\|$obj|はそれぞれ引数として渡されたクラス名およびオブジェクトへの参照）
のようにして親クラスの\|new|メソッドを呼び出すことができる．
典型的には，各\|new|メソッドはまず親クラスの\|new|メソッドを，
与えられた2つの引数をそのまま引き渡して呼び出し，
その返り値のオブジェクトにアクセスしつつ必要な処理を行った後，
\|bless オブジェクトへの参照, 渡されたクラス名|の値を
メソッドの返り値として\|return|すべきである．

\|core|モジュールでも\|new|メソッドが定義されており，ここでは
\ref{sec:created}節で説明したジョブの作業ディレクトリおよび
その中へのファイルのコピー・シンボリックリンクの生成処理を行う．
子クラスの\|new|メソッドにより\|core|モジュールの\|new|メソッド
が呼び出されないと，この処理が行われなくなるので注意すること．

\subsection{\texttt{before\_isready}メソッド}
状態（\ref{sec:states}節）が\|prepared|になったジョブオブジェクトに対して
適用される．一般にはXcryptスクリプト中の\|submit|関数（\ref{sec:submit}節）
の適用により，ジョブの状態が\|prepared|になる．
引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{before\_isready}メソッドが定義されて
いた場合は，{\bf 子クラス→親クラスの順で全ての}\texttt{before\_isready}メソッド
が呼び出される．

各メソッドは，真偽値を返す．
呼び出された\texttt{before\_isready}メソッド列のうち，1つでも偽を返したメソッドが
あれば，しばらくの時間待ち合わせた後，もう一度\texttt{before\_isready}メソッド列
の実行が行われる．

\subsection{\texttt{before}メソッド}
\texttt{before\_isready}メソッド列が適用され，その全てが真を返したジョブオブジェクト
に対して適用される．引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{before}メソッドが定義されて
いた場合は，{\bf 子クラス→親クラスの順で全ての}\texttt{before}メソッド
が呼び出される．

メソッドの返り値は破棄される．

\subsection{\texttt{start}メソッド}
\texttt{before}メソッドの処理が終わったジョブオブジェクトに対して適用される．
引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{start}メソッドが定義されていた場合は，
最もspecializedなクラスの\|start|メソッドが呼び出される．

メソッドの本体では，\|$obj->NEXT::start()| %$
（\|$obj|は引数として渡されたジョブオブジェクトへの参照）%$
のようにして親クラスの\|start|メソッドを呼び出すことができる．

\|core|モジュールでも\|start|メソッドが定義されており，ここでは
ジョブスクリプトの生成およびバッチスケジューラへのジョブ投入処理を行う．
子クラスの\|start|メソッドにより\|core|モジュールの\|start|メソッド
が呼び出されないと，この処理が行われなくなるので注意すること．

\subsection{\texttt{after\_isready}メソッド}
状態（\ref{sec:states}節）が\|done|になったジョブオブジェクトに対して
適用される．一般には，\|core::start|メソッドによってバッチスケジューラに
投入したジョブからのジョブ完了通知により，ジョブの状態が\|done|になる．
引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{after\_isready}メソッドが定義されて
いた場合は，{\bf 親クラス→子クラスの順で全ての}\texttt{after\_isready}メソッド
が呼び出される．

各メソッドは，真偽値を返す．
呼び出された\texttt{after\_isready}メソッド列のうち，1つでも偽を返したメソッドが
あれば，しばらくの時間待ち合わせた後，もう一度\texttt{after\_isready}メソッド列
の実行が行われる．

\subsection{\texttt{after}メソッド}
\texttt{after\_isready}メソッド列が適用され，その全てが真を返したジョブオブジェクト
に対して適用される．引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{after}メソッドが定義されて
いた場合は，{\bf 親クラス→子クラスの順で全ての}\texttt{after}メソッド
が呼び出される．

メソッドの返り値は破棄される．

\subsection{\texttt{before\_isready}，\texttt{before}，\texttt{start}，\texttt{after\_isready}，\texttt{after}の並行性}
\texttt{before}，\texttt{before\_isready}，\texttt{start}，\texttt{after}，\texttt{after\_isready}の各メソッドは
Xcryptのユーザスレッドとは並行に実行される．ただし，各ジョブオブジェクト間についてのこれらのメソッドの実行は
完全に並行に実行されるわけではない．Xcrypt処理系が保証する並行性は以下の通りである．
\begin{itemize}
  \item
    どのジョブオブジェクトの
    \texttt{before\_isready}，\texttt{before}，\texttt{start}，\texttt{after\_isready}，\texttt{after}メソッドも
    Xcryptのユーザスレッドとは並行に実行される．
  \item
    どのジョブオブジェクトの\texttt{before\_isready}，\texttt{before}，\texttt{start}メソッドも2つ以上並行に実行されることはない．
  \item
    どのジョブオブジェクトの\texttt{after\_isready}，\texttt{after}，メソッドも2つ以上並行に実行されることはない．
  \item
    あるオブジェクトに対して\texttt{before\_isready}メソッド列が全て真を返した際，
    それに続くそのオブジェクトへの\texttt{before}メソッド列の実行の前に，
    他のどのオブジェクトへの\texttt{before\_isready}，\texttt{before}，\texttt{start}
    メソッド適用も行われることはない．
  \item
    あるオブジェクトへの\texttt{before}メソッド列の適用と\texttt{start}メソッドの適用の間に，
    他のどのオブジェクトへの\texttt{before\_isready}，\texttt{before}，\texttt{start}
    メソッド適用も行われることはない．
  \item
    あるオブジェクトに対して\texttt{after\_isready}メソッド列が全て真を返した際，
    それに続くそのオブジェクトへの\texttt{after}メソッド列の実行の前に，
    他のどのオブジェクトへの\texttt{after\_isready}，\texttt{after}
    メソッド適用も行われることはない．
\end{itemize}

\end{document}
