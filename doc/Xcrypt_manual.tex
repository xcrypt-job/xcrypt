\documentclass[report]{jsbook}

\usepackage{tascmac}
\usepackage{alltt}
\usepackage[all]{xy}

% 
\def\|{\verb|} %|
%

\title{Xcrypt マニュアル}
\author{京大中島研e-scienceグループ}

\begin{document}
\maketitle
\tableofcontents

\paragraph{メモ}

Daniel Muey 氏の Recursive.pm を使用している．ライセンス的には問題ない
はず．

\part{総論}
\chapter{はじめに}

\section{機能}

通常，ある一つの大きな処理を行うには，その処理を小分け（ジョブと呼ぶ）
にし，それらの処理をジョブスケジューラに依頼する．具体的には，
\begin{enumerate}
\item ジョブスケジューラが理解できるスクリプトを作成し，
\item そのスクリプトをジョブスケジューラに渡し，
\item ジョブスケジューラが返す結果からまた別のスクリプトを作成し，それ
      をジョブスケジューラに渡す，
\end{enumerate}
という一連の操作を繰り返すというものである．

しかし，この方法は処理の繰り返しごとに人手による介入を要し，作業効率が
悪い．そこで，人手で行うところを適当なスクリプト言語により記述すること
で自動実行を実現することが考えられる．Xcrypt はそのスクリプト言語とし
て Perl を採用し，パラメタ指定によるジョブの生成や投入を Perl の関数と
して提供することで，ユーザがジョブ処理を容易に行うことを補助する．

TODO: サーチアルゴリズム等のアルゴリズムモジュールの提供についても記述
する．

\section{動作環境}

・sh 系（sh，bash，zsh 等）または csh 系（csh，tcsh 等）シェル

・Perl 5.10.0（GUI 利用時には Perl/Tk 8.4 も要）


\chapter{Xcrypt スクリプトの記述}

Xcrypt は Perl の拡張である．よって，全ての Perl スクリプトは Xcryptス
クリプトである．しかし，Xcrypt はジョブに関する操作の補助を行うものと考
えられ，Xcrypt スクリプトは典型的には以下の順に記述される．

\def\usemodule{モジュールに関する記述}
\def\defjobdefhash{ジョブ定義ハッシュに関する記述}
\def\operation{ジョブ処理に関する記述}

\begin{enumerate}
 \item \usemodule
 \item \defjobdefhash
 \item \operation
\end{enumerate}

\section{\usemodule}

モジュールは
\begin{boxnote}
\begin{verbatim}
use base qw(core);
\end{verbatim}
\end{boxnote}
\noindent
と記述して読み込む．複数読み込む場合は読み込みたい順に
\begin{boxnote}
\begin{alltt}
use base qw(\textit{mymodule} core);
\end{alltt}
\end{boxnote}
\noindent
と記述して読み込む．利用可能なモジュールに関しては\ref{chapmodule}章で
述べる．

モジュールを読み込むことにより，利用可能になる変数（例えば
\texttt{\$separator}）は
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}
\noindent
と記述してセットする．

\section{\defjobdefhash}

Xcrypt ではジョブはハッシュ（ジョブハッシュと呼ぶ）で実現されている．ジョ
ブを定義するにあたり，ハッシュ自身を記述してもよいが，ジョブ定義ハッシュ
と呼ばれるハッシュを記述すれば，ジョブを生成する際，さらにパラメタを与
えることで多数のジョブを一度に生成できる．例えば，
\begin{boxnote}
\begin{alltt}
%myjob = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}',
    'arg0' => '100',
    'arg1' => '\textit{myinput}',
    'linkedfile0' => '\textit{myexe}',
    'copiedfile0' => '\textit{myinput}',
    'stdofile' => '\textit{myout}',
    'stdefile' => '\textit{myerr}',
    'queue' => '\textit{myqueue}',
    'option' => '\textit{myoption}'
);
\end{alltt}
\end{boxnote}
\noindent
と記述する．デフォルトで定義可能なジョブ定義ハッシュのキーに関
しては\ref{chapjobdefhash}章で述べる．

\if0
ジョブ定義ハッシュキー（例えば
\texttt{userdefinedkey0}と\texttt{userdefinedkey1}）をユーザ定義するに
はあらかじめ
\begin{boxnote}
\begin{verbatim}
addkeys('userdefinedkey0', 'userdefinedkey1');
\end{verbatim}
\end{boxnote}
と書いておく（\ref{chapfun}章を参照のこと）か，または，ジョブ定義ハッ
シュのキーを与える際，
\begin{boxnote}
\begin{verbatim}
':userdefinedkey0' => 0
\end{verbatim}
\end{boxnote}
とキー名を\texttt{:}で始める．
\fi

\section{\operation}

通常，人手で行う処理で，今回，Xcrypt に行わせたい処理について記述す
る．Xcrypt で利用可能な関数については\ref{chapfun}章で述べる．

\section{記述例}\label{secscriptexample}

本章で前節までの説明を踏まえたスクリプト記述例を以下に示す．

\begin{boxnote}
\begin{alltt}
use base qw(limit core);

&limit::initialize(10);
$separator = '-';

%myjob = (
    'id' => '\textit{myjob}',
    'exe' => '\textit{./myexe}',
    'arg0' => '100',
    'arg1' => '\textit{myinput}',
    'linkedfile0' => '\textit{myexe}',
    'copiedfile0' => '\textit{myinput}',
    'stdofile' => '\textit{myout}',
    'stdefile' => '\textit{myerr}',
    'queue' => '\textit{myqueue}',
    'option' => '\textit{myoption}'
);
&prepare_submit_sync(%myjob, 'arg1@' => [2,4]);

\end{alltt}
\end{boxnote}


\chapter{ジョブ処理の流れ}

実際のジョブ処理の流れについて概観する．

\section{概念図}\label{sec:states}

\[
\entrymodifiers={+[F-:<10pt>]}
\xymatrix@=100pt{
  *{} \ar[r]|(.4){\txt{\small オブジェクト生成}} &
  \txt{active} \ar[r]|{\txt{\small 前処理実行}} \ar[d]|{\txt{\small \texttt{xcryptdel}入力}}&
  \txt{prepared} \ar[d]|{\txt{\small \texttt{qsub}実行}} \ar[ld]|{\txt{\small \texttt{xcryptdel}入力}}\\
  \txt{finished} &
  \txt{aborted} &
  \txt{submitted} \ar[d]|{\txt{\small \texttt{qsub}成功}} \ar[l]|{\txt{\small \texttt{qsub}失敗}}\\
  \txt{done} \ar[u]|{\txt{\small 後処理}} &
  \txt{running} \ar[l]|{\txt{\small スクリプト終了}} \ar[u]|{\txt{\small 当該ジョブ消滅}} &
  \txt{queued} \ar[l]|{\txt{\small スクリプト開始}} \ar[lu]|{\txt{\small 当該ジョブ消滅}}
}
\]

\section{実行方法}

環境変数 \texttt{XCRYPT} を Xcrypt をインストールしたディレクトリで定義
する（ここでは \texttt{/usr/share/xcrypt} と仮定する）．シェルが bash
なら，
\begin{screen}
\texttt{\$ XCRYPT=/usr/share/xcrypt; export XCRYPT}
\end{screen}

環境変数 \texttt{XCRJOBSCHED} をジョブスケジューラの名前
\footnote{\texttt{NQS}と\texttt{SGE}とが利用可能である．また，環境変数
\texttt{XCRJOBSCHED} に \texttt{sh} も利用可能である．この場合，ジョブ
をOSのプロセスとして扱い，ジョブスケジューラが導入されていない環境にお
けるジョブの投入・削除・状態取得を行う．}に設定する．シェルが bash
なら，例えば，
\begin{screen}
\texttt{\$ XCRJOBSCHED=SGE; export XCRJOBSCHED}
\end{screen}
とする．

環境変数 \texttt{PERL5LIB} に\texttt{\$XCRYPT/lib}と\texttt{\$XCRYPT/lib/algo/lib}とを追加する．


作業ディレクトリに移動する（ここでは \texttt{\$HOME/wd} とする）．
\begin{screen}
\texttt{\$ cd \$HOME/wd}
\end{screen}

Xcrypt スクリプト（\ref{secscriptexample}節参照）を作成する（ここでは
\texttt{sample.xcr} とする）．

実行する．
\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcrypt sample.xcr}
\end{screen}

\section{作成物}\label{sec:created}

Xcrypt を実行した際，作業ディレクトリ以下に作成される物について説明する．

\subsection*{ディレクトリ}

Xcrypt はジョブごとにディレクトリ（ジョブ作業ディレクトリと呼ぶ）を作成
する．ディレクトリの名前はジョブハッシュの\texttt{id}キーの値である．
ジョブ処理はジョブ作業ディレクトリで行われる．

\subsection*{(Xcrypt スクリプト名)\texttt{.pl}}

Xcrypt が Xcrypt スクリプトから作成する Perl スクリプトである．Xcryptが
行う Xcryptスクリプトの実行は，Perl が行うこの Perl スクリプトの実行を
含む．

\subsection*{ジョブリンク・ジョブファイル}

ジョブ作業ディレクトリからジョブハッシュの
\texttt{linkedfile}\textit{i}キーの値で指定されているファイルへシンボリッ
クリンクを張り，\texttt{copiedfile}\textit{i}キーの値で指定されている作
業ディレクトリ中のファイルのコピーをジョブ作業ディレクトリに作成する．

\subsection*{\texttt{NQS.sh}}

ジョブスケジューラが NQS である際，NQS に渡されるスクリプトである．

\subsection*{\texttt{SGE.sh}}

ジョブスケジューラが Sun Grid Engine である際，Sun Grid Engine に渡され
るスクリプトである．

\subsection*{\texttt{sh.sh}}

シェルをジョブスケジューラとして仮想的に利用す際，シェルに渡されるスク
リプトである．

\subsection*{\texttt{request\_id}}

Xcrypt によるジョブの投入に対し，ジョブスケジューラが返すジョブのリクエ
ストIDを格納する．

\subsection*{\texttt{stdout}}

ジョブの実行コマンドの標準出力が格納される．ジョブハッシュの
\texttt{stdofile}キーの値が指定されている場合，その値のファイル名で作成
される．

\subsection*{\texttt{stderr}}

ジョブの実行コマンドの標準エラー出力が格納される．ジョブハッシュの
\texttt{stdefile}キーの値が指定されている場合，その値のファイル名で作成
される．

\part{各論}
\chapter{モジュール}\label{chapmodule}

Xcrypt スクリプトで利用可能なモジュールについて紹介する．

\section{\texttt{core}}

Xcrypt コアを読み込む．Xcrypt 特有のもの（ジョブ定義ハッシュ等）を使用
する場合には必ず読み込まないといけない．

Xcrypt スクリプトで $\texttt{\$separator}$という変数が使えるようになる．

ジョブ作業ディレクトリ以下にジョブ定義ハッシュにおける\texttt{id}と
\texttt{arg}\textit{i}たちを\texttt{\$separator}で区切った名前のディレ
クトリを作成する．\texttt{\$separator}のデフォルト値は「\texttt{\_}」で
ある．「\texttt{-}」に変えたい場合は，
\begin{boxnote}
\begin{verbatim}
$separator = '-';
\end{verbatim}
\end{boxnote}
とする．

使用できるシンボルは \verb*+@ "$%&'/:;<=>?[\]`{|}+ を除く ASCII 印字可
能文字とする．

また，Xcrypt スクリプトで$\texttt{\$separator\_nocheck}$という変数が使
えるようになる．


この値を $1$ にすると \texttt{\$separator} が使用できるシンボルである
かのチェックを飛ばす．デフォルト値は $0$ である．

\section{\texttt{limit}}

投入するジョブの数を制限する．Xcrypt スクリプトで $\texttt{\$initialize}$ と
いう関数が使えるようになるので，例えば，ジョブ数を$10$に制限したければ，
\begin{boxnote}
\begin{verbatim}
&limit::initialize(10);
\end{verbatim}
\end{boxnote}
\noindent
と記述して使う．

\section{\texttt{successor}}

ジョブを宣言的に定義できるようにする．ジョブ定義ハッシュに
\texttt{successors} というキーが使えるようになるので，例え
ば，\texttt{\%x, \%y} というジョブを定義したければ，
\begin{boxnote}
\begin{verbatim}
...
'successor' => ['x', 'y'],
...
\end{verbatim}
\end{boxnote}
\noindent
と記述して使う．

\section{\texttt{simple\_convergence}}

投入したジョブの今回値と前回値の差が一定値以下になるまで繰り返す
Plan-Do-Check-Action (PDCA) サイクルを容易に実現する関数を提供する．ジョ
ブ定義ハッシュに \texttt{initialvalue}（初期
値），\texttt{initialvalue}（初期値），\texttt{isConvergent}（収束条
件），\texttt{inputfile}（namelist形式の入力ファイル
名），\texttt{sweepname}（入力ファイルから取得する値の名
前），\texttt{outputfile}（出力ファイル名），\texttt{extractrules}（出
力ファイルから値を取得するためのData\_Extractionにおける規則群）という
キーが使えるようになる．


\section{\texttt{dry}}

Xcrypt をドライモード（コマンドの実行のみ行わないモード）で動作させるこ
とができる．

ジョブ定義ハッシュに
\begin{boxnote}
\begin{verbatim}
...
'dry' => 1,
...
\end{verbatim}
\end{boxnote}
\noindent
と記述することでジョブがドライモードで動作する．

\if0
また，
\begin{screen}
\texttt{\$ xcrypt -d sample.xcr}
\end{screen}
\noindent
とオプションつきで実行することでドライモードで動作させることもできる．
\fi

\if0
\section{\texttt{minimax}}

あるノードからその子ノードを与えるプログラムと，ノードに対する評価関数
であるプログラムとを与えることで，木アルゴリズムであるミニマックス法を
行う．

例えば，前者のプログラムを \texttt{getchildren}，後者のプログラムを
\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari} とする
時，

\begin{boxnote}
\begin{verbatim}
%myjob = (
    'id'          => 'job10',
    'linkedfile0' => 'getchildren',
    'linkedfile1' => 'komadoku',
    'linkedfile2' => 'kuraidori',
    'linkedfile3' => 'ikiataribattari',
    'arg0'        => '9',               # depth of lookahead
    'arg1'        => '0',               # position
    'arg2'        => 'getchildren'      # get next positions
);

@results = &prepare_submit_sync(%myjob, 'arg3@' => ['komadoku',
				                  'kuraidori',
				                  'ikiataribattari']);
\end{verbatim}
\end{boxnote}

\noindent
と記述すること
で，\texttt{komadoku}，\texttt{kuraidori}，\texttt{ikiataribattari}，の
三つの評価関数下における \texttt{0} の位置のノードから \texttt{9} の深
さで先読みした際の値をそれぞれ返す．
\fi

\chapter{ジョブ定義ハッシュ}\label{chapjobdefhash}

ジョブ定義ハッシュにおいてデフォルトで利用可能なキーについて紹介する．

\section{\texttt{id}}

実行されるジョブを識別する語を記述する．

使用できるシンボルは \verb*+@ "$%&'/:;<=>?[\]`{|}+ を除く ASCII 印字可
能文字とする．

\section{\texttt{exe}}

実行されるジョブの実行コマンドを記述する．後述の\texttt{arg}\textit{i}
とともに
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}
といった形で実行される．

\section{\texttt{arg}\textit{i}}

実行されるジョブの実行コマンドの引数を記述する．前述の\texttt{exe}とと
もに
\begin{screen}
\texttt{\$ exe arg0 arg1 ... arg255}
\end{screen}
といった形で実行される．

\section{\texttt{linkedfile}\textit{i}}

この値のリンク名でジョブ作業ディレクトリから作業ディレクトリのファイル
へシンボリックリンクを張る．

\section{\texttt{copiedfile}\textit{i}}

この値のファイル名でジョブ作業ディレクトリから作業ディレクトリにコピー
をつくる．

\section{\texttt{copieddir}\textit{i}}

この値の名前であるディレクトリ中のファイルから作業ディレクトリにコピー
をつくる．

\section{\texttt{stdofile}}

この値のファイル名で実行プログラムとジョブスケジューラの標準出力を格納
する．空の場合は「stdout」というファイル名になる．

\section{\texttt{stdefile}}

この値のファイル名で実行プログラムとジョブスケジューラの標準エラー出力
を格納する．空の場合は「stderr」というファイル名になる．

\section{\texttt{queue}}

実行するジョブを投入するキューの名前を記述する．

\section{\texttt{cpu}}

使用するコア数を指定する．

\section{\texttt{proc}}

使用するプロセス数を指定する．

\section{\texttt{option}}

ジョブスケジューラのオプションを記述する．

\if0
\section{\texttt{predecessor}}

ジョブを，値であるところのジョブたちの処理が終わるまで投入しないものと
する．

\section{\texttt{successor}}

ジョブ処理後，値であるところのジョブたちを生成する．
\fi

\chapter{組込み関数}\label{chapfun}

Xcrypt で利用可能な組込み関数のうち，Perl の組込み関数でないものについ
て紹介する．

\def\format{書式}
\def\example{記述例}
\def\advanced{発展}


\section{\texttt{prepare}}\label{sec:prepare}

ジョブ定義ハッシュと（リファレンス\footnote{本稿ではリファレンスは型グ
ロブを含まないものとする．}またはスカラで与えられる）パラメタを受け取
り，適当なジョブリファレンスの配列を返す．特に，ジョブの\texttt{id}は後
述の\texttt{RANGE}\textit{i}により生成される．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
prepare(ジョブ定義ハッシュ[,'RANGE0' => (配列リファレンス)]
                      ...[,'RANGE255' => (配列リファレンス)]
                         [,'ジョブ定義ハッシュキー@' => (リファレンス||スカラ)]
                      ...[,'ジョブ定義ハッシュキー@' => (リファレンス||スカラ)]);
\end{verbatim}
\end{boxnote}

ただし，「ジョブ定義ハッシュキー\texttt{@}」はジョブ定義ハッシュキー
（\texttt{arg0}等）の語尾に\texttt{@}をつけ加えたもの
（\texttt{arg0@}等）を意味するものとする．

\texttt{RANGE}\textit{i}の値であるところの配列リファレンスにおける配列に使用できるシンボルは \verb*+@ "$%&'/:;<=>?[\]`{|}+ を除く ASCII 印字可能文字とする．

\subsection{\example}

\begin{boxnote}
\begin{verbatim}
@jobs = prepare('id' => 'myjob', 'exe' => './myexe', 'arg0@' => [10,20]);
\end{verbatim}
\end{boxnote}

これは以下と同義である．

\begin{boxnote}
\begin{verbatim}
@jobs = ();
push(@jobs, {'id' => 'myjob_0', 'exe' => './myexe', 'arg0' => '10'});
push(@jobs, {'id' => 'myjob_1', 'exe' => './myexe', 'arg0' => '20'});
\end{verbatim}
\end{boxnote}

宣言的に書くこともできる．

\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'myjob',
    'exe' => './myexe',
    'arg0@' => [10,20]
);
prepare(%abc);
\end{verbatim}
\end{boxnote}

ジョブ定義ハッシュとパラメタを分けて書くこともできる．

\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'myjob',
    'exe' => './myexe'
);
prepare(%abc, 'arg0@' => [10,20]);
\end{verbatim}
\end{boxnote}

\texttt{RANGE0}と関数リファレンスを使うことでさまざまなパラメタでジョブ
を生成することができる．例えば，
\begin{boxnote}
\begin{verbatim}
@jobs = prepare(%abc, 'RANGE0' => [0..99], 'arg0@' => sub { 2 * $_[0] });
\end{verbatim}
\end{boxnote}
は\texttt{prepare(\%abc, 0), prepare(\%abc, 2),..., prepare(\%abc,
198)}を順番に行ったものと同義である．


\subsection{\advanced}

パラメタは複数書くことができる．複数パラメタの配列の頭からジョブは生成
される．例えば，

\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'myjob',
    'exe' => './myexe'
);
@jobs = prepare(%abc, 'arg0@' => [0,1], 'arg1@' => [2,3]);
\end{verbatim}
\end{boxnote}
は以下と同義である．
\begin{boxnote}
\begin{verbatim}
@jobs = ();
push(@jobs, {'id' => 'myjob_0', 'exe' => './myexe', 'arg0' => '0', 'arg1' => '2'});
push(@jobs, {'id' => 'myjob_1', 'exe' => './myexe', 'arg0' => '1', 'arg1' => '3'});
\end{verbatim}
\end{boxnote}

\texttt{RANGE0}等と関数リファレンスを使うことでパラメタをかけ合わせてジョ
ブを生成することができる．例えば，
\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'myjob',
    'exe' => './myexe'
);
@jobs = prepare(%abc, 'RANGE0' => [0,1], 'RANGE1' => [2,4],
                'arg0@' => sub { $_[0] + $_[1] });
\end{verbatim}
\end{boxnote}
は以下と同義である．
\begin{boxnote}
\begin{verbatim}
@jobs = ();
push(@jobs, {'id' => 'myjob_2', 'exe' => './myexe', 'arg0' => '2'});
push(@jobs, {'id' => 'myjob_4', 'exe' => './myexe', 'arg0' => '4'});
push(@jobs, {'id' => 'myjob_3', 'exe' => './myexe', 'arg0' => '3'});
push(@jobs, {'id' => 'myjob_5', 'exe' => './myexe', 'arg0' => '5'});
\end{verbatim}
\end{boxnote}

引数がリファレンスでなくスカラである時，引数は \texttt{eval} される．ゆ
えに，上記は，
\begin{boxnote}
\begin{verbatim}
%abc = (
    'id' => 'myjob',
    'exe' => './myexe'
);
@jobs = prepare(%abc, 'RANGE0' => [0,1], 'RANGE1' => [2,4],
                'arg0@' => '$_[0] + $_[1]');
\end{verbatim}
\end{boxnote}
とも書くこともできる．

\section{\texttt{submit}}\label{sec:submit}

\if0
ジョブリファレンスの配列を受け取り，各ジョブをジョブスケジューラに渡
し，ジョブスケジューラからジョブスレッドを受け取り，それらの配列を返す．
\fi

ジョブリファレンスの配列を受け取り，各ジョブをジョブスケジューラに渡
し，ジョブリファレンスの配列を返す．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
submit(ジョブリファレンスの配列);
\end{verbatim}
\end{boxnote}

\subsection{\example}

典型的には\texttt{prepare}の返り値を引数にとる．

\begin{boxnote}
\begin{verbatim}
@jobs = prepare('id' => 'myjob', 'exe' => './myexe', 'arg0@' => [10,20]);
submit(@jobs);
\end{verbatim}
\end{boxnote}

自力でジョブリファレンスの配列を書いてもよい．

\begin{boxnote}
\begin{verbatim}
submit({'id' => 'myjob_0', 'exe' => './myexe', 'arg0' => '10'},
       {'id' => 'myjob_1', 'exe' => './myexe', 'arg0' => '20'});
\end{verbatim}
\end{boxnote}

\section{\texttt{sync}}

\if0
ジョブスレッドの配列を受け取り，ジョブ処理後のジョブリファレンスの配列
を返す．
\fi

ジョブリファレンスの配列を受け取り，それらの同期をとり，ジョブリファレ
ンスの配列を返す．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
sync(ジョブリファレンスの配列);
\end{verbatim}
\end{boxnote}

\subsection{\example}

典型的には\texttt{submit}の返り値を引数にとる．

\begin{boxnote}
\begin{verbatim}
@jobs = prepare('id' => 'myjob', 'exe' => './myexe', 'arg0@' => [10,20]);
@objs = submit(@jobs);
sync(@objs);
\end{verbatim}
\end{boxnote}

\section{\texttt{addkeys}}

文字列の配列を受け取り，それらを\texttt{prepare}で展開されるジョブ定義ハッ
シュキーとして利用可能にする．

\subsection{\format}

\begin{boxnote}
\begin{verbatim}
addkeys(文字列の配列);
\end{verbatim}
\end{boxnote}

\section{\texttt{prepare\_submit}}

\texttt{prepare}，\texttt{submit}を順に行う．ただし，\texttt{prepare}で
生成したジョブリファレンスを即座に\texttt{submit}する（全てのジョブリファ
レンスが生成されるのを待たない）．\format は\texttt{prepare}に準ずる．

\section{\texttt{submit\_sync}}

\texttt{submit}，\texttt{sync}を順に行う．\format は\texttt{submit}に準
ずる．

\section{\texttt{prepare\_submit\_sync}}

\texttt{prepare\_submit}，\texttt{sync}を順に行う．\format は
\texttt{prepare}に準ずる．


\appendix
\chapter{ジョブクラス拡張モジュール実装の手引}

\section{はじめに}
Xcryptの\|prepare|関数によって生成された全てのジョブオブジェクトは
\|$XCRYPT/lib/core.pm| %$
で定義された\|core|クラスに属する．
Xcryptのユーザや開発者は，拡張モジュールを定義して\|core|クラスを拡張
することでXcryptの機能を拡張することが可能である．
本章では，この拡張モジュールを開発するために必要な情報を示す．

\section{拡張モジュールの定義と利用}
\textit{mymodule}という名前の拡張モジュールを定義するためには，
\textit{mymodule}\|.pm| という名前の
ファイルを\|$XCRYPT/lib/|（または\|$PERL5LIB|で指定されている
  どこかのディレクトリ）に置く．
Xcryptユーザは，スクリプトの先頭で，
\begin{screen}
\begin{alltt}
use base (\ldots {\it mymodule} \ldots core);
\end{alltt}
\end{screen}
のようにモジュール名を指定することで，当該モジュールの機能を使用できる．


\section{拡張モジュールスクリプトの構成}

典型的な拡張モジュールの定義スクリプトは以下のように記述される．

\begin{boxnote}
  \begin{alltt}
package {\it mymodule};
  \end{alltt}
\begin{verbatim}
use strict;
use ...;

&addkeys('my_instance_member', ...);

my $my_class_member;

# special methods
sub new {
  my $class = shift;
  my $self = $class->NEXT::new(@_);
  ... 
  return bless $self, $class;
}

sub before_isready { ... }
sub before { ... }

sub start
{
  my $self = shift;
  ...
  $self->NEXT::start();
  ...
}

sub after { ... }
sub after_isready { ... }

# general methods
sub another_method
{
  ...
}
\end{verbatim}
\end{boxnote}

以下，スクリプトの各構成要素について説明する．

\begin{enumerate}
  \item モジュール名の定義：\|package|で指定する．ここで指定する名前は，
    モジュールファイル名の拡張子（\|.pm|）を除いた部分と同一でなければ
    ならない．
  \item Perlモジュールの取り込み：通常のPerlプログラムと同様に，必要なPerlモジュールを\|use|で取り込む．
  \item 追加するインスタンス変数の定義：ジョブクラスに新たに追加したい
    インスタンス変数の名前を\|addkeys|関数により定義する．ここで定義し
    たインスタンス変数は，ジョブオブジェクトの属性として，Xcryptスクリプトや
    モジュール内のメソッドから\|$job->{my_instance_menber}| %$
    などとしてアクセスできる．また，Xcryptユーザがジョブ定義ハッシュの記述時に，\\
    \|  |\|%template = {| \ldots \|, my_instance_menber=>|{\it value}\|,| \ldots \|}|\\
    のようにして値を設定することもできる．
  \item クラス変数の定義：通常のPerlのオブジェクト指向プログラミングと同様，
    クラス変数はパッケージ内のグローバル変数として定義する．ここで定義した変数は，
    \|$|{\it mymodule}\|::my_class_member|としてアクセスできる %$
  \item メソッドの定義：このモジュールにおいて追加，拡張するメソッドをパッケージ内の
    トップレベル関数として定義する．通常のPerlオブジェクト指向プログラミングと同様であるが，
    特定の名前を持つメソッドは特別な意味を持つので注意する．（次節で説明）
\end{enumerate}

\section{特別な意味を持つメソッド}
\subsection{\texttt{new}メソッド}
コンストラクタに相当するクラスメソッドであり，
Xcryptの\|prepare|関数（\ref{sec:prepare}節）の処理中に，
最もspecializedなクラス（Xcryptスクリプトのヘッダで宣言されているモジュール列
のうち最も左に書かれているもの）の\|new|メソッドが呼び出される．

このnewメソッドに渡される引数は以下の通りである．
\begin{enumerate}
\item Xcryptスクリプトが属するパッケージ名（＝\|user|）
\item ジョブオブジェクトへの参照．オブジェクトのメンバには，\|prepare|関数に渡されたジョブ定義ハッシュに対応する値がセットされている．
\end{enumerate}
ジョブ定義ハッシュの\|RANGE|等の指定により\|prepare|関数が複数のジョブオブジェクト
を生成した場合は，その各オブジェクトに対して\|new|が適用される．

メソッドの本体では，\|$class->NEXT::new($self,$obj)| %$
（\|$class|，\|$obj|はそれぞれ引数として渡されたクラス名およびオブジェクトへの参照）
のようにして親クラスの\|new|メソッドを呼び出すことができる．
典型的には，各\|new|メソッドはまず親クラスの\|new|メソッドを，
与えられた2つの引数をそのまま引き渡して呼び出し，
その返り値のオブジェクトにアクセスしつつ必要な処理を行った後，
\|bless オブジェクトへの参照, 渡されたクラス名|の値を
メソッドの返り値として\|return|すべきである．

\|core|モジュールでも\|new|メソッドが定義されており，ここでは
\ref{sec:created}節で説明したジョブの作業ディレクトリおよび
その中へのファイルのコピー・シンボリックリンクの生成処理を行う．
子クラスの\|new|メソッドにより\|core|モジュールの\|new|メソッド
が呼び出されないと，この処理が行われなくなるので注意すること．

\subsection{\texttt{before\_isready}メソッド}
状態（\ref{sec:states}節）が\|prepared|になったジョブオブジェクトに対して
適用される．一般にはXcryptスクリプト中の\|submit|関数（\ref{sec:submit}節）
の適用により，ジョブの状態が\|prepared|になる．
引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{before\_isready}メソッドが定義されて
いた場合は，{\bf 子クラス→親クラスの順で全ての}\texttt{before\_isready}メソッド
が呼び出される．

各メソッドは，真偽値を返す．
呼び出された\texttt{before\_isready}メソッド列のうち，1つでも偽を返したメソッドが
あれば，しばらくの時間待ち合わせた後，もう一度\texttt{before\_isready}メソッド列
の実行が行われる．

\subsection{\texttt{before}メソッド}
\texttt{before\_isready}メソッド列が適用され，その全てが真を返したジョブオブジェクト
に対して適用される．引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{before}メソッドが定義されて
いた場合は，{\bf 子クラス→親クラスの順で全ての}\texttt{before}メソッド
が呼び出される．

メソッドの返り値は破棄される．

\subsection{\texttt{start}メソッド}
\texttt{before}メソッドの処理が終わったジョブオブジェクトに対して適用される．
引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{start}メソッドが定義されていた場合は，
最もspecializedなクラスの\|start|メソッドが呼び出される．

メソッドの本体では，\|$obj->NEXT::start()| %$
（\|$obj|は引数として渡されたジョブオブジェクトへの参照）%$
のようにして親クラスの\|start|メソッドを呼び出すことができる．

\|core|モジュールでも\|start|メソッドが定義されており，ここでは
ジョブスクリプトの生成およびバッチスケジューラへのジョブ投入処理を行う．
子クラスの\|start|メソッドにより\|core|モジュールの\|start|メソッド
が呼び出されないと，この処理が行われなくなるので注意すること．

\subsection{\texttt{after\_isready}メソッド}
状態（\ref{sec:states}節）が\|done|になったジョブオブジェクトに対して
適用される．一般には，\|core::start|メソッドによってバッチスケジューラに
投入したジョブからのジョブ完了通知により，ジョブの状態が\|done|になる．
引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{after\_isready}メソッドが定義されて
いた場合は，{\bf 親クラス→子クラスの順で全ての}\texttt{after\_isready}メソッド
が呼び出される．

各メソッドは，真偽値を返す．
呼び出された\texttt{after\_isready}メソッド列のうち，1つでも偽を返したメソッドが
あれば，しばらくの時間待ち合わせた後，もう一度\texttt{after\_isready}メソッド列
の実行が行われる．

\subsection{\texttt{after}メソッド}
\texttt{after\_isready}メソッド列が適用され，その全てが真を返したジョブオブジェクト
に対して適用される．引数はジョブオブジェクトへの参照である．
複数のモジュールで\texttt{after}メソッドが定義されて
いた場合は，{\bf 親クラス→子クラスの順で全ての}\texttt{after}メソッド
が呼び出される．

メソッドの返り値は破棄される．

\subsection{\texttt{before\_isready}，\texttt{before}，\texttt{start}，\texttt{after\_isready}，\texttt{after}の並行性}
\texttt{before}，\texttt{before\_isready}，\texttt{start}，\texttt{after}，\texttt{after\_isready}の各メソッドは
Xcryptのユーザスレッドとは並行に実行される．ただし，各ジョブオブジェクト間についてのこれらのメソッドの実行は
完全に並行に実行されるわけではない．Xcrypt処理系が保証する並行性は以下の通りである．
\begin{itemize}
  \item
    どのジョブオブジェクトの
    \texttt{before\_isready}，\texttt{before}，\texttt{start}，\texttt{after\_isready}，\texttt{after}メソッドも
    Xcryptのユーザスレッドとは並行に実行される．
  \item
    どのジョブオブジェクトの\texttt{before\_isready}，\texttt{before}，\texttt{start}メソッドも2つ以上並行に実行されることはない．
  \item
    どのジョブオブジェクトの\texttt{after\_isready}，\texttt{after}，メソッドも2つ以上並行に実行されることはない．
  \item
    あるオブジェクトに対して\texttt{before\_isready}メソッド列が全て真を返した際，
    それに続くそのオブジェクトへの\texttt{before}メソッド列の実行の前に，
    他のどのオブジェクトへの\texttt{before\_isready}，\texttt{before}，\texttt{start}
    メソッド適用も行われることはない．
  \item
    あるオブジェクトへの\texttt{before}メソッド列の適用と\texttt{start}メソッドの適用の間に，
    他のどのオブジェクトへの\texttt{before\_isready}，\texttt{before}，\texttt{start}
    メソッド適用も行われることはない．
  \item
    あるオブジェクトに対して\texttt{after\_isready}メソッド列が全て真を返した際，
    それに続くそのオブジェクトへの\texttt{after}メソッド列の実行の前に，
    他のどのオブジェクトへの\texttt{after\_isready}，\texttt{after}
    メソッド適用も行われることはない．
\end{itemize}

\end{document}
