\documentclass[a4paper,10pt]{report}

%\addtolength{\topmargin}{-50pt}
%\addtolength{\textheight}{80pt}
\addtolength{\oddsidemargin}{-35pt}
\addtolength{\textwidth}{70pt}

\usepackage{tascmac}
\usepackage{alltt}
%\usepackage[all]{xy}

%
\def\|{\verb|} %|
%

\title{Xcrypt Manual}
\author{E-Science Group, Nakashima Laboratory, Kyoto University}

\begin{document}
\maketitle
\tableofcontents

\part{General}
\chapter{Introduction}

\section{Overview}

In using a high-performance computer, we usually commit job processing
to a job scheduler.  At this time, we often go through the following
procedures:
\begin{itemize}
\item to create a script in its writing style depending on the
      job scheduler,
\item to pass the script to the job scheduler, and
\item to extract data from its result, create another script from
      the data, and pass it to the job scheduler.
\end{itemize}

However, such procedures require manual intervention cost.  It
therefore seems better to remove manual intervention in mid-processing
by using an appropriate script language.  Xcrypt is a script language
for job parallelization.  We can deal with jobs as objects (called
\textit{job objects}) in Xcrypt and manipulate the jobs as well as
objects in an object-oriented language.  Xcrypt provides some
functions and modules for facilitating job generation, submission,
synchronization, etc.  Xcrypt makes it easy to write scripts to process
job, and supports users to process jobs easily.

\section{Environment}

Xcrypt requires Perl ($\geq$ 5.10.0) and a superset of Bourne shell.

\if0
, and Perl/Tk 8.4 for GUI.
\fi

Xcrypt also requires the following outer modules:
\begin{itemize}
\item Marc Lehmann's Coro (where conftest.c is not contained), EV,
\item Graham Barr's Error,
\item Joshua Nathaniel Pritikin's Event,
\item Salvador Fandi\~no's Net-OpenSSH,
\item Daniel Muey's Recursive,
\end{itemize}
and wants Marc Lehmann's AnyEvent, common::sense, and Guard (warns if
none).  These modules are bundled with Xcrypt.


\chapter{Script}

Xcrypt is a script language, and an extension of Perl.  Xcrypt provides
some functions and modules (not in Perl) which support how to deal
with \textit{jobs}.

An Xcrypt script consists of descriptions of
\begin{enumerate}
 \item module,
 \item template, and
 \item procedure.
\end{enumerate}

\section{Module}

Modules for job objects are used as follows,
\begin{boxnote}
\begin{verbatim}
use base qw(core);
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}

When you use multiple modules, it is enough to write
\begin{boxnote}
\begin{alltt}
use base qw(\textit{mymodule} core);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
Every module should be used in order.
The details of the modules are described in Chapter~\ref{chapmodule}.

Commonly-used modules can be loaded as follows,
\begin{boxnote}
\begin{alltt}
use \textit{mymodule};
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
\noindent
similarly to how to use modules in Perl.

\section{Template}

Xcrypt's templates are implemented as Perl's hashes.  For example,
\begin{boxnote}
\begin{alltt}
%mytemplate = (
 'id@' => sub \{ "\textit{myjob}$VALUE[0]"; \},
 'exe0@' => sub \{ "./\textit{myexe} $VALUE[0]"; \},
 'RANGE0' => [0,1]
);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

Keys in templates are described in Chapter~\ref{chapjobdefhash} in
detail.

\section{Job Object}

Xcrypt's job object are implemented as Perl's objects (blessed hash
references).  In Xcrypt, job objects should be typically created from
templates by a built-in function \texttt{\&prepare}
(Chapter~\ref{chapfun} in detail).


\section{Procedure}

Procedures of job processing are described in Xcrypt (and Perl)
instead of manually carried out.
Xcrypt's functions are described in Chapter~\ref{chapfun}.

\section{Example}\label{secscriptexample}

An example script is as follows,
\begin{boxnote}
\begin{alltt}
use base qw(limit core);

&limit::initialize(10);

%mytemplate = (
 'id@' => sub \{ "\textit{myjob}$VALUE[0]"; \},
 'exe0@' => sub \{ "./\textit{myexe} $VALUE[0]"; \},
 'RANGE0' => [0,1]
);

&prepare_submit_sync(%mytemplate);
\end{alltt}
\end{boxnote}


\chapter{Flow}

In this chapter, we introduce how jobs are processed.

\section{State}\label{sec:states}

Any job has one of the following states:
\begin{center}
\begin{tabular}{ll}
initialized: & the job is initialized or aborted,\\
prepared: & the same as initialized (for backward compatibility)\\
submitted: & the job is submitted,\\
queued: & the job is queued,\\
running: & the job is running,\\
done: & the job is done,\\
finished: & the job is finished,\\
aborted: & the job is aborted.
\end{tabular}
\end{center}

\if0
Any job transits to \textit{states} as follows,
\[
\entrymodifiers={+[F-:<10pt>]}
\xymatrix@=100pt{
  *{} \ar[r]|(.4){\txt{\small job object generated}} &
  \txt{initialized} \ar[r]|{\txt{\small pre-processing}} \ar[d]|{\txt{\small \texttt{\$ xcryptdel}}}&
  \txt{prepared} \ar[d]|{\txt{\small job submitted}} \ar[ld]|{\txt{\small \texttt{\$ xcryptdel}}}\\
  \txt{finished} &
  \txt{aborted} &
  \txt{submitted} \ar[d]|{\txt{\small job generated}} \ar[l]|{\txt{\small \texttt{qsub} failed}}\\
  \txt{done} \ar[u]|{\txt{\small post-processing}} &
  \txt{running} \ar[l]|{\txt{\small job script done}} \ar[u]|{\txt{\small job aborted}} &
  \txt{queued} \ar[l]|{\txt{\small job started}} \ar[lu]|{\txt{\small job aborted}}
}
\]

\[
\entrymodifiers={+[F-:<10pt>]}
\xymatrix@C=200pt@R=30pt{
  *{}               \ar[d]|{\txt{\small job object generated}} & *{}\\
  \txt{initialized} \ar[d]|{\txt{\small pre-processing}}
  \ar[rdd]|{\txt{\small \texttt{\$ xcryptdel}}} & *{}\\
  \txt{prepared}    \ar[d]|{\txt{\small job submitted}}
  \ar[rd]|{\txt{\small \texttt{\$ xcryptdel}}} & *{}\\
  \txt{submitted}   \ar[d]|{\txt{\small job queued}}
  \ar[r]|{\txt{\small \texttt{\$ xcryptdel} or \texttt{qsub} failed}} & \txt{aborted}\\
  \txt{queued}      \ar[d]|{\txt{\small job started}}
  \ar[ru]|{\txt{\small \texttt{\$ xcryptdel} or job aborted}} & *{}\\
  \txt{running}     \ar[d]|{\txt{\small job script done}}
  \ar[ruu]|{\txt{\small \texttt{\$ xcryptdel} or job aborted}} & *{}\\
  \txt{done}        \ar[d]|{\txt{\small post-processing}}
  \ar[ruuu]|{\txt{\small \texttt{\$ xcryptdel}}} & *{}\\
  \txt{finished} & *{}
}
\]
\fi

\section{Installation}

Edit \texttt{xcrypt/source-me.sh} in order to set some environment
variables, and
\begin{screen}
\texttt{\$ source source-me.sh}
\end{screen}

Then, continue the following installation procedure:
\begin{screen}
\texttt{\$ cd \$XCRYPT/cpan; ./do-install.sh}
\end{screen}

\section{Execution}

Set \texttt{XCRJOBSCHED}\footnote{\texttt{SGE}, \texttt{t2k-tsukuba},
\texttt{t2k-tokyo}, \texttt{t2k-kyoto}, and \texttt{sh} are available.
In the case of \texttt{sh}, jobs are dealt with as processes in OS.
The default is \texttt{sh}} to your job scheduler.  Optionally, set
\texttt{XCRQUEUE} as the default queue.

Next, move to the working directory (e.g., \texttt{\$HOME/wd})
\begin{screen}
\texttt{\$ cd \$HOME/wd}
\end{screen}
and write an Xcrypt script (e.g., \texttt{sample.xcr}).  See
Section~\ref{secscriptexample} in order to know how to write.

Finally, execute Xcrypt with the script:
\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcrypt sample.xcr}
\end{screen}

If you use Emacs, then the following description in \texttt{.emacs.el}
helps you.
\begin{boxnote}
\begin{verbatim}
(add-to-list 'auto-mode-alist '("\\.xcr" . perl-mode))
\end{verbatim}
\end{boxnote}

\section{Interactive Usage}

\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcrypt} \textit{myscript}\texttt{.xcr}
\end{screen}
makes Xcrypt to interpret \textit{myscript}\texttt{.xcr}.

\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcryptstat}
\end{screen}
shows states of jobs.  In detail, use the \texttt{--help} option.

\begin{screen}
\texttt{\$ \$XCRYPT/bin/xcryptdel} \textit{myjob} [\textit{myjob}...]
\end{screen}
makes states of unfinished jobs aborted.  For deleting all the jobs,
use the \texttt{--all} option.  For making (not necessarily
unfinished) jobs aborted, use the \texttt{--abort} option.  For
making jobs finished, use the \texttt{--finish} option.  For
forgetting states of all jobs, use the \texttt{--clean} option.


\section{Product}\label{sec:created}

Xcrypt creates the following in the working directory
during and after its execution.

%\subsection*{\textit{myscript}\texttt{.pl}}
%is a Perl script created from the Xcrypt script \textit{myscript}.

\if0
\subsection*{file and soft link}

of the names (which are the values of \texttt{copiedfile}\textit{i}
and \texttt{linkedfile}\textit{i}) are copied and created in the job
working directory, respectively.
\fi

\subsection*{\textit{myjob}\_\texttt{\$XCRJOBSCHED.sh}}

is a job script passed to a job scheduler or a Bourne shell script
executed, regarding OS as a job scheduler, respectively.

\subsection*{\textit{myjob}\_\texttt{stdout}}

is a file storing the job's standard output.  When \texttt{stdofile}
is defined, the file is renamed as its value.

\subsection*{\textit{myjob}\_\texttt{stderr}}

is a file storing the job's standard error.  When \texttt{stdefile}
is defined, the file is renamed as its value.

\subsection*{\texttt{inv\_watch}}

is a directory containing log and other files for retry.  When
\texttt{--inventory\_path} is defined, the directory is renamed as its
value.

\part{Details}

\chapter{Module}\label{chapmodule}

In this chapter, we introduce some modules available in Xcrypt scripts.

\section{\texttt{core}}

This module is the Xcrypt core module, and required to be read in
order to use anything particular to Xcrypt.

\section{\texttt{sandbox}}

A directory of the name
\begin{center}
\texttt{join('\_', (\$myjob->\{id\}, @VALUE))}
%\texttt{\$VALUE[0]}\_\texttt{\$VALUE[1]}\_$\ldots$
\end{center}
is created for each job (called a \textit{job working directory}).
Job-processing is done in the job working directory.

The following can be defined in templates.

\texttt{linkedfile}\textit{i}: a soft link of the file (whose name is
its value) is created in the job working directory.

\texttt{copiedfile}\textit{i}: the indicated file is copied to the job
working directory.

\section{\texttt{limit}}

This module limits the number of jobs submitted simultaneously.
In order to limit the number of jobs to $10$, for example, it is enough to
write as follows,
\begin{boxnote}
\begin{verbatim}
&limit::initialize(10);
\end{verbatim}
\end{boxnote}

\section{\texttt{bulk\_simple}}

This module gathers jobs and returns one job of the same denotation.
For bulked jobs, the function \texttt{\&bulk} ignores any member
except \texttt{exe}\textit{i},
\texttt{exe}\textit{i}\texttt{\_}\texttt{j}, \texttt{initially},
\texttt{before}, \texttt{after}, and \texttt{finally}.  Typically, you
can write as follows,
\begin{boxnote}
\begin{verbatim}
my $template = { 'id' => 'bulked_job_', 'JS_queue' => 'myqueue' };
my @jobs0 = &prepare(%template0);
my @jobs1 = &prepare(%template1);
my @bulk = &bulk_simple::bulk($template, @jobs0, @jobs1);
&submit(@bulk);
\end{verbatim}
\end{boxnote}

\section{\texttt{successor}}

This module indicates job objects which can be defined declaratively.
For example, in order to define job objects of the name \texttt{\%x,
\%y}, write:
\begin{boxnote}
\begin{verbatim}
...
'successor' => ['x', 'y'],
...
\end{verbatim}
\end{boxnote}
\vspace{\baselineskip}
\noindent
using the key \texttt{successor} in the template.

\section{\texttt{convergence}}

This module provides a function for a Plan-Do-Check-Action (PDCA)
cycle, to deal with convergence of difference of job's results.  The
keys \texttt{initialvalue}, \texttt{isConvergent}, \texttt{inputfile},
\texttt{sweepname}, \texttt{outputfile}, and \texttt{extractrules} can
be used in templates.

\section{\texttt{n\_section\_method}}

This module provides \textit{n}-section method, a root-finding
algorithm. The only difference from bisection
method\footnote{\texttt{http://en.wikipedia.org/wiki/Bisection\_method/}}
is the number of sections.

The values \texttt{partition} and \texttt{epsilon} denote
    a partition number and an error, respectively.  An interval is
    expressed by \texttt{x\_left} and \texttt{x\_right}.  The values
    \texttt{y\_left} and \texttt{y\_right} are values on \texttt{x\_left}
    and \texttt{x\_right}.  Typically, we can call the function
    \texttt{n\_section\_method} with these keys, e.g.,
\begin{boxnote}
\begin{verbatim}
&n_section_method::n_section_method(%job,
    'partition' => 12, 'epsilon' => 0.01,
    'x_left'  => -1,  'x_right' => 10,
    'y_left'  => 0.5, 'y_right' => -5
);
\end{verbatim}
\end{boxnote}

\section{\texttt{dry}}

This module provides job-processing in dry mode (skipping any command
execution).  Description in a template
\begin{boxnote}
\begin{verbatim}
...
'dry' => 1,
...
\end{verbatim}
\end{boxnote}
\noindent
makes any job (derived from this hash) to be processed in dry mode.

\if0

\section{\texttt{minimax}}

This module provides a function of a tree algorithm \textit{minimax}.
This function takes a tree and a static function on nodes.

The following is a sample script:
\begin{boxnote}
\begin{verbatim}
%myjob = (
    'id'          => 'job10',
    'linkedfile0' => 'getchildren',
    'linkedfile1' => 'strategy1',
    'linkedfile2' => 'strategy2',
    'linkedfile3' => 'strategy3',
    'arg0_0'        => '9',               # depth of lookahead
    'arg0_1'        => '0',               # position
    'arg0_2'        => 'getchildren'      # get next positions
);

&prepare_submit_sync(%myjob,
                     'arg0_3@' => ['strategy1', 'strategy2', 'strategy3']);
\end{verbatim}
\end{boxnote}
\noindent
where \texttt{strategy1}, \texttt{strategy2}, and
\texttt{strategy3} are static functions.

\fi

\section{\texttt{invalidate}}

This module invalidates jobs of which running time is more than
\texttt{allotted\_time} (can be defined in templates).

\chapter{Template}\label{chapjobdefhash}

In this chapter, we introduce keys and values available in templates
by default.

\section{\texttt{RANGE}\textit{i}}

\textit{key}\texttt{@} denotes the one whose postfix is the
character \texttt{@} (e.g., \texttt{exe0@}).


Any word of ASCII printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available for \texttt{RANGE}\textit{i}'s values.

\texttt{@} means

values are array references, function references, (or scalar although
not recommended).

\section{\texttt{id}}

Its value is a word.  The value is used for creating job objects and
identifying the job objects as their prefixes.  Any word of ASCII
printable characters except
\begin{center}
\verb*+@ "$%&'/:;<=>?[\]`{|}+        % " for highlight
\end{center}
is available.

\section{\texttt{exe}\textit{i}}

Its value denotes a command.  The command is executed as follows,
\begin{screen}
\texttt{\$ } \textit{myexe0 myarg0\_0 ...}\\
\texttt{\$ } \textit{myexe1 myarg1\_0 ...}\\
\vdots
\end{screen}
with \texttt{arg}\textit{i}\_\textit{j} explained below.

\section{\texttt{arg}\textit{i}\_\textit{j}}

Its values are arguments of a command.

\section{\texttt{stdofile}}

The standard output is stored in the indicated file.
The default is \texttt{stdout}.

\section{\texttt{stdefile}}

The standard error is stored in the indicated file.
The default is \texttt{stderr}.

\section{\texttt{JS}\_\textit{key}}

\if0
\section{\texttt{queue}}

Its values is a name of a queue.

\section{\texttt{cpu}}

Its value is the number of cores used exclusively.

\section{\texttt{proc}}

Its value is the number of processes used exclusively.

\section{\texttt{option}}

Its value is an option of a job scheduler.

\section{\texttt{successor}}

Its values' jobs are generated after the job is done.
\fi

\chapter{Function}\label{chapfun}

In this chapter, we introduce built-in functions.

\def\format{Format}
\def\example{Example}
\def\advanced{Advanced}

\section{\texttt{prepare}}\label{sec:prepare}

This function takes a job definition hash and parameters of
references\footnote{In this manual, references do not denote type
globs.}, and returns an array of job objects.

%The \texttt{id}s of job objects are generated by \texttt{RANGE}\textit{i} as described later.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
prepare(%template);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\subsubsection{\example}

\begin{boxnote}
\begin{alltt}
@jobs = prepare('id@' => sub \{ "\textit{myjob}$VALUE[0]"; \},
                'exe0@' => sub \{ "./\textit{myexe0} $VALUE[0]"; \},
                'exe1@' => sub \{ "./\textit{myexe1} $VALUE[0]"; \},
                'RANGE0' => [0,1]);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\if0

This is almost the same as
\begin{boxnote}
\begin{alltt}
@jobs = ();
push(@jobs, \{'id' => '\textit{myjob0}', 'exe0' => '\textit{./myexe} 0'\});
push(@jobs, \{'id' => '\textit{myjob1}', 'exe0' => '\textit{./myexe} 1'\});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\fi

Declarative description is also available as follows,
\begin{boxnote}
\begin{alltt}
%mytemplate = (
    'id@' => sub \{ "\textit{myjob}$VALUE[0]"; \},
    'exe0@' => sub \{ "./\textit{myexe0} $VALUE[0]"; \},
    'exe1@' => sub \{ "./\textit{myexe1} $VALUE[0]"; \},
    'RANGE0' => [0,1]
);

@jobs = prepare(%mytemplate);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}


\subsubsection{\advanced}

It is possible to generate job objects by using multiple parameters.
For example,
\begin{boxnote}
\begin{alltt}
%mytemplate = (
    'id@' => sub \{ "\textit{myjob}$VALUE[0]_$VALUE[1]"; \},
    'exe0@' => sub \{ "./\textit{myexe} $VALUE[0] $VALUE[1]"; \},
    'RANGE0' => [0,1],
    'RANGE1' => [2,4]
);
@jobs = prepare(%mytemplate);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

creates 4 job objects.  This is the same as
\begin{boxnote}
\begin{alltt}
%mytemplate = (
    'id@' => sub \{ "\textit{myjob}$VALUE[0]_$VALUE[1]"; \},
    'exe0@' => sub \{ "./\textit{myexe} $VALUE[0] $VALUE[1]"; \},
    'RANGES' => [[0,1],[2,4]]
);
@jobs = prepare(%mytemplate);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{submit}}\label{sec:submit}

This function takes an array of job objects and passes the jobs
(corresponding to the job objects) to a job scheduler.  Its return
value is also the array of job objects.

\subsubsection{\format}
\begin{boxnote}
\begin{alltt}
submit(@\textit{myjobs});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\subsubsection{\example}
Typically, this function takes a return value of \texttt{prepare}.
\begin{boxnote}
\begin{alltt}
@jobs = prepare(%mytemplate);
submit(@jobs);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}
It is possible to define job references without using
\texttt{prepare} (although not recommended).

\section{\texttt{sync}}

This function takes an array of job objects and synchronizes the job objects.
Its return value is the array of job objects.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
sync(\textit{@myjobs});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\subsubsection{\example}

Typically, this function takes a return value of \texttt{prepare}
(same as \texttt{submit}).
\begin{boxnote}
\begin{alltt}
@jobs = prepare(%mytemplate);
submit(@jobs);
sync(@jobs);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{xcr\_exist}}

This function returns 1 if \texttt{\$file} exists (0 unless) at
\texttt{\$env\{location\}}.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
xcr_exist(\|\|%\textit{env}, $file);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{xcr\_qx}}

This function returns \texttt{\$command}'s standard output at
\texttt{\$env\{location\}} as an array.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
xcr_qx(\|\|%\textit{env}, $command);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{xcr\_system}}

This function returns \texttt{\$command}'s return value at
\texttt{\$env\{location\}}.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
xcr_system(\|\|%\textit{env}, $command);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{xcr\_mkdir}}

This function makes a directory of the name \texttt{\$dir} at
\texttt{\$env\{location\}}.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
xcr_mkdir(\|\|%\textit{env}, $dir);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{xcr\_copy}}

This function copies \texttt{\$file\_or\_dir0} to
\texttt{\$file\_or\_dir1} at \texttt{\$env\{location\}}.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
xcr_copy(\|\|%\textit{env}, $file_or_dir0, $file_or_dir1);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{xcr\_rename}}

This function rename \texttt{\$file0} to \texttt{\$file1} at
\texttt{\$env\{location\}}.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
xcr_rename(\|\|%\textit{env}, $file0, $file1);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{xcr\_symlink}}

This function links \texttt{\$file} as \texttt{\$link} in
\texttt{\$dir} at \texttt{\$env\{location\}}.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
xcr_symlink(\|\|%\textit{env}, $file, $dir, $link);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{xcr\_unlink}}

This function removes \texttt{\$file} at \texttt{\$env\{location\}}.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
xcr_unlink(\|\|%\textit{env}, $file);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{get\_from}}

This function gets \texttt{\$file} from \texttt{\$env\{wd\}} in
\texttt{\$env\{location\}}.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
get_from(\|\|%\textit{env}, $file);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{put\_into}}

This function puts \texttt{\$file} into \texttt{\$env\{wd\}} in
\texttt{\$env\{location\}}.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
put_into(\|\|%\textit{env}, $file);
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}


\section{\texttt{add\_host}}

This function takes a hash that denotes a host (containing its
environment), and returns a reference that denotes it.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
add_host(\|\|%\textit{env});
\end{alltt}
\end{boxnote}

\subsubsection{\example}

\begin{boxnote}
\begin{alltt}
$env = add_host(\{'host' => '\textit{foo@bar}', 'wd' => '\textit{/home/foo}'\});
%template = ('id' => '\textit{myjob}', 'exe0' => '\textit{./myexe}', 'env' => $env);
\end{alltt}
\end{boxnote}

\section{\texttt{get\_local\_env}}

This function returns a reference that denotes the local host
(containing its environment).

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
get_local_env();
\end{alltt}
\end{boxnote}

\subsubsection{\example}

\begin{boxnote}
\begin{alltt}
$env = get_local_env();
%template = ('id' => '\textit{myjob}', 'exe0' => '\textit{./myexe}', 'env' => $env);
\end{alltt}
\end{boxnote}


\section{\texttt{add\_key}}

This function takes an array of words and makes it available as keys in job
definition hashes.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
add_key(@\textit{words});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{add\_prefix\_of\_key}}

This function takes an array of words and makes it available as
prefixes of keys in job definition hashes.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
add_prefix_of_key(@\textit{words});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{repeat}}

This function takes an Xcrypt's script code (denoted as
\textit{mystring}) and an integer $i$, and evaluates it each $i$ seconds.

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
repeat(\textit{mystring}, \textit{i});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}


\section{\texttt{set\_expander}}

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
set_expander(\textit{\$string});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{get\_expander}}

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
get_expander();
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{set\_separator}}

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
set_separator(\textit{\$string});
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{get\_separator}}

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
get_separator();
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{check\_separator}}

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
check_separator();
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{nocheck\_separator}}

\subsubsection{\format}

\begin{boxnote}
\begin{alltt}
nocheck_separator();
\end{alltt}
\end{boxnote}
\vspace{\baselineskip}

\section{\texttt{prepare\_submit}}

This function makes \texttt{prepare} and \texttt{submit} applied to
job objects generated by \texttt{prepare}.  The composition of
\texttt{prepare} and \texttt{submit} is done at each job object.

\section{\texttt{prepare\_submit\_sync}}

This function is an abbreviation of \texttt{prepare\_submit} and
\texttt{sync}.  Its format follows \texttt{prepare}.

\chapter{Methods of \texttt{core} Class}\label{chap-coremethod-enduser}
This chapter explains methods defined in \texttt{core} class.
These methods can be used by end users.
The methods that are defined in \texttt{core} class but
should not be used directly by end users are listed in
Appendix \ref{apd-coremethod-developer}.

\section{\texttt{workdir\_member\_file}}
to be written...
\section{\texttt{abort}}
to be written...
\section{\texttt{cancel}}
to be written...
\section{\texttt{invalidate}}
to be written...

\chapter{Option}\label{chapoption}

%\section{\texttt{--port}}

\section{\texttt{--sched}}

takes a batch job scheduler.

\section{\texttt{--print\_log}}

prints the log (in particular, status of job objects), in detail.

\section{\texttt{--compile\_only}}

only makes a Perl script from the Xcrypt scritp, and does not exec the
Perl script.

%\section{\texttt{--xqsub}}

\section{\texttt{--shared}}

does not copy files at a shared system in remote-execution mode.

\section{\texttt{--abort\_check\_interval}}

an interval of checking whether jobs are aborted or not (sec).

\section{\texttt{--left\_message\_check\_interval}}

an interval of checking what states jobs have (sec).

\section{\texttt{--inventory\_path}}

a path at that logs are located.

\section{\texttt{--verbose}}
\section{\texttt{--stack\_size}}

\section{\texttt{--host}}

a host to that jobs are submitted.

\section{\texttt{--wd}}

a working directory in that Xcrypt is executed at a remote host.

\section{\texttt{--xd}}
\section{\texttt{--p5l}}
\section{\texttt{--scratch}}

executes Xcrypt without recovering the states of jobs in the previous
execution.

\appendix

\if0
\chapter{Recipes}

\section{}

\begin{boxnote}
\begin{alltt}
%myjob = (
    'id' => '\textit{myjob}',
    'exe0' => '\textit{./myexe} 0 100 myoutput'
);
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe 0 100 myoutput
\end{alltt}
\end{boxnote}

\section{}

\begin{boxnote}
\begin{alltt}
%myjob = (
    'id' => '\textit{myjob}',
    'exe0' => '\textit{./myexe}',
    'arg0_0@' => [0,1],
    'arg0_1' => 100,
    'arg0_2@' => [\textit{myoutput0},\textit{myoutput}1]
);
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe 0 100 myoutput
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe 1 100 myoutput
\end{alltt}
\end{boxnote}

\section{}

\begin{boxnote}
\begin{alltt}
%myjob = (
    'id' => '\textit{myjob}',
    'exe0' => '\textit{./myexe0}',
    'exe1' => '\textit{./myexe1}',
    'arg0_0@' => [0,1],
    'arg0_1' => 100,
    'arg0_2@' => [\textit{myoutput00},\textit{myoutput01}],
    'arg1_0@' => [2,3],
    'arg1_1' => 200,
    'arg1_2@' => [\textit{myoutput10},\textit{myoutput11}]
);
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe0 0 100 myoutput00
./myexe1 2 200 myoutput10
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe0 1 100 myoutput01
./myexe1 3 100 myoutput11
\end{alltt}
\end{boxnote}


\section{}

\begin{boxnote}
\begin{alltt}
%myjob = (
  'id' => '\textit{myjob}',
  'exe0' => sub \{ "\textit{./myexe} $VALUE[0] 100 \textit{myoutput} $VALUE[0]"; \},
  'RANGE0' => [0,1]
);
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe 0 100 myoutput0
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe 1 100 myoutput1
\end{alltt}
\end{boxnote}

\section{}

\begin{boxnote}
\begin{alltt}
%myjob = (
  'id' => '\textit{myjob}',
  'exe0' => sub \{ "\textit{./myexe} $VALUE[0] $VALUE[1] \textit{myoutput} $VALUE[0]_$VALUE[1]"; \},
  'RANGE0' => [0,1],
  'RANGE1' => [100,101],
);
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe 0 100 myoutput0
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe 0 101 myoutput0
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe 1 100 myoutput0
\end{alltt}
\end{boxnote}

\begin{boxnote}
\begin{alltt}
./myexe 1 101 myoutput1
\end{alltt}
\end{boxnote}

\fi

\chapter{How to Implement Job Class Extension Modules}

Any job object generated by the Xcrypt's function \|prepare| belongs
to the class \|core|, defined by \|$XCRYPT/lib/core.pm|.%$
Xcrypt users and developers can extend the class \|core| by defining
modules and consequently expand the function of Xcrypt.
In this chapter, we introduce how to implement such extension modules.

\section{How to Define and Use Extension Modules}

In order to define an extension module of the name \textit{mymodule},
it is enough for Xcrypt developers to put it into any directory
designated by \|$XCRYPT/lib/| (or \|$PERL5LIB|).

Then Xcrypt users can use the extension module by simply indicating
their name on the header of his/her script as follows:
\begin{screen}
\begin{alltt}
use base (\ldots {\it mymodule} \ldots core);
\end{alltt}
\end{screen}


\section{Scripts of Extension Modules}

A definition script for an extension module is typically described as follows,
\begin{boxnote}
  \begin{alltt}
package {\it mymodule};
  \end{alltt}
\begin{verbatim}
use strict;
use ...;

&add_key('my_instance_member', ...);

my $my_class_member;

# special methods
sub new {
  my $class = shift;
  my $self = $class->NEXT::new(@_);
  ... 
  return bless $self, $class;
}

sub before { ... }

sub start
{
  my $self = shift;
  ...
  $self->NEXT::start();
  ...
}

sub after { ... }

# general methods
sub another_method
{
  ...
}
\end{verbatim}
\end{boxnote}%$
\vspace{\baselineskip}

In the following, we make an explanation for each component of the script.
\begin{enumerate}
  \item Definition of the module name: is designated by \|package|.
	The module name must coincide with the file name
        without its extension (\|.pm|).
  \item Use of Perl modules: is declared by using \|use|
        as in typical Perl programs.
  \item Addition of instance variables: is performed by the function
	\|add_key|.  The added instance variables are accessible as
	attributes of the job objects by writing, e.g.,
	\begin{center}
	 \|$job->{my_instance_member}|%$
	\end{center}
	in Xcrypt scripts and modules.  Also, by writing, e.g.,
	\begin{center}
	 \|  |\|%template = {| \ldots \|, my_instance_menber=>|{\it value}\|,| \ldots \|}|
	\end{center}
	users can set values to them.
 \item Definition of class variables: is done in the usual way in
       object-oriented programming, i.e., class variables are defined
       as global variables in packages.  The variables can be
       accessed, e.g.,
	 \begin{center}
	  \|$|{\it mymodule}\|::my_class_member| %$
	 \end{center}
  \item Definition of methods: is defined in the usual way, i.e.,
	methods added and extended in modules are defined as top-level
	functions in packages.  Note that some methods with
	particular names have special meanings as explained in the next
	section.
\end{enumerate}

\section{Special Methods}

Xcrypt gives special meanings to the following class methods.

\subsection{\texttt{new}}

The method \texttt{new} is a class method, the so-called
\textit{constructor}.  The method \|new| in the most specialized class
(the left-most module declared on the script header) is called.

The method \|new| takes the following arguments:
\begin{enumerate}
\item the package name ($=$ \|user|) to which an Xcrypt script belongs,
\item a reference to a job object\footnote{The object members has
      values in the template passed to the function \texttt{prepare}.}.
\end{enumerate}
Note that \|new| is applied to each of multiple objects
generated by \|prepare|.

In the body of a method, the method \|new| in the parent class is
called as
\begin{center}
 \|$class->NEXT::new($self,$obj)| %$
\end{center}
where \|$class| and \|$obj| are the class name and reference to the
object, the arguments of \|new|, respectively.

Typically, each \|new| calls \|new| in his parent class with the same
two arguments, processes its return value (an object), and returns
\|bless| \textit{reference to the object},
\textit{the class name} as return values.

In the module \|core|, \|new| is defined.  The \|new| creates a job
directory, soft links, and copies of files (explained in
Section~\ref{sec:created}).  Note that this required procedure is
skipped unless \|new|s in children classes call the \|new| in the
\|core|.

\subsection{\texttt{initially}}
to be written...

\if0
\subsection{\texttt{before\_isready}}

In Xcrypt, application of the function \|submit| (cf.\
Section~\ref{sec:submit}) makes a job object's state \|prepared|.  The
methods \texttt{before\_isready}s are applied to a job object of the
state \|prepared| (cf.\ Section~\ref{sec:states}).  Its argument is a
reference to the job object.  The order of calling
\texttt{before\_isready}s is in such a way from children to parents
classes.  Each method returns a boolean value.  When some
\texttt{before\_isready}s called in the object return false,
\texttt{before\_isready}s are called after a little interval time.

\subsection{\texttt{before}}

The methods \texttt{before}s are applied to a job object when all of
the methods \texttt{before\_isready}s applied to the job object return
true.  Its argument is a reference to the job object.  The order of calling
\texttt{before}s is in such a way from children to parents
classes.  Return values of the methods are abandoned.
\fi

\subsection{\texttt{before}}

In Xcrypt, application of the function \|submit| (cf.\
Section~\ref{sec:submit}) makes a job object's state \|prepared|.  The
methods \texttt{before}s are applied to a job object of the state
\|prepared| (cf.\ Section~\ref{sec:states}).  Its argument is a
reference to the job object.  The order of calling \texttt{before}s is
in such a way from children to parents classes.  Return values of the
methods are abandoned.

\subsection{\texttt{start}}

The methods \texttt{start}s are applied to a job object after
\texttt{before}s to the job objects are applied.  Its argument is a
reference of the job object.  The method \|start| in the most
specialized class (the left-most module declared on the script header)
is called.

In the body of a method, the method \|new| in the parent class is
called as
\begin{center}
 \|$obj->NEXT::start()| %$
\end{center}
where \|$obj| is the reference to the object. %$

In the module \|core|, \|start| is defined.  The \|start| creates a
job script and submits the job to a job scheduler.  Note that this
required procedure is skipped unless \|start|s in children classes call
the \|start| in the \|core|.

\if0
\subsection{\texttt{after\_isready}}

In Xcrypt, a completion notice of a job submitted by the method
 \|core::start| makes the job object's state \|done|.  The methods
 \texttt{after\_isready}s are applied to a job object with the state
 \|done| (cf.\ Section~\ref{sec:states}).  Its argument is a reference
 to the job object.  The order of calling \texttt{after\_isready}s is
 in such a way from parents to children classes.  Each method
 returns a boolean value.  When some \texttt{after\_isready}s called
 in the object return false, \texttt{after\_isready}s are called
 after a little interval time.

\subsection{\texttt{after}}

The methods \texttt{before}s are applied to a job object when all of
the methods \texttt{after\_isready}s applied to the job object return
true.  Its argument is a reference to the job object.  The order of
calling \texttt{after}s is in such a way from parents to children classes.
Return values of the methods are abandoned.
\fi

\subsection{\texttt{after}}

In Xcrypt, a completion notice of a job submitted by the method
 \|core::start| makes the job object's state \|done|.  The methods
 \texttt{after}s are applied to a job object with the state \|done|
 (cf.\ Section~\ref{sec:states}).  Its argument is a reference to the
 job object.  The order of calling \texttt{after}s is in such a way
 from parents to children classes.  Return values of the methods are
 abandoned.

\subsection{\texttt{finally}}
to be written...

\section{Ordinary methods}\label{apd-coremethod-developer}
A developer of Xcrypt modules can add ordinary methods and
extended preexisting ordinary methods defined in \|core.pm|
in the manner of the object oriented Perl programming.
This section lists the ordinary methods defined in \|core.pm|.
Note that the methods that can be called by end users are
already listed in Chapter \ref{chap-coremethod-enduser},
which can be extended by Xcrypt module developers, too.

\subsection{\texttt{apply\_push\_valid\_arg}}
%
\subsection{\texttt{make\_jobscript}}
called by \|qsub_make|.
\subsection{\texttt{make\_jobscript\_header}}
called by \|make_jobscript|
\subsection{\texttt{make\_jobscript\_body}}
called by \|make_jobscript|
%
\subsection{\texttt{make\_in\_jobscript}}
called by \|make_before_in_jobscript| and \|make_after_in_jobscript|
\subsection{\texttt{make\_before\_in\_jobscript}}
called by \|qsub_make|.
\subsection{\texttt{make\_after\_in\_jobscript}}
called by \|qsub_make|.
%
\subsection{\texttt{update\_script\_file}}
called by \|update_jobscript_file|, \|update_before_in_job_file|, and \|update_after_in_job_file|.
\subsection{\texttt{update\_jobscript\_file}}
calls \|update_script_file|
\subsection{\texttt{update\_before\_in\_job\_file}}
calls \|update_script_file|
\subsection{\texttt{update\_after\_in\_job\_file}}
calls \|update_script_file|
\subsection{\texttt{update\_all\_script\_files}}
It calls \|update_jobscript_file|, \|update_before_in_job_file|, and \|update_after_in_job_file|.
%
\subsection{\texttt{make\_qsub\_options}}
called by \|qsub_make|.
%
\subsection{\texttt{qsub\_make}}
called by \|qsub|.
%
\subsection{\texttt{qsub}}
%
\subsection{\texttt{qdel}}
\subsection{\texttt{qdel\_if\_queued\_or\_running}}
conditionally calls \|qdel|.
%

\if0
\paragraph{Remark on Concurrency of \texttt{before\_isready}, \texttt{before}, \texttt{start}, \texttt{after\_isready}, and \texttt{after}.}
Each method is called in concurrently with Xcrypt main thread.
However, it is not necessary that each method is concurrently called
at each job object.  Xcrypt guarantees the following concurrency:
\begin{itemize}
  \item each of
	\texttt{before\_isready}s, \texttt{before}s, \texttt{start}s,
	\texttt{after\_isready}s, and \texttt{after}s
       method is called in concurrent with Xcrypt main thread,
  \item
    at most one method is simultaneously called in
	\texttt{before\_isready}s, \texttt{before}s, and
	\texttt{start}s,
  \item
    at most one method is simultaneously called in
	\texttt{after\_isready}s and \texttt{after}s,
  \item
       just after any \texttt{before\_isready} of a job object returns
	true, the \texttt{before}s of the job object are applied,
	i.e., no method is applied to the *other* job objects,
  \item
       just after \texttt{before}s are applied to a job object,
	\texttt{start}s are applied to the job object, i.e., no method
	is applied to the other job objects,
  \item
       just after any \texttt{after\_isready} of a job object returns
	true, the \texttt{after}s of the job object are applied ,
	i.e., no method is applied to the *other* job objects,
\end{itemize}
\fi

\end{document}
