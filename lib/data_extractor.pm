############################################
# ＜＜出力データ抽出＞＞                   #
# Ver=0.5 2010/02/20                       #
############################################
package data_extractor;
use strict;
use File::Basename;
use Cwd;

###################################################################################################
#   ＜＜ 抽出対象ファイル定義 ＞＞                                                                #
###################################################################################################
sub new {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = クラス名                                                                #
    #         $_[1] = ファイル名 or 変数名                                                    #
    #         $_[2] = ユーザ指定最大バッファ数                                                #
    # 処理 ： 入力データチェック、オブジェクト定義（抽出対象ファイル定義）                    #
    # 返却 ： オブジェクト                                                                    #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $class         = shift;
    # 入力情報
    my @in_data       = ();
    my @in_index      = ();
    # 抽出条件情報
    my @cond_data     = ();
    my $cond_index    = -1;
    my $next_index    = 0;
    # バッファ情報
    my @buff_data     = ();
    my @cond_buf_max  = ();
    my $user_buf_max  = 0;
    # seek情報
    my $seek_kbn      = '';
    my $seek_index    = 0;
    my @seek_num      = ();
    my $get_kbn       = '';
    my $get_index     = 0;
    my @get_num       = ();
    # pipe情報
    my @pipe_data     = ();
    # 出力情報
    my @mid_data      = ();
    my $user_out_kbn  = '';
    my @out_index     = ();
    
    # 入力データチェック
    @in_data = &check_in_data($_[0]);
    # ユーザ指定最大バッファ数チェック
    $user_buf_max = &check_user_buf_max($_[1]);
    
    ####################
    # オブジェクト定義 #
    ####################
    my $job = {
             # 入力情報
               "in_kbn"        =>$in_data[0],                 # 入力区分（ファイルor変数）
               "in_name"       =>$in_data[1],                 # 入力データ名（ファイル名or変数名）
               "in_index"      =>\@in_index,                  # 入力行番号
             # 抽出条件情報
               "cond_data"     =>\@cond_data,                 # 抽出条件
               "cond_index"    =>$cond_index,                 # 抽出位置（抽出条件の配列index）
               "next_index"    =>$next_index,                 # next抽出条件index（抽出条件の配列index）
             # buff情報
               "buff_data"     =>\@buff_data,                 # バッファ情報
               "cond_buf_max"  =>\@cond_buf_max,              # 定型指定最大バッファ数
               "user_buf_max"  =>$user_buf_max,               # ユーザ指定最大バッファ数
             # seek情報
               "seek_kbn"      =>$seek_kbn,                   # seek区分（"buff"＝バッファ情報/"input"＝入力pipe情報/"org"＝オリジナル情報）
               "seek_index"    =>$seek_index,                 # seek位置（バッファ情報の配列index）
               "seek_num"      =>\@seek_num,                  # seek行情報（オリジナル行番号、レコードbyte位置、入力行番号、取得区分（buff/input/org））
               "get_kbn"       =>$get_kbn,                    # get区分（"buff"＝バッファ情報/"input"＝入力pipe情報/"org"＝オリジナル情報）
               "get_index"     =>$get_index,                  # get位置（バッファ情報の配列index）
               "get_num"       =>\@get_num,                   # get行情報（オリジナル行番号、レコードbyte位置、入力行番号、取得区分）
             # pipe情報
               "pipe_data"     =>\@pipe_data,                 # pipe情報（オリジナル行番号、レコードbyte位置、入力行番号、出力区分、抽出対象データ）
             # 出力情報
               "mid_data"      =>\@mid_data,                  # ユーザ先行出力情報
               "user_out_kbn"  =>$user_out_kbn,               # ユーザ出力区分（"output"＝ユーザ出力済/"seek"＝ユーザ出力後のseek）
               "out_index"     =>\@out_index};                # 出力データindex
    bless $job;
    return $job;
}
###################################################################################################
#   ＜＜ 入力データチェック ＞＞                                                                  #
###################################################################################################
sub check_in_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 入力データ情報                                                          #
    # 処理 ： 変数指定    ）変数存在チェック、データ存在チェック                              #
    #         ファイル指定）ファイル存在チェック、読込み権限チェック、データ存在チェック      #
    # 返却 ： チェック後入力データ情報（入力区分、入力データ名）                              #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $in_data  = shift;                                                                     # 入力データ情報
    my @out_data = ();                                                                        # チェック後入力データ情報(入力区分、入力データ名)
    
    # ファイル指定か変数指定かチェック
    if (-e "$in_data") {
        #==============#
        # ファイル指定 #
        #==============#
        $out_data[0] = 'file';
        $out_data[1] = $in_data;
        # ファイルチェック
        if (!-r "$out_data[1]") {
            #----------------#
            # 読込み権限なし #
            #----------------#
            print STDERR "Input file($in_data) is not read authority\n";
            exit 99;
        }
        my @in_file_information = stat $out_data[1];
        if ($in_file_information[7] == 0) {
            #------------#
            # データなし #
            #------------#
            print STDERR "There are not the input data($in_data)\n";
            exit 99;
        }
    } elsif (substr($in_data, 0, 1) eq '$') {
        #==========#
        # 変数指定 #
        #==========#
        # 変数チェック
        my $in_data_name = substr($in_data, 1);
        $out_data[1] = '${user::'."$in_data_name".'}';
        if (! defined eval($out_data[1])) {
            $out_data[1] = '${main::'."$in_data_name".'}';
            if (! defined eval($out_data[1])) {
                #----------#
                # 変数なし #
                #----------#
                print STDERR "Input variable($in_data) not found\n";
                exit 99;
            }
        }
        if (eval($out_data[1]) eq '') {
            #--------------#
            # 変数に値なし #
            #--------------#
            print STDERR "There are not the input data($in_data)\n";
            exit 99;
        }
    } else {
        #==============================#
        # ファイル指定（ファイルなし） #
        #==============================#
        print STDERR "Input file($in_data) not found\n";
        exit 99;
    }
    
    ################################
    # チェック後入力データ情報返却 #
    ################################
    return @out_data;
}
###################################################################################################
#   ＜＜ ユーザ指定最大バッファ数チェック ＞＞                                                    #
###################################################################################################
sub check_user_buf_max {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = ユーザ指定最大バッファ数                                                #
    # 処理 ： 数値チェック                                                                    #
    # 返却 ： チェック後ユーザ指定最大バッファ数                                              #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $user_buf_max = shift;                                                                 # ユーザ指定最大バッファ数
    
    ####################################
    # ユーザ指定最大バッファ数チェック #
    ####################################
    # ユーザ指定最大バッファ数が未指定かチェック
    if ($user_buf_max eq '') {
        #==========#
        # 指定なし #
        #==========#
        return 0;
    # ユーザ指定最大バッファ数が実数指定かチェック
    } elsif ($user_buf_max =~ /^\d+$/) {
        #======#
        # 実数 #
        #======#
        return $user_buf_max;
    } else {
        #========#
        # その他 #
        #========#
        # ユーザ指定最大バッファ数に誤り
        print STDERR "Greatest Seek Buffers Number is an Error($user_buf_max)\n";
        exit 99;
    }
}
###################################################################################################
#   ＜＜ 抽出条件定義 ＞＞                                                                        #
###################################################################################################
sub condition {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = オブジェクト                                                           #
    #         $_[1〜]= 抽出データ指示                                                         #
    # 処理 ： 抽出条件チェック、抽出条件設定、抽出処理に必要な配列の登録                      #
    #-----------------------------------------------------------------------------------------#
    # 抽出データ指示                                                                          #
    #   行抽出                                                                                #
    #     行番号指定  ：[!]L/{行番号|end[-範囲]}                                              #
    #                 ：[!]L/{行番号|end[-範囲]}//列抽出                                      #
    #                 ：[!]L/{行番号|end[-範囲]}/{終了行番号|{+|-}範囲|end[-範囲]}            #
    #                 ：[!]L/{行番号|end[-範囲]}/{終了行番号|{+|-}範囲|end[-範囲]}/列抽出     #
    #     正規表現指定：[!]LR/抽出条件                                                        #
    #                 ：[!]LR/抽出条件//列抽出                                                #
    #                 ：[!]LR/抽出条件/{終了条件|{+|-}範囲}                                   #
    #                 ：[!]LR/抽出条件/{終了条件|{+|-}範囲}/列抽出                            #
    #     ※条件以外の抽出は、先頭に"!"を付与                                                 #
    #     ※最終行の抽出は、"end"を指定                                                       #
    #   列抽出                                                                                #
    #     列番号指定  ：[!]C/{列番号|end[-範囲]}                                              #
    #                 ：[!]C/{列番号|end[-範囲]}/{終了列番号|{+|-}範囲|end[-範囲]}            #
    #     正規表現指定：[!]CR/抽出条件                                                        #
    #                 ：[!]CR/抽出条件/{終了条件|{+|-}範囲}                                   #
    #     ※条件以外の抽出は、先頭に"!"を付与                                                 #
    #     ※最終列の抽出は、"end"を指定                                                       #
    #   ユーザ抽出    ：［"パッケージ名::サブルーチン名"[, "ユーザ引数", ･･･ ]］              #
    #                   ※大外の［］は、配列定義を意味する                                    #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj          = $_[0];                                                                 # オブジェクト
    my $cond_buf_max = -1;                                                                    # 定型指定最大バッファ数(初期値=-1)
    
    ####################
    # 抽出条件チェック #
    ####################
    my @cond_data = &check_extraction_cond(@_);
    
    ##############################
    # 定型指定バッファ数チェック #
    ##############################
    # 定型抽出条件(行番号指定、且つマイナス付き数字の範囲)から定型指定最大バッファ数を確定
    foreach my $cond(grep { (${$_}[0] eq 'L' and  ${$_}[2] =~ /^end-\d+$/)
                         or (${$_}[0] =~ /L/ and (${$_}[3] =~ /^-\d+$/ or ${$_}[3] =~ /^end-\d+$/)) }@cond_data) {
         my $cond2    = 0;
         my $cond3    = 0;
         my $cond_min = 0;
         # 一番小さい値の範囲を「定型指定最大バッファ数」に設定
         if (${$cond}[2] =~ /^end(-\d+)$/) {
             $cond2 = $1;
         }
         if (${$cond}[3] =~ /^end(-\d+)$/) {
             $cond3 = $1;
         }
         if ($cond2 <= $cond3) {
             $cond_min = $cond2;
         } else {
             $cond_min = $cond3;
         }
         if (${$cond}[3] =~ /^-\d+$/) {
             $cond_min += ${$cond}[3];
         }
         if ($cond_buf_max > $cond_min) {
             $cond_buf_max = $cond_min;
         }
    }
    
    ############
    # 配列登録 #
    ############
    push(@{$obj->{cond_data}}, [@cond_data]);                                                 # 抽出条件を抽出条件(配列)へ登録
    push(@{$obj->{cond_buf_max}} , ($cond_buf_max * -1));                                     # 最大バッファ数を実数化して定型指定最大バッファ数(配列)へ登録
    push(@{$obj->{pipe_data}}, []);                                                           # pipe情報(配列)へ枠のみ登録
    push(@{$obj->{buff_data}}, []);                                                           # バッファ情報(配列)へ枠のみ登録
    push(@{$obj->{mid_data}} , []);                                                           # ユーザ先行出力情報(配列)へ枠のみ登録
}
###################################################################################################
#   ＜＜ エイリアス抽出条件定義 ＞＞                                                              #
###################################################################################################
# ＜行抽出＞
sub extract_line {
    &set_condition('nn', 'L', @_);
}
sub extract_line_nn {
    &set_condition('nn', 'L', @_);
}
sub extract_line_nr {
    &not_support_command();
}
sub extract_line_r {
    &set_condition('rn', 'LR', @_);
}
sub extract_line_rn {
    &set_condition('rn', 'LR', @_);
}
sub extract_line_rr {
    &set_condition('rr', 'LR', @_);
}
# ＜列抽出＞
sub extract_column {
    &set_condition('nn', 'C', @_);
}
sub extract_column_nn {
    &set_condition('nn', 'C', @_);
}
sub extract_column_nr {
    &not_support_command();
}
sub extract_column_r {
    &set_condition('rn', 'CR', @_);
}
sub extract_column_rn {
    &set_condition('rn', 'CR', @_);
}
sub extract_column_rr {
    &set_condition('rr', 'CR', @_);
}
# ＜否定行抽出＞
sub remove_line {
    &set_condition('nn', '!L', @_);
}
sub remove_line_nn {
    &set_condition('nn', '!L', @_);
}
sub remove_line_nr {
    &not_support_command();
}
sub remove_line_r {
    &set_condition('rn', '!LR', @_);
}
sub remove_line_rn {
    &set_condition('rn', '!LR', @_);
}
sub remove_line_rr {
    &set_condition('rr', '!LR', @_);
}
# ＜否定列抽出＞
sub remove_column {
    &set_condition('nn', '!C', @_);
}
sub remove_column_nn {
    &set_condition('nn', '!C', @_);
}
sub remove_column_nr {
    &not_support_command();
}
sub remove_column_r {
    &set_condition('rn', '!CR', @_);
}
sub remove_column_rn {
    &set_condition('rn', '!CR', @_);
}
sub remove_column_rr {
    &set_condition('rr', '!CR', @_);
}
sub not_support_command {
    my $this = (caller 1)[3];
    $this =~ s/.*:://;
    print STDERR "not yet support ($this)\n";
    exit 99;
}
sub set_condition {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 指定区分（n、r）                                                       #
    #         $_[1]  = 設定区分（L、LR、C、CR）                                               #
    #         $_[2]  = オブジェクト                                                           #
    #         $_[3〜]= 抽出データ指示[, 抽出データ指示[,･･･]]                                 #
    # 処理 ： 抽出区分の付与、抽出条件定義                                                    #
    #-----------------------------------------------------------------------------------------#
    # 抽出データ指示                                                                          #
    #   nn ：  {行番号|end[-範囲]}                                                            #
    #        [ {行番号|end[-範囲]}[,{終了行番号|{+|-}範囲|end[-範囲]}] ]                      #
    #   rn ：  抽出条件                                                                       #
    #        [ 抽出条件[,{{+|-}範囲|end[-範囲]}] ]                                            #
    #   rr ：  抽出条件                                                                       #
    #        [ 抽出条件[,終了条件] ]                                                          #
    #   ※大外の［］は、配列定義を意味する                                                    #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $in_kbn       = shift;                                                                 # 指定区分
    my $set_kbn      = shift;                                                                 # 設定区分
    my $obj          = shift;                                                                 # オブジェクト
    my @conds        = ();                                                                    # 抽出条件
    
    foreach my $cond(@_) {
        if ($cond =~ /^ARRAY\(.*\)/) {
            if ($in_kbn eq 'rn') {
                if (${$cond}[1] =~ /^\d+$/) {
                    ${$cond}[1] = '+'.${$cond}[1];
                } elsif (${$cond}[1] !~ /^[\+-]\d+$/) {
                    # 抽出範囲誤り
                    print STDERR "End Range Number is an Error (${$cond}[1])\n";
                    exit 99;
                }
            }
            if ($in_kbn eq 'rr' and ${$cond}[1] =~ /^-/) {
                ${$cond}[1] = '\\'.${$cond}[1];
            }
            push(@conds, "$set_kbn/${$cond}[0]/${$cond}[1]");
        } else {
            push(@conds, "$set_kbn/$cond");
        }
    }
    ################
    # 抽出条件定義 #
    ################
    &condition($obj, @conds);
}
###################################################################################################
#   ＜＜ 抽出条件チェック ＞＞                                                                    #
###################################################################################################
sub check_extraction_cond {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = オブジェクト                                                           #
    #         $_[1〜]= 抽出条件                                                               #
    #                  ※詳細は、抽出条件定義の説明を参照                                     #
    # 処理 ： 抽出条件チェック、定型抽出条件の記述チェック                                    #
    # 返却 ： チェック後抽出条件                                                              #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj           = shift;                                                                # オブジェクト
    my @in_cond_data  = @_;                                                                   # 抽出条件
    my @out_cond_data = ();                                                                   # チェック後抽出条件
    my $line_max      = 0;                                                                    # 抽出対象ファイルのレコード数
    # 抽出対象ファイルのレコード数取得
    if ($^O eq 'linux' and $obj->{in_kbn} eq 'file') {
        $line_max     = &get_line_max($obj);
    }
    
    ####################
    # 抽出条件チェック #
    ####################
    # 抽出条件が記述ルールに合っているかチェック
    foreach my $cond(@in_cond_data) {
        # 定型抽出("L/LR/C/CR")かチェック
        if ($cond =~ /^\!{0,1}[CLcl][Rr]*\//) {
            #==========#
            # 定型抽出 #
            #==========#
            # 抽出条件をスラッシュ("/")区切りで分割
            my @in_cond = split /[\/]/, $cond;                                                # 分割後抽出条件
            #**************************************************************************************#
            # ＜分割後抽出条件の詳細＞                                                             #
            # ${$in_cond}[0] ： 抽出種別1(肯定否定区分＋抽出区分)                                  #
            # ${$in_cond}[1] ： 開始条件1(行番号/列番号/end[-範囲]/抽出条件)                       #
            # ${$in_cond}[2] ：[終了条件1(終了行番号/終了列番号/{+|-}範囲/end[-範囲]/終了条件)]    #
            # ${$in_cond}[3] ：[抽出種別2(肯定否定区分＋抽出区分)]                                 #
            # ${$in_cond}[4] ：[開始条件2(列番号/end[-範囲]/抽出条件)]                             #
            # ${$in_cond}[5] ：[終了条件2({+|-}範囲/end[-範囲]/終了条件)]                          #
            #**************************************************************************************#
            my @in_kbn  = ();                                                                 # 抽出処理区分
            #**************************************************************************************#
            # ＜抽出処理区分＞                                                                     #
            # ${$in_kbn}[0] ： 肯定否定区分1(分割後抽出条件の抽出種別1の肯定否定区分)              #
            # ${$in_kbn}[1] ： 抽出区分1(分割後抽出条件の抽出種別1の抽出区分)                      #
            # ${$in_kbn}[2] ： 肯定否定区分2(分割後抽出条件の抽出種別2の肯定否定区分)              #
            # ${$in_kbn}[3] ： 抽出区分2(分割後抽出条件の抽出種別2の抽出区分)                      #
            # ${$in_kbn}[4] ： 暫定開始位置（正規表現、且つ否定抽出条件時に使用）                  #
            #**************************************************************************************#
            
            # 肯定抽出条件か否定抽出条件かチェック
            if ((substr $in_cond[0], 0, 1) ne '!') {
                #------#
                # 肯定 #
                #------#
                $in_kbn[1] = uc(substr $in_cond[0], 0);
            } else {
                #------#
                # 否定 #
                #------#
                $in_kbn[0] = substr $in_cond[0], 0, 1;
                $in_kbn[1] = uc(substr $in_cond[0], 1);
            }
            
            # 定型抽出条件の記述チェック
            if ($in_kbn[1] eq 'L' and $line_max > 0 and $in_cond[1] =~ /^end(-\d+)*$/) {
                my $cond1 = $1;
                $in_cond[1] = $line_max;
                if ($cond1 ne '') {
                    $in_cond[1] += $cond1;
                }
            }
            #if ($in_kbn[1] =~ /L/ and $line_max > 0 and $in_cond[2] =~ /^end(-\d+)*$/) {
            #    my $cond2 = $1;
            #    $in_cond[2] = $line_max;
            #    if ($cond2 ne '') {
            #        $in_cond[2] += $cond2;
            #    }
            #}
            &check_fixed_form_cond($obj, $in_kbn[0], $in_kbn[1], $in_cond[1], $in_cond[2]);
            
            # 正規表現、且つ否定抽出条件時の暫定開始位置を設定
            if ($in_kbn[1] eq 'LR' and $in_kbn[0] ne '') {
                $in_kbn[4] = '0';
            }
            
            # 列抽出指定("C/CR")があるかチェック
            if ($in_cond[3] =~ /^\!{0,1}[Cc][Rr]*$/) {
                # 肯定抽出条件か否定抽出条件かチェック
                if ((substr $in_cond[3], 0, 1) ne '!') {
                    #･･････#
                    # 肯定 #
                    #･･････#
                    $in_kbn[3] = uc(substr $in_cond[3], 0);
                } else {
                    #･･････#
                    # 否定 #
                    #･･････#
                    $in_kbn[2] = substr $in_cond[3], 0, 1;
                    $in_kbn[3] = uc(substr $in_cond[3], 1);
                }
                
                # 定型抽出条件の記述チェック
                &check_fixed_form_cond($obj, $in_kbn[2], $in_kbn[3], $in_cond[4], $in_cond[5]);
                
                # 抽出条件(列抽出)をチェック後抽出条件へ登録
                push(@out_cond_data, ["$in_kbn[1]", "$in_kbn[0]", "$in_cond[1]", "$in_cond[2]", "$in_kbn[3]", "$in_kbn[2]", "$in_cond[4]", "$in_cond[5]", "$in_kbn[4]"]);
            } elsif ($in_cond[3] eq '') {
                #--------#
                # 行抽出 #
                #--------#
                # 抽出条件(行抽出)をチェック後抽出条件へ登録
                push(@out_cond_data, ["$in_kbn[1]", "$in_kbn[0]", "$in_cond[1]", "$in_cond[2]", '', '', '', '', "$in_kbn[4]"]);
            } else {
                #--------#
                # その他 #
                #--------#
                # 抽出区分誤り
                print STDERR "Extraction Division is an Error ($cond)\n";
                exit 99;
            }
        # ユーザ抽出(配列)かチェック
        } elsif ($cond =~ /^ARRAY\(.*\)/) {
            #============#
            # ユーザ抽出 #
            #============#
            # ユーザ関数("パッケージ名::関数名")が指定されているかチェック
            if (${$cond}[0] =~ /^[^\.]+\:\:.+/) {
                #････････････････････#
                # ユーザ関数指定あり #
                #････････････････････#
                # 抽出区分を"USER"(ユーザ抽出)として、抽出条件(ユーザ抽出)をチェック後抽出条件へ登録
                push(@out_cond_data, ['USER', @{$cond}]);
            } else {
                #････････#
                # その他 #
                #････････#
                # 抽出区分誤り
                print STDERR "User Function Name Error (@{$cond})\n";
                exit 99;
            }
        } else {
            #========#
            # その他 #
            #========#
            # 抽出区分誤り
            print STDERR "Extraction Division is an Error ($cond)\n";
            exit 99;
        }
    }
    
    ############################
    # チェック後抽出条件を返却 #
    ############################
    return @out_cond_data;
}
###################################################################################################
#   ＜＜ 抽出対象ファイルのレコード数取得 ＞＞                                                    #
###################################################################################################
sub get_line_max {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = オブジェクト                                                           #
    # 処理 ： 抽出対象ファイルのレコード数を取得                                              #
    # 返却 ： 抽出対象ファイルのレコード数                                                    #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj      = shift;                                                                     # オブジェクト
    my $line_max = 0;                                                                         # レコード数
    
    ##################
    # レコード数取得 #
    ##################
    #my $line_max = `wc --lines $obj->{in_name}`;
    # 改行コード数を取得
    if ( `wc --lines $obj->{in_name}` =~ /^([0-9]+)/) {
        $line_max = $1;
    }
    
    # 最終行に改行コードがあるかチェック
    my $last_line = `tail -n 1 $obj->{in_name}`;
    if ((substr $last_line, -1) ne "\n") {
        $line_max++;
    }
    
    ##################
    # レコード数返却 #
    ##################
    return $line_max;
}
###################################################################################################
#   ＜＜ 定型抽出条件の記述チェック ＞＞                                                          #
###################################################################################################
sub check_fixed_form_cond {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 肯定否定区分                                                            #
    #         $_[2] = 抽出区分                                                                #
    #         $_[3] = 開始条件(行番号/列番号/end[-範囲]/抽出条件)                             #
    #         $_[4] = 終了条件(終了行番号/終了列番号/{+|-}範囲/end[-範囲]/終了条件)           #
    #         ※カッコ内は、抽出条件定義の説明を参照                                          #
    # 処理 ： 定型抽出条件の記述チェック、範囲($_[4])を絶対値に変換                           #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $cond_kbn   = \$_[2];                                                                  # 抽出区分
    my $cond_start = \$_[3];                                                                  # 開始条件
    my $cond_end   = \$_[4];                                                                  # 終了条件
    
    ##############################
    # 定型抽出条件の記述チェック #
    ##############################
    # 指定方法に基いた記述になっているかチェック
    if (${$cond_kbn} !~ /R/) {
        #==========#
        # 番号指定 #
        #==========#
        # ＜開始条件チェック＞
        if (${$cond_start} =~ /^end(-\d+)*$/) {
            #---------------------------#
            # 最終からの実数指定("end") #
            #---------------------------#
            # 処理なし
        } elsif (${$cond_start} =~ /^\d+$/ and ${$cond_start} > 0) {
            #----------#
            # 実数指定 #
            #----------#
            # 処理なし
        } elsif (${$cond_start} !~ /^[\+-]\d+$/ and ${$cond_start} !~ /[a-zA-Z]/ and ${$cond_start} =~ /[\+\-\*\/\%]/) {
            #------------#
            # 計算式指定 #
            #------------#
            my $cond_eval_out = undef;
            my $cond_eval     = '$cond_eval_out = '."${$cond_start}";
            ${$cond_start}    = $cond_eval_out;
        } else {
            #--------#
            # その他 #
            #--------#
            # 開始番号誤り
            print STDERR "Starting Point Number is an Error (${$cond_start})\n";
            exit 99;
        }
        
        # ＜終了条件チェック＞
        if (${$cond_end} =~ /^end(-\d+)*$/) {
            #---------------------------#
            # 最終からの実数指定("end") #
            #---------------------------#
            # 処理なし
       #} elsif (${$cond_end} =~ /^\d+$/ and ${$cond_end} > 0) {
        } elsif (${$cond_end} =~ /^\d+$/) {
            #----------#
            # 実数指定 #
            #----------#
            if (${$cond_end} == 0) {
                # 開始を終了に設定
                ${$cond_end} = ${$cond_start};
            }
            # 開始条件よりも終了条件が小さい場合、条件を入替える
            if (${$cond_start} =~ /end/ or ${$cond_start} > ${$cond_end}) {
                my $temp_su    = ${$cond_start};
                ${$cond_start} = ${$cond_end};
                ${$cond_end}   = $temp_su;
            }
       #} elsif (${$cond_end} =~ /^\+\d+$/ and ${$cond_end} != 0) {
        } elsif (${$cond_end} =~ /^\+\d+$/) {
            #------------------------------#
            # 後続範囲指定(プラス付き数字) #
            #------------------------------#
            # 開始が"end"以外の場合、終了を絶対値に変換
            if (${$cond_start} !~ /end/) {
                ${$cond_end} += ${$cond_start};
            }
       #} elsif (${$cond_end} =~ /^-\d+$/ and ${$cond_end} != 0) {
        } elsif (${$cond_end} =~ /^-\d+$/) {
            #--------------------------------#
            # 先行範囲指定(マイナス付き数字) #
            #--------------------------------#
            # 開始が"E"以外の場合、値を絶対値に変換し、開始と終了を入替え
            if (${$cond_start} !~ /end/) {
                my $temp_su     = ${$cond_start};
                ${$cond_start} += ${$cond_end};
                ${$cond_end}    = $temp_su;
            }
        } elsif (${$cond_end} !~ /[a-zA-Z]/ and ${$cond_end} =~ /[\+\-\*\/\%]/) {
            #------------#
            # 計算式指定 #
            #------------#
            my $cond_eval_out = undef;
            my $cond_eval     = '$cond_eval_out = '."${$cond_end}";
            ${$cond_end}      = $cond_eval_out;
        } elsif (${$cond_end} eq '') {
            #----------#
            # 指定なし #
            #----------#
            # 開始を終了に設定
            ${$cond_end} = ${$cond_start};
        } else {
            #--------#
            # その他 #
            #--------#
            # 抽出範囲誤り
            print STDERR "End Range Number is an Error (${$cond_end})\n";
            exit 99;
        }
    } else {
        #==============#
        # 正規表現指定 #
        #==============#
        # ＜開始条件チェック＞
        if (${$cond_start} eq '') {
            # 起点正規表指定現無し
            print STDERR "Regular Expression Character string is not Found\n";
            exit 99;
        }
        
        # ＜終了条件チェック＞
       #if ($_[4] =~ /^[\+-]\d+/ and ($_[4] !~ /^[\+-]\d+$/ or $_[4] == 0))  {
        if ($_[4] =~ /^[\+-]\d+/ and $_[4] !~ /^[\+-]\d+$/)  {
            # 抽出範囲誤り
            print STDERR "End Range Number is an Error ($_[4])\n";
            exit 99;
        }
    }
}
###################################################################################################
#   ＜＜ 抽出実行 前処理＞＞                                                                      #
###################################################################################################
sub execute {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 通常版抽出と簡易版抽出の分岐処理とそれぞれ抽出処理から抽出結果を受け取る        #
    # 返却 ： 抽出結果                                                                        #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj = shift;       # オブジェクト

    # ＜条件なし＞
    if ($#{$obj->{cond_data}} < 0) {
        # 抽出条件なし
        return ();
    }
    
    #=======================#
    # #簡易版か通常版か分岐 #
    #=======================#
    # ＜簡易版その1 バッファの使用なし(-範囲とend範囲なし)＞
    if(&conditinal_branch1($obj)){
        return &execute_easy($obj);
    }
    # ＜簡易版その2 condition1つ、行番号抽出のend[-数字]範囲指定あり＞
    elsif(&conditinal_branch2($obj)){
        return &execute_easy_line_end($obj);
    }
    # ＜通常版＞
    else{
        return &execute_org($obj);
    }
}
###################################################################################################
#   ＜＜ 簡易版抽出(バッファの使用なし)を実行する条件か判別＞＞                                   #
###################################################################################################
sub conditinal_branch1{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 簡易版抽出その１の実行をする条件か判別                                          #
    # 返却 ： 判別結果 1:実行可能 0:実行不可能                                                #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj = shift;       # オブジェクト

    # 入力区分がファイル
    if($obj->{in_kbn} eq 'file'){
        # ブロック抽出の有無
        if(!&exist_block_extract($obj->{cond_data})){
             # ユーザ関数の使用の有無
             if(!&exist_userfunction($obj->{cond_data})){
                  # マイナス範囲指定の有無
                  if(!&exist_minus($obj->{cond_data})){
                      # 正規表現行抽出のend[-数字]指定があるかどうか
                      if(!&exist_LR_end($obj->{cond_data})){
                           # 行番号抽出のend[-数字]指定があるかどうか
                           if(!&exist_line_end($obj->{cond_data})){
                               return 1;
                           }
                      }
                  }
             }
        }
    }
    return 0;
}
###################################################################################################
#   ＜＜ 簡易版抽出(condition１つ、行番号抽出のend[-数字]指定あり)を実行する条件か判別＞＞        #
###################################################################################################
sub conditinal_branch2{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 簡易版抽出その2の実行をする条件か判別                                           #
    # 返却 ： 判別結果 1:実行可能 0:実行不可能                                                #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj = shift;       # オブジェクト
    
    # 入力区分がファイルかどうか
    if($obj->{in_kbn} ne 'file'){
         return 0;
    }
    # ブロック抽出の有無
    if(&exist_block_extract($obj->{cond_data})){
        return 0;
    }
    # マイナス範囲指定があるかどうか
    if(&exist_minus($obj->{cond_data})){
        return 0;
    }
    # conditionが単数かどうか
    if(!&exist_multi_condition($obj->{cond_data})){
         # 行番号抽出であり、且つend[-数字]範囲指定があるかどうか
         if(&exist_line_end($obj->{cond_data})){
             return 1
         }
    }
    return 0;
}
###################################################################################################
#   ＜＜ 複数条件の存在判別＞＞                                                                   #
###################################################################################################
sub exist_multi_condition{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 抽出条件配列への参照                                                    #
    # 処理 ： 抽出条件が複数個あるか判別する                                                  #
    # 返却 ： 判別結果 1:ある 0:なし                                                          #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $cond_data = shift;  # 抽出条件配列への参照
    my $exist = 0;          # 判別結果 1:あり 0:なし
    
    if($#{$cond_data} > 0){
        $exist = 1;
        return $exist;
    }
    foreach my $cond(@{$cond_data}){
        if($#{$cond} != 0){
            $exist = 1;
            return $exist;
        }
    }
}
###################################################################################################
#   ＜＜ マイナス範囲指定の存在判別＞＞                                                           #
###################################################################################################
sub exist_minus {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 抽出条件配列への参照                                                    #
    # 処理 ： 抽出条件の中に-範囲指定があるか判別する                                         #
    # 返却 ： 判別結果 1:ある 0:なし                                                          #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $cond_data = shift;      # 抽出条件配列への参照
    my $exist = 0;              # 判別結果 1:あり 0:なし
    foreach(@{$cond_data}){
        foreach(@{$_}){
            # 抽出条件の3番目に[-数字]指定がないかチェック
            if(${$_}[3] =~ /^[\-]\d+$/){
                $exist = 1;
                return $exist;
            }
        }
    }
    return $exist;
}
###################################################################################################
#   ＜＜ 行版番号抽出のend[-数字]範囲指定の存在判別＞＞                                           #
###################################################################################################
sub exist_line_end {
    #------------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 抽出条件配列への参照                                                     #
    # 処理 ： 抽出条件が行番号抽出であり且つ、抽出条件の中にend[-数字]範囲指定があるか判別する #
    # 返却 ： 判別結果 1:ある 0:なし                                                           #
    #------------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $cond_data = shift;      # 抽出条件配列への参照
    my $exist = 0;              # 判別結果 1:あり 0:なし
    foreach(@{$cond_data}){
        foreach(@{$_}){
            # 抽出条件の2,3番目にend[-数字]指定がないかチェック
            if(${$_}[0] eq "L" && (${$_}[2] =~ /^end[\-]*[\d+]*$/ or ${$_}[3] =~ /^end[\-]*[\d+]*$/)){
                $exist = 1;
                return $exist;
            }
        }
    }
    return $exist;
}
###################################################################################################
#   ＜＜ 正規表現行抽出のend[-数字]範囲指定の存在判別＞＞                                         #
###################################################################################################
sub exist_LR_end{
    #----------------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 抽出条件配列への参照                                                         #
    # 処理 ： 抽出条件が正規表現行抽出であり且つ、抽出条件の中にend[-数字]範囲指定があるか判別する #
    # 返却 ： 判別結果 1:ある 0:なし                                                               #
    #----------------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $cond_data = shift;      # 抽出条件配列への参照
    my $exist = 0;              # 判別結果 1:あり 0:なし
    foreach(@{$cond_data}){
        foreach(@{$_}){
            # 抽出条件の3番目にend[-数字]指定がないかチェック
            if(${$_}[0] eq "LR" && ${$_}[3] =~ /^end[\-]*[\d+]*$/){
                $exist = 1;
                return $exist;
            }
        }
    }
    return $exist;
}
###################################################################################################
#   ＜＜ ブロック抽出があるか判別＞＞                                                             #
###################################################################################################
sub exist_block_extract{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 抽出条件配列への参照照                                                  #
    # 処理 ： 抽出条件の4番目に値が入力されているか確認しブロック抽出かどうか判別する         #
    # 返却 ： 判別結果 1: あり 0:なし                                                         #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $cond_data = shift;      # 抽出条件配列への参照
    my $exist = 0;              # 判別結果 1:あり 0:なし

    foreach(@{$cond_data}){
        foreach(@{$_}){
            if(${$_}[4] ne ''){
                $exist = 1;
                return $exist;
            }
        }
    }
    return $exist;
}
###################################################################################################
#   ＜＜ ユーザ関数の使用があるか判別＞＞                                                         #
###################################################################################################
sub exist_userfunction{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 抽出条件配列への参照照                                                  #
    # 処理 ： 抽出条件にユーザ関数があるか判別する                                            #
    # 返却 ： 判別結果 1: あり 0:なし                                                         #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $cond_data = shift;      # 抽出条件配列への参照
    my $exist = 0;              # 判別結果 1:あり 0:なし

    foreach(@{$cond_data}){
        foreach(@{$_}){
            # 抽出条件の0番目が[USER]指定か判別
            if(${$_}[0] eq "USER"){
                $exist = 1;
                return $exist;
            }
        }
    }
}
###################################################################################################
#   ＜＜ ファイルの終わりから目的の行までファイルハンドルを移動する＞＞                           #
###################################################################################################
sub move_FH_end_to_dest{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = ファイルの最後から数えた目的の行数                                      #
    # 処理 ： ファイルの最後から目的の行数までファイルハンドルを移動する                      #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $dest_line = shift;                  # ファイルの最後から数えた目的の行数
    my $char = "";                          # 現在のファイルポインタの文字
    my $pos_start = tell(EXTRACTION_FILE);  # ファイルハンドルの先頭を記憶
    my $line_count = 0;                     # ファイルの終わりからの行数
    my $read_first = 1;                     # ファイルの読み始めフラグ。ファイルの最後に改行文字があった場合の対処用
    
    for(my $i = 0; $line_count < $dest_line + 1; $i--){
        # ファイルの終わりから$iバイト分ファイルの最初に向かって移動する
        # 第1引数：ファイルハンドル
        # 第2引数：バイト数。デクリメントする事でマイナスバイト数分ファイルの最後から移動する
        # 第3引数：2はファイルの最後を指す(0は最初を指す、1は現在地を指す)
        seek(EXTRACTION_FILE, $i, 2);
        # ファイルの終わりだったらもう1度ループ
        if(eof(EXTRACTION_FILE)){
            next;
        }
        # ファイルの始めまで来たらループを抜ける
        if($pos_start == tell(EXTRACTION_FILE)){
            # ファイルの先頭を越えるようならエラーを出す
            if($dest_line >= $line_count+1){
                my $error_num = ($dest_line - ($line_count+1)) * -1;
                print STDERR "Starting Point Number is an Error ($error_num)\n";
                exit 99
            }
            last;
        }
        # 1バイトずつずらしながら改行文字を探す
        $char = getc(EXTRACTION_FILE);
        if($char =~ /^[\r\n]$/ && $read_first != 1){
            # 改行文字があればファイルの最後からの行数を更新する
            $line_count++;
        }
        $read_first = 0;
    }
}
###################################################################################################
#   ＜＜  抽出実行 簡易版その１ バッファの使用なし＞＞                                            #
###################################################################################################
sub execute_easy{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 行データ取得、EDコマンド抽出実行                                                #
    # 返却 ： 抽出結果                                                                        #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj = shift;        # オブジェクト
    my @result = ();        # 抽出結果

    ################
    # ファイルOPEN #
    ################
    if ($obj->{in_kbn} eq 'file') {
        # ファイル指定
        &in_file_open($obj->{in_name});
    }
    
    ############
    # 抽出実行 #
    ############
    my $line_count = 0;         # ファイルの何行目か
    my @ext_line_count = ();    # 条件による抽出後の行数
    #######################################################
    # ファイルハンドルをループさせ1行のデータ毎に処理する #
    #######################################################
    while(<EXTRACTION_FILE>){
        $line_count++;                                           # 現在の行数を更新
        my $line = $_;                                           # 元の1行のデータ
        $line =~ s/^\s*(.*?)\s*$/$1/;                            # 前後の空白を取り除く 
        my @line_data = ($line , $line_count, $line_count, '');  # (行データ、実際の行数、抽出時の行数, 列抽出後のデータ)
        my $push_flag = '';                                      # 結果配列に追加するかのフラグ 1:抽出する -1:抽出しない
        $obj->{cond_index} = 0;                                  # 抽出条件のインデックス
        my $befo_push_flag = '';                                 # 以前の条件で抽出フラグがたったか記憶
        my $colum_flag = 0;                                      # 列抽出のあり、なし 1:あり -1なし
        foreach my $cond_group(@{$obj->{cond_data}}){
            # 抽出しなければ次の条件へ
            if($push_flag < 0){
                next;
            }
            # 前の条件での抽出フラグを確認
            if($obj->{cond_index} == 1){
                $befo_push_flag = $push_flag;
                $push_flag = 0;
            }
            # 必須の抽出条件を絞る
            # 行番号抽出で抽出範囲を過ぎたものを削除する
            @{$cond_group} = (grep{((${$_}[0] eq 'L' and (${$_}[1] eq '' and $line_data[2] <= ${$_}[3])
                                    or (${$_}[1] ne ''))
                              or (${$_}[0] eq 'r' )
                              or (${$_}[0] eq 'LR' )
                              or (${$_}[0] eq 'C' )
                              or (${$_}[0] eq 'CR' ))}@{$cond_group});
            
            # 必要な条件がひとつもない場合
            if($#{$cond_group} < 0){
                $push_flag = -1;
                # 次のループへ
                next;
            }
            my $cond_count = 0;                 # 抽出条件番号
            $colum_flag = 0;                    # 列抽出をおこなったかどうか
            my $before_extraction_data = '';    # 正規表現列抽出の前の結果
            foreach my $cond_single(@{$cond_group}){
                #################
                # 行番号抽出    #
                #################
                if(${$cond_single}[0] eq "L"){
                    # 条件範囲内
                    if((${$cond_single}[1] eq '' && ${$cond_single}[2] <= $line_data[2] && $line_data[2] <= ${$cond_single}[3])
                     || (${$cond_single}[1] eq '!' && ((${$cond_single}[2] != ${$cond_single}[3] && ($line_data[2] < ${$cond_single}[2] || ${$cond_single}[3] <  $line_data[2])) ||(${$cond_single}[2] == ${$cond_single}[3] && $line_data[2] != ${$cond_single}[2])))){
                        # 肯定条件時は無条件で抽出フラグを立てる
                        # 否定条件の時は抽出フラグがまだ立っていない時に抽出フラグを立てる
                        if(${$cond_single}[1] eq '' || (${$cond_single}[1] eq '!' && $push_flag != 1) || $colum_flag == 1){
                            # 抽出フラグを立てる
                            $push_flag = 1;
                            # 行優先
                            if($colum_flag == 1){
                                $colum_flag = -1;
                            }
                        }
                    }
                    # 条件範囲外  
                    else{
                        # 肯定条件の時は1つ目の条件の時に抽出フラグを折る
                        # 否定条件の時は無条件で抽出フラグを折る
                        if((${$cond_single}[1] eq '' && $befo_push_flag == 1 && ($#{$cond_group} == 0 || $cond_count == 0))
                         || (${$cond_single}[1] eq '!' && ($push_flag != 1))){
                            $push_flag = -1;
                        }
                    }
                }
                ##################
                # 正規表現行抽出 #
                ##################                
                elsif(${$cond_single}[0] eq "LR"){
                    # 抽出開始行の設定
                    # 最初の抽出条件の場合ファイルのそのままの行数を使用する
                    # 途中の抽出条件の場合抽出後の行数を使用する
                    my $start_line = $obj->{cond_index} ==  0 ? $line_count : $ext_line_count[$obj->{cond_index}-1];
                    # 正規表現のマッチング
                    if($line_data[0] =~ /${$cond_single}[2]/){
                        # 肯定条件
                        # 正規表現でマッチしたら新たに行番号抽出条件を追加する
                        if(${$cond_single}[1] ne '!'){
                            # +範囲指定ありの抽出条件を追加
                            if(${$cond_single}[3] =~ /^[\+]+(\d+)$/){
                                push(@{$cond_group}, ["L", '', $start_line, $start_line + $1, '', '', '', '', '']);
                            }
                            # +範囲指定なしの抽出条件を追加
                            elsif(${$cond_single}[3] eq ''){
                                push(@{$cond_group}, ["L", '', $start_line, $start_line, '', '', '', '', '']);
                            }
                            # 終了範囲が正規表現
                            else{
                                push(@{$cond_group}, ["r", '', $start_line, ${$cond_single}[3], '', '', '', '', '']);
                            }  
                        } 
                        # 否定条件
                        # 抽出条件の9番目に抽出開始する行を設定する。
                        # 抽出条件の8番目に未抽出を表す空文字列を入れる
                        else{
                            # +範囲指定あり
                            if(${$cond_single}[3] =~ /^[\+]+(\d+)$/){
                                ${$cond_single}[9] = $start_line + $1 + 1;
                            }
                            # +範囲指定なし
                            elsif(${$cond_single}[3]  eq ''){
                                ${$cond_single}[9] = $start_line + 1;
                            }
                            # 終了範囲が正規表現
                            else{
                            }
                            # 抽出条件の8番目を空にすることで抽出外を表す
                            ${$cond_single}[8] = '';
                        }                                               
                    }
                    # マッチしない
                    else{
                        # 肯定条件
                        # 抽出しない
                        if(${$cond_single}[1] ne '!'){
                            if($push_flag != 1){
                                $push_flag = -1;
                            }
                        }
                        # 否定条件
                        # 抽出条件の9番目に記憶しておいた抽出開始行ならば抽出フラグを立てる
                        else{
                            # 前の行では抽出外だった場合
                            if(${$cond_single}[8] eq ''){
                                # 終了行が範囲指定
                                if(${$cond_single}[3] eq '' or ${$cond_single}[3] =~ /^[\+-]\d+$/){
                                    # 暫定否定抽出開始行がカレント行以前を指す場合、出力対象("1")を否定抽出区分に設定
                                    if (${$cond_single}[9] eq '' or (${$cond_single}[9] =~ /^[0-9]+$/ and ${$cond_single}[9] <= $start_line)) {
                                        ${$cond_single}[8] = '1';
                                    }
                                }
                                # 終了行が正規表現
                                elsif ($line_data[0] =~ /${$cond_single}[3]/) {
                                     # 条件検出("0")を否定抽出区分へ設定
                                     ${$cond_single}[8] = '0';
                                     # 次行の行番号を暫定否定抽出開始行へ設定
                                     ${$cond_single}[9] = ($start_line + 1);
                                }
                            }
                            # 初回
                            elsif(${$cond_single}[8] eq '0'){
                                ${$cond_single}[8] = '1';
                                ${$cond_single}[9] = $start_line;
                            }
                            # 抽出フラグ設定
                            if(${$cond_single}[8] eq '1' || $colum_flag == 1){
                                # 抽出フラグを立てる
                                $push_flag = 1;
                                # 行優先
                                if($colum_flag == 1){
                                    $colum_flag = -1;
                                }
                            }
                        }
                    }
                }
                ##################
                #   列番号抽出   #
                ##################                 
                elsif(${$cond_single}[0] eq "C"){
                    # 行抽出のフラグが立っていたらスルー(行優先)
                    if($push_flag != 1 || ($push_flag == 1 && $colum_flag == 1)){
                        my $start_col = ${$cond_single}[2];                           # 開始列
                        my $end_col = ${$cond_single}[3];                             # 終了列
                        my @in_line_col = split(/\s+\,*\s*|\,+\s*/, $line_data[0]);   # 区切り文字で分割した配列
                        my $col_sum = $#in_line_col + 1;                              # 列総数
                        my $extraction_data = ('0' x $col_sum);                       # 列抽出位置を表すビット
                        
                        # ＜開始列の数値化＞
                        # 開始列のend[-数字]の数字を抜き出す
                        if($start_col =~ /^end[\-]*(\d+)*$/){
                            $start_col = $col_sum - $1;
                        }
                        # ＜終了列の数値化＞
                        # 終了列のend[-数字]の数字を抜き出す
                        if($end_col =~ /^end[\-]*(\d+)*$/){
                            $end_col = $col_sum - $1;
                        }
                        # 終了列の+範囲を数字に直す
                        elsif($end_col =~ /^[\+](\d+)$/){
                            $end_col = $start_col + $1;
                        }
                        # 終了列の-範囲を数字に直す
                        elsif($end_col =~ /^[\-](\d+)$/){
                            $end_col = $start_col - $1;
                        }
                        # 開始列、終了列の大小関係の整理
                        if($start_col - $end_col > 0){
                            my $tmp = $start_col;
                            $start_col = $end_col;
                            $end_col = $tmp;
                        }
                        # 抽出範囲なら抽出位置をビットで記憶する
                        for(my $index = 1; $index <= $col_sum; $index++){
                            if((${$cond_single}[1] ne '!' && $start_col <= $index && $index <= $end_col)
                             || (${$cond_single}[1] eq '!' && ($index < $start_col || $end_col < $index))){
                                substr($extraction_data, $index, 1) = '1';
                            }
                        }
                        # 列抽出結果を取得
                        if($extraction_data > 0){
                            # 以前の列抽出位置のビットとのorを取得する
                            $extraction_data = "$before_extraction_data" | "$extraction_data";
                            # 抽出列をビットの位置で取得する
                            $line_data[3] = &get_out_line($line_data[0], \@in_line_col, $extraction_data);
                            if($push_flag != 1){
                                # 抽出範囲であれば抽出フラグをたてる
                                $push_flag = 1;
                                # カラムの抽出を行った
                                $colum_flag = 1;
                            }
                            # 列抽出データを記憶、次回の条件で使用
                            $before_extraction_data = $extraction_data;                            
                         }
                     }
                }
                ######################
                #   正規表現列抽出   #
                ######################               
                elsif(${$cond_single}[0] eq "CR"){
                    # 行抽出のフラグが立っていたらスルー(行優先)
                    if($push_flag != 1 || ($push_flag == 1 && $colum_flag == 1)){
                        my @in_line_col = split(/\s+\,*\s*|\,+\s*/, $line_data[0]);   # 区切り文字で分割した配列
                        my $col_sum = $#in_line_col + 1;                              # 列総数
                        # 抽出列をビットの位置で取得する
                        my $extraction_data = "$before_extraction_data" | &get_cond_cr($line_data[0], $col_sum, $cond_single);
                        # 抽出列のビットデータから抽出すべき列を取得する
                        if($extraction_data > 0){
                            # 抽出した列を記憶
                            $line_data[3] = &get_out_line($line_data[0], \@in_line_col, $extraction_data);
                            # 既に列抽出を行っているか確認
                            if($push_flag != 1){
                                # 抽出範囲であれば抽出フラグをたてる
                                $push_flag = 1;
                                # カラムの抽出を行った
                                $colum_flag = 1;                            
                            }
                            # 列抽出データのビット位置を記憶、次回の条件で使用
                            $before_extraction_data = $extraction_data;
                        }    
                    }
                }
                ##########################################
                # 正規表現の行抽出の終了範囲が正規表現   #
                ##########################################
                elsif(${$cond_single}[0] eq "r"){
                    # 抽出開始行の設定
                    # 最初の抽出条件の場合ファイルのそのままの行数を使用する
                    # 途中の抽出条件の場合抽出後の行数を使用する
                    my $start_line = $obj->{cond_index} ==  0 ? $line_count : $ext_line_count[$obj->{cond_index}-1];                
                    # 抽出範囲内
                    if((${$cond_single}[1] eq '' && ${$cond_single}[2] <= $line_data[2]) 
                     || (${$cond_single}[1] eq '!' && !(${$cond_single}[2] <= $line_data[2]))){
                        # 肯定条件時は無条件で抽出フラグを立てる
                        # 否定条件の時は抽出フラグがまだ立っていない時に抽出フラグを立てる
                        if(${$cond_single}[1] eq '' || (${$cond_single}[1] eq '!' && $push_flag != 1)){
                            # 抽出範囲であれば抽出フラグを立てる
                            $push_flag = 1;
                            # 行優先
                            if($colum_flag == 1){
                                $colum_flag = -1;
                            }
                        }                        
                    }
                    # 抽出範囲外
                    else{
                        # 抽出フラグが１でも1つでも条件に合わなければ抽出フラグを折る
                        # 正規表現による条件の追加時はフラグを折らない
                        if($push_flag == 1 && $#{$cond_group} == 0){
                            $push_flag = -1;
                        }
                    }
                    # 抽出終了範囲か判定
                    if(${$cond_single}[9] eq '' || (${$cond_single}[9] =~ /^[0-9]+$/ and ${$cond_single}[9] <= $start_line)){
                        if($line_data[0] =~ /${$cond_single}[3]/){
                            # 抽出条件の終了行を確定させる。肯定条件だった場合は次ループのcond_groupのgrepで削除される
                            ${$cond_single}[0] = 'L';
                            ${$cond_single}[3] = $line_data[2];
                        }
                    }
                }
                # 指定外の抽出種類
                else{
                     print STDERR "not yet support (${$cond_single}[0])\n";
                     exit 99;
                }
                # 抽出条件番号を更新
                $cond_count++;
            }
            # 列抽出フラグの確認
            if($colum_flag == 1){
                # 元の行データを列抽出したデータに置き換える
                $line_data[0] = $line_data[3];
                $line_data[3] = '';
            }
            # 抽出条件クリア後の行数を記憶
            if($push_flag == 1){
                $ext_line_count[$obj->{cond_index}]++;
                $line_data[2] = $ext_line_count[$obj->{cond_index}];                
            }
            if($push_flag != 1){
                $push_flag = -1;
            }
            # 抽出条件インデックスを更新
            $obj->{cond_index}++;
        }
        ############
        # 抽出する #
        ############
        if($push_flag == 1){
            my $ext_line;
            # 行優先
            if($line_data[3] ne '' && $colum_flag == 1){
                $ext_line = $line_data[3];
            }else{
                $ext_line = $line_data[0];
            }
            # 前後の空白を削除
            $ext_line =~ s/^\s*(.*?)\s*$/$1/;
            push(@result, $ext_line);
        }
        # 不要な条件があればループを抜ける
        my @rest_cond = grep{ $#{$_} < 0}@{$obj->{cond_data}};
        if($#rest_cond >=0){
            last;
        }
    }

    #################
    # ファイルCLOSE #
    #################
    if ($obj->{in_kbn} eq 'file') {
        # ファイル指定
        &in_file_close($obj->{in_name});
    }
    ################
    # 抽出結果返却 #
    ################
    return @result;
}
###################################################################################################
#   ＜＜  抽出実行簡易版 conditionが単数のとき行番号end行抽出＞＞                                 #
###################################################################################################
sub execute_easy_line_end {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 行データ取得、EDコマンド抽出実行                                                #
    # 返却 ： 抽出結果                                                                        #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj = shift;                            # オブジェクト
    my $cond_data = ${$obj->{cond_data}[0]}[0]; # 抽出条件 
    my $ex_kind = ${$cond_data}[0];             # 抽出種類
    my @result = ();

    ################
    # ファイルOPEN #
    ################
    if ($obj->{in_kbn} eq 'file') {
        # ファイル指定
        &in_file_open($obj->{in_name});
    }
    
    ############
    # 変数定義 #
    ############
    my $denial     = ${$cond_data}[1];   # 肯定、否定
    my $start_line = ${$cond_data}[2];   # 抽出開始行
    my $end_line   = ${$cond_data}[3];   # 抽出終了行
    my @result     = ();                 # 抽出結果
    
    my $end_range = 0;                   # endの範囲(end-1だったら1)
    my $line_range = 0;                  # 後続行数の範囲(+3だったら3)
    my $end_of_end = 0;                  # condition("/L/end-1/end")の後ろのendの数字

    ############
    # 抽出実行 #
    ############
    # 抽出開始行の範囲指定がendの場合
    if($start_line =~ /^end[\-]*(\d+)*$/){
        # 開始行のend範囲を確定
        if($1 ne ""){
            $end_range = $1;
        }
        # 終了行が+範囲指定
        my $line_count = 0;
        if($end_line =~ /^[\+](\d+)$/){
            $line_range = $1;   # 目的の行数
        }
        # 終了行がend範囲指定
        elsif($end_line =~ /^end[\-]*(\d+)*$/){
            # end[-数字]の数字を取得。endだけの場合は0
            if($1 ne ""){
                $end_of_end = $1;
            }
            # 抽出行の範囲を取得
            $line_range = $end_range - $end_of_end;
            # 開始行と終了行の大小関係の調整
            if($end_range - $end_of_end < 0){
                $line_range *= -1;
                my $temp = $end_of_end;
                $end_range = $temp;
            } 
        }
        # ファイルポインタの先頭を記憶
        my $pos_start = tell(EXTRACTION_FILE);
        # 最終行から目的の行数までファイルハンドルを移動する
        &move_FH_end_to_dest($end_range);        
        # 肯定条件
        if($denial ne '!'){
            $line_count = 0;
            while(<EXTRACTION_FILE>){
                my $line = $_;
                $line =~ s/^\s*(.*?)\s*$/$1/;
                push(@result, $line);
                $line_count++;
                if($line_count > $line_range){
                    last;
                }
            }
        }
        # 否定条件
        else{
            # 目的行のファイルハンドルを記憶
            my $pos = tell(EXTRACTION_FILE);
            # end[-数字]で先頭まで戻った場合は例外
            if($pos == $pos_start){
                while(<EXTRACTION_FILE>){
                    if($. > $line_range + 1){
                        my $line = $_;
                        $line =~ s/^\s*(.*?)\s*$/$1/;
                        push(@result, $line);
                    }
                }
            }
            else{
                # ファイルハンドルを先頭に戻す
                seek(EXTRACTION_FILE, 0, 0);
                while(<EXTRACTION_FILE>){
                    # 目的の行に来たら
                    if($pos == tell(EXTRACTION_FILE)){
                        # その行を追加
                        my $line = $_;
                        $line =~ s/^\s*(.*?)\s*$/$1/;
                        push(@result, $line);
                        # +範囲文の行を空回し
                        my $count = 0;
                        while(<EXTRACTION_FILE>){
                            $count++;
                            if($count > $line_range){
                                last;
                            }
                        }
                    }
                    # 範囲外を追加
                    else{
                        my $line = $_;
                        $line =~ s/^\s*(.*?)\s*$/$1/;
                        push(@result, $line);
                    }
                }
            }
        }
    }
    # 抽出終了行の範囲指定がendの場合、condition("/L/3/end-1")などの指定
    elsif($end_line =~ /^end[\-]*(\d+)*$/){
        # end範囲を確定
        if($1 ne ""){
            $end_range = $1;    # 目的行数
        }
        # ファイルハンドルの先頭を記憶
        my $pos_start = tell(EXTRACTION_FILE);
        # 最終行から目的の行数までファイルハンドルを移動する
        &move_FH_end_to_dest($end_range -1);
        # 目的行数のファイルポインタを記憶
        my $pos_end = tell(EXTRACTION_FILE);
        # 先頭にファイルポインタを戻す
        seek(EXTRACTION_FILE, 0, 0);
        # 抽出フラグの初期値は肯定条件か否定条件かで決まる
        my $push_flag = $denial eq '' ? 0 : 1;
        while(<EXTRACTION_FILE>){
            # 開始行もしくは終了行になった
            if($. == $start_line || $pos_end == tell(EXTRACTION_FILE)){
                # 抽出してなければ抽出中フラグを立てる
                if($push_flag == 0){
                    $push_flag = 1;
                    # 否定条件なら次の行へ
                    if($denial eq '!'){
                        next;
                    }
                }
                # 抽出中ならこの行で抽出終了
                elsif($push_flag == 1){
                    $push_flag = 0;
                    # 肯定条件の場合この行を抽出する
                    if($denial eq ''){
                        my $line = $_;
                        $line =~ s/^\s*(.*?)\s*$/$1/;
                        push(@result, $line);
                    }
                }
            }
            # 抽出フラグ
            if($push_flag == 1){
                my $line = $_;
                $line =~ s/^\s*(.*?)\s*$/$1/;
                push(@result, $line);
            }
        }
    }
    
    #################
    # ファイルCLOSE #
    #################
    if ($obj->{in_kbn} eq 'file') {
        # ファイル指定
        &in_file_close($obj->{in_name});
    }
    
    ################
    # 抽出結果返却 #
    ################
    return @result;
}
###################################################################################################
#   ＜＜ 抽出実行 通常版＞＞                                                                      #
###################################################################################################
sub execute_org {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 行データ取得、EDコマンド抽出実行                                                #
    # 返却 ： 抽出結果                                                                        #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj       = shift;                                                                    # オブジェクト
    my $seek_byte = 0;                                                                        # レコードbyte位置
    my $index_org = 0;                                                                        # オリジナル行番号
    my @index_now = ();                                                                       # 入力行番号
    push(@{$obj->{pipe_data}}, []);                                                           # 最終抽出結果出力用の配列を追加
    my $return_data = \@{${$obj->{pipe_data}}[$#{$obj->{pipe_data}}]};                        # 最終抽出結果
    
    ########################
    # 抽出条件存在チェック #
    ########################
    if ($#{$obj->{cond_data}} < 0) {
        # 抽出条件なし
        return ();
    }
    
    ################
    # ファイルOPEN #
    ################
    if ($obj->{in_kbn} eq 'file') {
        # ファイル指定
        &in_file_open($obj->{in_name});
    }
    
    ############
    # 抽出実行 #
    ############
    # 全ての抽出が完了するまで抽出（無限ループ）
    while (1) {
        #==========#
        # 変数定義 #
        #==========#
        my $next_index = $obj->{cond_index} + 1;                                              # next抽出位置
        my $in_data    = \@{${$obj->{pipe_data}}[$obj->{cond_index}]};                        # (抽出位置の)入力pipe情報
        my $out_data   = \@{${$obj->{pipe_data}}[$next_index]};                               # (抽出位置の)出力pipe情報
        
        #==================#
        # データ取得・抽出 #
        #==================#
        # 抽出位置をチェックし、実施処理を振り分ける
        if ($obj->{cond_index} < 0) {
            #--------------------#
            # 抽出対象データ取得 #
            #--------------------#
            &get_extraction_data($obj, \$seek_byte, \$index_org);
            # 最終行番号が設定できた場合、抽出条件("end")を実数化
            if (${$out_data}[$#{$out_data}] eq 'Data_Extraction_END') {
                my $cond_data = \@{${$obj->{cond_data}}[$next_index]};
                # 開始条件を変換
                &get_cond_l_s($index_org, grep{${$_}[0] eq 'L' and ${$_}[2] =~ /end/}@{$cond_data});
                # 終了条件を変換
                &get_cond_l_e($index_org, grep{${$_}[0] eq 'L' and ${$_}[3] =~ /end/}@{$cond_data});
            }
        } else {
            #--------------------------#
            # 抽出位置のEDコマンド抽出 #
            #--------------------------#
            &watch_extraction_data($obj, \@index_now);
        }
        
        #==================#
        # 抽出終了チェック #
        #==================#
        # 全EDコマンド抽出が完了したかチェック
        if ($#{$return_data} >= 0 and ${$return_data}[$#{$return_data}] eq 'Data_Extraction_END') {
            #------------------------#
            # 全EDコマンド抽出が完了 #
            #------------------------#
            # 繰り返し(while)を抜ける
            last;
        }
        
        #======================#
        # 次回抽出位置チェック #
        #======================#
        # 後続EDコマンド抽出が可能かチェック
        if ($obj->{cond_index} < $#{$obj->{cond_data}} and
            # データ取得(cond_index=-1)時
           (($obj->{cond_index} < 0                                       and $#{$out_data} > ${$obj->{cond_buf_max}}[$next_index]) or
            # EDコマンド抽出(cond_index>=0)時、且つユーザバッファ数(user_buf_max)＞＝cond_buf_max時
            ($obj->{user_buf_max} >= ${$obj->{cond_buf_max}}[$next_index] and $#{$out_data} > ($obj->{user_buf_max} * 2)) or
            # EDコマンド抽出(cond_index>=0)時、且つuser_buf_max＜cond_buf_max時
            ($obj->{user_buf_max} < ${$obj->{cond_buf_max}}[$next_index]  and $#{$out_data} > ($obj->{user_buf_max} + ${$obj->{cond_buf_max}}[$next_index])) or
            # "Data_Extraction_END"まで出力済時
            ($#{$out_data} >= 0 and ${$out_data}[$#{$out_data}] eq 'Data_Extraction_END'))) {
            #----------------------------#
            # 後続EDコマンドの抽出が可能 #
            #----------------------------#
            # 後続EDコマンド抽出へシフト
            $obj->{cond_index}++;
            # 繰り返し(while)の先頭に戻る
            next;
        }
        # 先行EDコマンド抽出に戻るべきかチェック(処理できるEDコマンド抽出まで戻る)
        while ($obj->{cond_index} >= 0 and
            # 入力データなし(in_data=-1)時
           ($#{$in_data} == -1 or
           (${$in_data}[$#{$in_data}] ne 'Data_Extraction_END' and
            # 先頭EDコマンド抽出(cond_index=0)時
           (($obj->{cond_index} == 0                                             and $#{$in_data} <= ${$obj->{cond_buf_max}}[$obj->{cond_index}]) or
            # 後続EDコマンド抽出(cond_index>0)時、且つuser_buf_max＞＝cond_buf_max時
            ($obj->{user_buf_max} >= ${$obj->{cond_buf_max}}[$obj->{cond_index}] and $#{$in_data} <= ($obj->{user_buf_max} * 2)) or
            # 後続EDコマンド抽出(cond_index>0)時、且つuser_buf_max＜cond_buf_max時
            ($obj->{user_buf_max} < ${$obj->{cond_buf_max}}[$obj->{cond_index}]  and $#{$in_data} <= ($obj->{user_buf_max} + ${$obj->{cond_buf_max}}[$obj->{cond_index}])))))) {
            #----------------------------#
            # 現EDコマンドの抽出が不可能 #
            #----------------------------#
            # 先行EDコマンド抽出へシフト
            $obj->{cond_index}--;
            $in_data    = \@{${$obj->{pipe_data}}[$obj->{cond_index}]};
        }
    }
    
    #################
    # ファイルCLOSE #
    #################
    if ($obj->{in_kbn} eq 'file') {
        # ファイル指定
        &in_file_close($obj->{in_name});
    }
    
    ################
    # 抽出結果返却 #
    ################
    return &extraction_result(@{$return_data});
}
###################################################################################################
#   ＜＜ 抽出対象データ取得 ＞＞                                                                  #
###################################################################################################
sub get_extraction_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = レコードbyte位置                                                        #
    #      ： $_[2] = オリジナル行番号                                                        #
    # 処理 ： 抽出対象データ取得、抽出対象データ情報をpipe配列へ登録                          #
    #-----------------------------------------------------------------------------------------#
    # ※抽出対象データ情報とは、下記を配列化したもの                                          #
    #   ・"オリジナル行番号"                                                                  #
    #   ・"レコードbyte位置"         ←取得区分が"ファイル指定"時に使用                       #
    #   ・"入力行番号"               ←ここでは「オリジナル行番号＝入力行番号」               #
    #   ・""(null)                   ←ユーザ関数にて使用                                     #
    #   ・"抽出対象データ"                                                                    #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $seek_byte, $index_org) = @_;                                                   # オブジェクト、レコードbyte位置、オリジナル行番号
    
    ######################
    # 抽出対象データ取得 #
    ######################
    # レコードbyte位置へ移動
    seek EXTRACTION_FILE, (${$seek_byte}), 0 or "$!($obj->{in_name})";
    # レコード情報を取得
    my $line = &get_line_data($obj, ${$index_org});
    
    ######################
    # 取得データチェック #
    ######################
    # 取得データがEOFかチェック
    if ("$line" ne 'Data_Extraction_END') {
        #============#
        # データあり #
        #============#
        # オリジナル行番号をカウントUP
        ${$index_org}++;
        # 取得区分をチェックし、pipe配列への登録方法を確定
        if ($obj->{in_kbn} ne '') {
            #--------------#
            # ファイル指定 #
            #--------------#
            # 抽出対象データ情報をpipe配列へ登録
            push(@{${$obj->{pipe_data}}[0]}, ["${$index_org}", "${$seek_byte}", "${$index_org}", '', "$line"]);
            # レコードbyte位置を退避
            ${$seek_byte} = (tell EXTRACTION_FILE);
        } else {
            #----------#
            # 変数指定 #
            #----------#
            # 抽出対象データ情報をpipe配列へ登録
            push(@{${$obj->{pipe_data}}[0]}, ["${$index_org}", '', "${$index_org}", '', "$line"]);
        }
    } else {
        #=====#
        # EOF #
        #=====#
        # "Data_Extraction_END"をpipe配列へ登録
        push(@{${$obj->{pipe_data}}[0]}, 'Data_Extraction_END');
    }
}
###################################################################################################
#   ＜＜ 処理位置のEDコマンド抽出 ＞＞                                                            #
###################################################################################################
sub watch_extraction_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 抽出判定、抽出データのpipe配列登録                                              #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $index_now) = @_;                                                               # オブジェクト、入力行番号
    
    ################################
    # 先行EDコマンド抽出結果を取得 #
    ################################
    # 処理位置の入力pipe情報をshiftして抽出対象データ情報を取得
    my $line_data = shift(@{${$obj->{pipe_data}}[$obj->{cond_index}]});
    
    ######################
    # 取得データチェック #
    ######################
    if ("$line_data" ne 'Data_Extraction_END') {
        #============#
        # データあり #
        #============#
        # 入力行番号をカウントUP
        ${$index_now}[$obj->{cond_index}]++;
        # 抽出対象データ情報の入力行番号を最新化
        ${$line_data}[2] = ${$index_now}[$obj->{cond_index}];
        # 抽出条件置換え
        &change_extraction_cond($obj, \@{$line_data});
        # EDコマンド抽出判定
        &check_extraction_data($obj, \@{$line_data});
    } else {
        #=====#
        # EOF #
        #=====#
        # "Data_Extraction_END"をpipe配列へ登録
        push(@{${$obj->{pipe_data}}[($obj->{cond_index} + 1)]}, 'Data_Extraction_END');
    }
}
###################################################################################################
#   ＜＜ 抽出結果返却 ＞＞                                                                        #
###################################################################################################
sub extraction_result {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： @_ = EDコマンド抽出結果                                                         #
    # 処理 ： EDコマンド抽出結果からユーザスクリプトへ返却する情報を生成                      #
    # 返却 ： 最終抽出結果(ユーザスクリプトへ返却する情報)                                    #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my @result_data = @_;                                                                     # EDコマンド抽出結果
    my @return_data = ();                                                                     # 最終抽出結果(ユーザスクリプトへ返却する情報)
    
    ################
    # 抽出結果生成 #
    ################
    # EDコマンド抽出結果からユーザスクリプトへ返却する情報を生成
    foreach my $result(@result_data) {
        # 返却対象情報の内、データ部分のみを抜き出す
        if ($result ne 'Data_Extraction_END' and ${$result}[3] ne 'DEL') {
            push(@return_data, "${$result}[4]");
        }
    }
    
    ####################
    # 最終抽出結果返却 #
    ####################
    return @return_data;
}
###################################################################################################
#   ＜＜ 抽出条件置換え ＞＞                                                                      #
###################################################################################################
sub change_extraction_cond {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 抽出対象データ情報                                                      #
    # 処理 ： 定型抽出条件の置換え                                                            #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $line_data) = @_;                                                               # オブジェクト、抽出対象データ情報
    my ($index_org, $seek_byte, $index_now, $out_kbn, $in_line) = @{$line_data};              # オリジナル行番号、レコードbyte位置、入力行番号、出力区分、抽出対象データ
    my $cond_index   = $obj->{cond_index};                                                    # 処理位置
    my $cond_data    = \@{${$obj->{cond_data}}[$cond_index]};                                 # (処理位置の)抽出条件
    my $pipe_data    = \@{${$obj->{pipe_data}}[$cond_index]};                                 # (処理位置の)入力pipe情報
    my $cond_buf_max = ${$obj->{cond_buf_max}}[$cond_index];                                  # (処理位置の)定型指定最大バッファ数
    my $line_end     = 0;                                                                     # 最終行番号
    
    ################
    # 最終行を検索 #
    ################
    # 抽出条件に最終行指定("end")があるかチェック
    if ((grep {${$_}[0] =~ /L/ and (${$_}[2] =~ /end/ or ${$_}[3] =~ /end/)}@{$cond_data}) > 0) {
        #===============#
        # "end"指定あり #
        #===============#
        # 入力pipe情報にEOF情報が存在するかチェックし、最終行番号を設定
        if (($#{$pipe_data} == $cond_buf_max and ${$pipe_data}[$cond_buf_max] eq 'Data_Extraction_END') or
            ($#{$pipe_data} >= 0 and $#{$pipe_data} < $cond_buf_max and ${$pipe_data}[$#{$pipe_data}] eq 'Data_Extraction_END')) {
            my $add_cnt = 0;
            for (my $index=0 ; $index <= $#{$pipe_data}; $index++) {
                # index位置がEOFかチェック
                if (${$pipe_data}[$index] ne 'Data_Extraction_END') {
                    #------------#
                    # 通常データ #
                    #------------#
                    # 後続データ数をカウントUP
                    $add_cnt++;
                } else {
                    #-----#
                    # EOF #
                    #-----#
                    if ($index == 0) {
                        #･････････････････････#
                        # 自レコード直後がEOF #
                        #･････････････････････#
                        # 現在行を最終行番号に設定
                        $line_end = $index_now;
                    } else {
                        #･･････････････････････････#
                        # 自レコード後にデータあり #
                        #･･････････････････････････#
                        # 最終行番号を算出
                        $line_end = $index_now + $add_cnt;
                    }
                    last;
                }
            }
        }
    }
    
    #######################################
    # 最終行指定("end")を行番号指定に変換 #
    #######################################
    # 最終行番号が設定できた場合、抽出条件("end")を実数化
    if ($line_end > 0) {
        # 開始条件を変換
        &get_cond_l_s($line_end, grep{${$_}[0] eq 'L' and ${$_}[2] =~ /end/}@{$cond_data});
        # 終了条件を変換
        &get_cond_l_e($line_end, grep{${$_}[0] eq 'L' and ${$_}[3] =~ /end/}@{$cond_data});
    }
    
    ##################################
    # 正規表現指定を行番号指定に変換 #
    ##################################
    # 開始条件を変換（get_cond_lr_s内で完結できない場合、抽出区分に"r"を設定）
    if ((grep{${$_}[0] eq 'LR'}@{$cond_data}) > 0) {
        push(@{$cond_data}, &get_cond_lr_s($obj, $index_now, "$line_end", "$in_line", grep{${$_}[0] eq 'LR'}@{$cond_data}));
    }
    # 終了条件を変換
    if ((grep{${$_}[0] eq 'r' and "$in_line" =~ /${$_}[3]/}@{$cond_data}) > 0) {
        &get_cond_lr_e($index_now, grep{${$_}[0] eq 'r' and "$in_line" =~ /${$_}[3]/}@{$cond_data});
    }
}
###################################################################################################
#   ＜＜ EDコマンド抽出判定 ＞＞                                                                  #
###################################################################################################
sub check_extraction_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 抽出対象データ情報                                                      #
    # 処理 ： 定型抽出（行・列・ブロック抽出）、ユーザー抽出（ユーザー関数呼出し）            #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $line_data) = @_;                                                               # オブジェクト、抽出対象データ情報
    my ($index_org, $seek_byte, $index_now, $out_kbn, $in_line) = @{$line_data};              # オリジナル行番号、レコードbyte位置、入力行番号、出力区分、抽出対象データ
    my $cond_index = $obj->{cond_index};                                                      # 処理位置
    my $cond_data  = \@{${$obj->{cond_data}}[$cond_index]};                                   # (処理位置の)抽出条件
    my $buff_data  = \@{${$obj->{buff_data}}[$cond_index]};                                   # (処理位置の)バッファ情報
    my $out_data   = \@{${$obj->{pipe_data}}[($cond_index + 1)]};                             # (処理位置の)出力pipe情報
    my $out_index  = \${$obj->{out_index}}[$cond_index];                                      # (処理位置の)出力件数
    
    ################
    # バッファ登録 #
    ################
    # ユーザ指定最大バッファ数以上になった場合、バッファ情報をshiftして古いデータを削除
    if ($#{$buff_data} >= $obj->{user_buf_max}) {shift(@{$buff_data})}
    # 抽出対象データ情報をバッファ情報の最後に登録
    push(@{$buff_data}, $line_data);
    
    ##################################
    # ユーザ関数出力済情報のチェック #
    ##################################
    if ($#{${$obj->{mid_data}}[$obj->{cond_index}]} >= 0) {
        # ユーザ関数によって削除済かチェック
        if (&check_mid_data($obj, $index_now)) {return ()}
        # ユーザ関数によって追加・更新済かチェック
        if (&put_mid_data($obj, $index_now)) {return ()}
    }
    
    my @in_line_col     = &get_col_data("$in_line", "0");
    my $in_col_su       = $#in_line_col + 1;
    my $extraction_data = ('0' x $in_col_su);
    ##############
    # ユーザ抽出 #
    ##############
    if ((grep{${$_}[0] eq 'USER'}@{$cond_data}) > 0) {
        $extraction_data = "$extraction_data" |
                           &get_cond_user($obj, "$in_line", grep{${$_}[0] eq 'USER'}@{$cond_data});
    }
    # ユーザ抽出結果が０の場合、ユーザ関数で直接更新していないかチェック
    if ($extraction_data == 0) {
        # ユーザ出力有無チェック
        #   ユーザ出力あり、且つ
        #   最終出力pipe情報の入力行番号が現在行、且つ
        #   最終出力pipe情報の出力区分が"USER"又は"DEL"
        if ($obj->{user_out_kbn} ne '' and $#{$out_data} >= 0 and
            ${${$out_data}[$#{$out_data}]}[0] eq $index_org and
           (${${$out_data}[$#{$out_data}]}[3] eq 'USER' or ${${$out_data}[$#{$out_data}]}[3] eq 'DEL')) {
            #----------------------------#
            # ユーザによって現在行を出力 #
            #----------------------------#
            # 出力された情報が削除指示かチェック
            if (${${$out_data}[$#{$out_data}]}[3] eq 'DEL') {
                #･･････････#
                # 削除指示 #
                #･･････････#
                # 出力pipe情報の最後(削除指示データ)を削除
                pop(@{$out_data});
            }
            # 呼出し元へ戻る
            return ();
        }
        # 先行EDコマンド抽出でユーザ出力されたデータかチェック
        if ($out_kbn eq 'USER') {
            #------------#
            # ユーザ出力 #
            #------------#
            # 出力件数をカウントUPし、抽出対象データ情報を出力pipe情報の最後に登録
            ${$out_index}++;
            push(@{$out_data}, ["$index_org", "$seek_byte", "${$out_index}", 'USER', "$in_line"]);
            # 呼出し元へ戻る
            return ();
        }
    }
    
    if ("$extraction_data" =~ /^1/) {
        ######################
        # ユーザ抽出結果登録 #
        ######################
        my $out_line = &get_out_line("$in_line", \@in_line_col, "$extraction_data");
        # 出力カウンタをカウントUP
        ${$out_index}++;
        # 抽出結果を出力pipe情報に登録
        push(@{$out_data}, ["$index_org", "$seek_byte", "${$out_index}", "$out_kbn", "$out_line"]);
    } else {
        ####################################
        # 定型抽出(行抽出、行抽出＋列抽出) #
        ####################################
        my @cond_data_lc = (grep{(${$_}[0] eq 'L' and ((${$_}[1] eq '' and ${$_}[2] !~ /end/ and ${$_}[2] <= $index_now and (${$_}[3] =~ /end/ or $index_now <= ${$_}[3]))
                                                    or (${$_}[1] ne '' and (${$_}[2] =~ /end/ or $index_now < ${$_}[2] or (${$_}[3] !~ /end/ and ${$_}[3] < $index_now))))
                              or (${$_}[0] eq 'r' and ((${$_}[1] eq '' and ${$_}[2] <= $index_now)
                                                    or (${$_}[1] ne '' and $index_now < ${$_}[2])))
                              or (${$_}[0] eq 'LR' and ${$_}[1] ne '' and ${$_}[8] eq '1' and ${$_}[9] =~ /[0-9]+/ and ${$_}[9] <= $index_now))}@{$cond_data});
        if ($#cond_data_lc >= 0) {
            # 行番号指定による行抽出("L"＝行番号指定、又は行番号指定へ変換した正規表現指定(元"LR"))
            # ・肯定抽出、且つ（開始行番号≦現在行≦終了行番号、又は終了行番号＝"end"）
            # ・否定抽出、且つ（開始行番号＝"end"、又は現在行＜終了行番号、又は（終了行番号≠"end"、且つ終了行番号＜現在行））
            # 正規表現による行抽出("r"＝開始条件のみ行番号指定へ変換している(元"LR"))
            # ・肯定抽出、且つ開始行番号≦現在行
            # ・否定抽出、且つ現在行＜開始行番号
            # 正規表現による行抽出("LR"＝正規表現指定が行番号指定へ変換されていない)
            # ・否定抽出、且つ抽出条件未検出
            $extraction_data = "$extraction_data" |
                               &get_cond_lc("$in_line", $in_col_su, @cond_data_lc);
            
            if ("$extraction_data" =~ /^1/) {
                ########################
                # 定型抽出結果登録(行) #
                ########################
                my $out_line = &get_out_line("$in_line", \@in_line_col, "$extraction_data");
                # 出力カウンタをカウントUP
                ${$out_index}++;
                # 抽出結果を出力pipe情報に登録
                push(@{$out_data}, ["$index_org", "$seek_byte", "${$out_index}", "$out_kbn", "$out_line"]);
                # 不要になった抽出条件を削除
                my @cond_data_new = ();
                foreach my $cut_cond(@{$cond_data}) {
                    if (${$cut_cond}[0] ne 'L' or (${$cut_cond}[0] eq 'L' and ((${$cut_cond}[1] eq '' and (${$cut_cond}[2] =~ /end/ or ${$cut_cond}[3] =~ /end/ or ${$cut_cond}[3] > $index_now))
                                                                             or ${$cut_cond}[1] ne '' ))) {
                        push(@cond_data_new, \@{$cut_cond});
                    }
                }
                @{$cond_data} = @cond_data_new;
                if ($#{$cond_data} < 0) {
                    push(@{$out_data}, 'Data_Extraction_END');
                }
                return ();
            }
        }
        
        ####################
        # 定型抽出(列抽出) #
        ####################
        my @cond_data_temp = (grep{${$_}[0] =~ /C/}@{$cond_data});
        if ($#cond_data_temp >= 0) {
            # 列番号指定による列抽出("C")
            $extraction_data = "$extraction_data" |
                               &get_cond_c($in_col_su, grep{${$_}[0] eq 'C'}@{$cond_data});
            # 正規表現による列抽出("CR")
            $extraction_data = "$extraction_data" |
                               &get_cond_cr("$in_line", $in_col_su, grep{${$_}[0] eq 'CR'}@{$cond_data});
        }
        
        ########################
        # 定型抽出結果登録(列) #
        ########################
        if ($extraction_data > 0) {
            my $out_line = &get_out_line("$in_line", \@in_line_col, "$extraction_data");
            # 出力カウンタをカウントUP
            ${$out_index}++;
            # 抽出結果を出力pipe情報に登録
            push(@{$out_data}, ["$index_org", "$seek_byte", "${$out_index}", "$out_kbn", "$out_line"]);
        }
    }
}
###################################################################################################
#   ＜＜ ユーザ先行出力情報チェック ＞＞                                                          #
###################################################################################################
sub check_mid_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 入力行番号                                                              #
    # 処理 ： 入力行番号と一致するユーザ先行出力情報(削除)があるかチェック                    #
    # 返却 ： チェックフラグ（１＝削除対象あり、０＝削除対象なし）                            #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $index_now) = @_;                                                               # オブジェクト、入力行番号
    my $mid_data          = \@{${$obj->{mid_data}}[$obj->{cond_index}]};                      # (処理位置の)ユーザ先行出力情報
    
    ##############################
    # ユーザ先行出力情報チェック #
    ##############################
    for (my $index=0 ; $index <= $#{$mid_data}; $index++) {
        # 入力行番号が一致するデータが削除情報(出力区分＝"DEL")かチェック
        if (${${$mid_data}[$index]}[2] == $index_now and ${${$mid_data}[$index]}[3] eq 'DEL') {
            #==========#
            # 削除対象 #
            #==========#
            # 「削除対象あり」を返却
            return 1;
        }
    }
    # 「削除対象なし」を返却
    return 0;
}
###################################################################################################
#   ＜＜ ユーザ先行出力情報登録 ＞＞                                                              #
###################################################################################################
sub put_mid_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 入力行番号                                                              #
    # 処理 ： 入力行番号と一致するユーザ先行出力情報を出力pipe情報へ登録                      #
    # 返却 ： 出力フラグ（１＝あり、０＝なし）                                                #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $index_now) = @_;                                                               # オブジェクト、入力行番号
    my $mid_data  = \@{${$obj->{mid_data}}[$obj->{cond_index}]};                              # (処理位置の)ユーザ先行出力情報
    my $out_data  = \@{${$obj->{pipe_data}}[($obj->{cond_index} + 1)]};                       # (処理位置の)出力pipe情報
    my $out_index = \${$obj->{out_index}}[$obj->{cond_index}];                                # (処理位置の)出力件数
    my $out_flg   = 0;                                                                        # 出力フラグ
    
    ##############################
    # ユーザ先行出力情報チェック #
    ##############################
    # カレント行に対するユーザ先行出力情報があるか検索
    for (my $index=0 ; $index <= $#{$mid_data}; $index++) {
        # 入力行番号が一致するかチェック
        if ($index_now == ${${$mid_data}[$index]}[2]) {
            #==============================#
            # 行番号が一致(カレント行あり) #
            #==============================#
            # 出力件数をカウントUP
            ${$out_index}++;
            # ユーザ先行出力情報を出力pipe情報へ登録
            push(@{$out_data}, ["${${$mid_data}[$index]}[0]", "${${$mid_data}[$index]}[1]", "${$out_index}", "${${$mid_data}[$index]}[3]", "${${$mid_data}[$index]}[4]"]);
            # 「ユーザ先行出力あり」を出力フラグへ設定
            $out_flg = 1;
            # 「ユーザ出力あり」をユーザ出力区分へ設定
            $obj->{user_out_kbn} = 'output';
        }
    }
    
    ##################
    # 出力フラグ返却 #
    ##################
    return $out_flg;
}
###################################################################################################
#   ＜＜ 抽出データを取得 ＞＞                                                                    #
###################################################################################################
sub get_out_line {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 行データ                                                                #
    #      ： $_[1] = 配列化した行データ                                                      #
    #      ： $_[2] = 抽出対象区分                                                            #
    # 処理 ： 抽出対象区分から抽出データを取得                                                #
    # 返却 ： 抽出データ                                                                      #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($line, $col_data, $extraction_data) = @_;                                             # 行データ、配列化した行データ、抽出対象区分
    ##################
    # 抽出データ取得 #
    ##################
    # 行抽出か列抽出かチェック
    if ("$extraction_data" =~ /^1/) {
        #========#
        # 行抽出 #
        #========#
        # 行データをそのまま抽出データとする
        return "$line";
    } else {
        #========#
        # 列抽出 #
        #========#
        # "1"(抽出対象)になっている列のみ抽出データとする
        unshift @{$col_data}, '';
        my $out_data = '';
        for (my $index=1; $index <= $#{$col_data}; $index++) {
            if ((substr $extraction_data, $index, 1) eq '1' and ${$col_data}[$index] ne '') {
                $out_data .= "${$col_data}[$index] ";
            }
        }
        chop $out_data;
        return $out_data;
    }
}
###################################################################################################
#   ＜＜ 入力ファイルＯＰＥＮ ＞＞                                                                #
###################################################################################################
sub in_file_open {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 入力ファイル名                                                          #
    # 処理 ： 入力ファイルのファイルＯＰＥＮ                                                  #
    #-----------------------------------------------------------------------------------------#
    if (! open (EXTRACTION_FILE, "< $_[0]")) {
        # 入力ファイルOPENエラー
        print STDERR "Input File($_[0]) cannot Open\n";
        exit 99;
    }
    #flock(EXTRACTION_FILE, 1);
}
###################################################################################################
#   ＜＜ 入力ファイルＣＬＯＳＥ ＞＞                                                              #
###################################################################################################
sub in_file_close {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 入力ファイル名                                                          #
    # 処理 ： 入力ファイルのファイルＣＬＯＳＥ                                                #
    #-----------------------------------------------------------------------------------------#
    if (! close (EXTRACTION_FILE)) {
        # 入力ファイルCLOSEエラー
        print STDERR "Input File($_[0]) cannot Close\n";
        exit 99;
    }
}
###################################################################################################
#   ＜＜ 処理中行番号取得 ＞＞                                                                    #
###################################################################################################
sub get_line_num {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 処理中の行番号を取得                                                            #
    # 返却 ： 処理中の行番号                                                                  #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj       = shift;                                                                    # オブジェクト
    my $in_data   = \@{${$obj->{pipe_data}}[$obj->{cond_index}]};                             # (処理位置の)入力pipe情報
    my $buff_data = \@{${$obj->{buff_data}}[$obj->{cond_index}]};                             # (処理位置の)バッファ情報
    
    # seek区分をチェックし、seek位置の行番号を取得・返却
    if ($obj->{seek_kbn} eq 'buff') {
        #======================#
        # バッファ情報から取得 #
        #======================#
        return ${${$buff_data}[$obj->{seek_index}]}[2];
    } elsif ($obj->{seek_kbn} eq 'input') {
        #======================#
        # 入力pipe情報から取得 #
        #======================#
        return ${${$in_data}[$obj->{seek_index}]}[2];
    } else {
        #========================#
        # オリジナル情報から取得 #
        #========================#
        return ${$obj->{seek_num}}[2];
    }
}
###################################################################################################
#   ＜＜ seek行番号チェック ＞＞                                                                  #
###################################################################################################
sub check_seek_num {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = seek行番号                                                              #
    # 処理 ： 行番号の記述チェック                                                            #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $seek_no) = @_;                                                                 # オブジェクト、seek行番号
    my $buff_data       = \@{${$obj->{buff_data}}[$obj->{cond_index}]};                       # (処理位置の)バッファ情報
    
    ######################
    # seek行番号チェック #
    ######################
    # ０より大きい数字かチェック
    if ($seek_no !~ /^\d+$/ or $seek_no <= 0) {
        #==============================#
        # 数字以外、または０以下の数字 #
        #==============================#
        # seek行番号エラー
        print STDERR "Seek Line Number Error ($seek_no)\n";
        exit 99;
    }
    
    ##############################
    # seek可能な行番号かチェック #
    ##############################
    # ユーザ指定最大バッファ数を越えていないかチェック
    if ((${${$buff_data}[$#{$buff_data}]}[2] < $seek_no and (${${$buff_data}[$#{$buff_data}]}[2] + $obj->{user_buf_max}) < $seek_no) or
        (${${$buff_data}[$#{$buff_data}]}[2] > $seek_no and (${${$buff_data}[$#{$buff_data}]}[2] - $obj->{user_buf_max}) > $seek_no)) {
        #======================================#
        # ユーザ指定最大バッファ数を越えている #
        #======================================#
        # seek範囲エラー
        print STDERR "Seek Buffer Range Error ($seek_no)\n";
        exit 99;
    }
}
###################################################################################################
#   ＜＜ データ取得区分チェック ＞＞                                                              #
###################################################################################################
sub check_data_acquisition_division {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = データ取得区分                                                          #
    # 処理 ： データ取得区分の記述チェック                                                    #
    #-----------------------------------------------------------------------------------------#
    if ($_[0] ne 'org' and $_[0] ne 'now') {
        print STDERR "Data Acquisition division Error ($_[0])\n";
        exit 99;
    }
}
###################################################################################################
#   ＜＜ バッファエラー ＞＞                                                                      #
###################################################################################################
sub error_buffers {
    # バッファに該当データ無し
    print STDERR "Buffers does not have Line Number Pertinence Data (line($_[0])-\>seek($_[1]))\n";
    exit 99;
}
###################################################################################################
#   ＜＜ 抽出対象データ取得位置指定 ＞＞                                                          #
###################################################################################################
sub seek_line {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = seek行番号                                                              #
    # 処理 ： 行番号チェック、抽出対象データの読込む位置を指定行へ移動                        #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $seek_no) = @_;                                                                 # オブジェクト、seek行番号
    my $cond_index = $obj->{cond_index};                                                      # 処理位置
    my $in_data    = \@{${$obj->{pipe_data}}[$cond_index]};                                   # (処理位置の)入力pipe情報
    my $buff_data  = \@{${$obj->{buff_data}}[$cond_index]};                                   # (処理位置の)バッファ情報
    my $out_data   = \@{${$obj->{pipe_data}}[($cond_index + 1)]};                             # (処理位置の)出力pipe情報
    
    ######################
    # seek行番号チェック #
    ######################
    &check_seek_num($obj, "$seek_no");
    
    ########################
    # seek先データ位置取得 #
    ########################
    # ユーザ出力済の場合、"seek"(ユーザ出力後のseek)をユーザ出力区分に設定
    if ($obj->{user_out_kbn} ne '') {
        $obj->{user_out_kbn} = 'seek';
    }
    # seek行番号をチェックし、seek対象先を振り分ける
    if ($seek_no <= ${${$buff_data}[$#{$buff_data}]}[2]) {
        #==================#
        # seek先が処理済行 #
        #==================#
        # バッファ情報を検索
        for (my $index=0; $index <= $#{$buff_data}; $index++) {
            # 現在行がseek行番号のデータかチェック
            if ($seek_no == ${${$buff_data}[$index]}[2]) {
                #--------------------------#
                # seek行番号のデータが存在 #
                #--------------------------#
                # 入力区分が"ファイル"の場合、検出したレコードbyte位置へ移動
                if ($obj->{in_kbn} ne '') {
                    seek EXTRACTION_FILE, (${${$buff_data}[$index]}[1]), 0 or "$!($obj->{in_name})";
                }
                # ＜seek情報の設定＞
                $obj->{seek_kbn}          = 'buff';                                           # seek区分←バッファ情報("buff")
                @{$obj->{seek_num}}[0..2] = @{${$buff_data}[$index]};                         # seek行情報←バッファ情報(オリジナル行番号、レコードbyte位置、入力行番号)
                $obj->{seek_index}        = $index;                                           # seek位置←検出index
                # ＜get情報の設定＞
                $obj->{get_kbn}           = $obj->{seek_kbn};                                 # get区分
                @{$obj->{get_num}}        = @{$obj->{seek_num}};                              # get行情報
                $obj->{get_index}         = $obj->{seek_index};                               # get位置
                # ＜呼出し元へ復帰＞
                return 0;
            }
        }
        # seekエラー
        &error_buffers(${${$buff_data}[$#{$buff_data}]}[2],$seek_no);
    } else {
        #================#
        # seek先が後続行 #
        #================#
        # 何回目のEDコマンド抽出か処理位置をチェックし、処理を振り分ける
        if ($cond_index > 0) {
            #--------------------------------#
            # 後続(２個目以降)EDコマンド抽出 #
            #--------------------------------#
            # 最大検索数(for_max)を設定
            my $for_max = $#{$in_data};                                                       # 入力pipe情報数を設定
            if (${$in_data}[$#{$in_data}] ne 'Data_Extraction_END') {
                $for_max = $obj->{user_buf_max};                                              # ユーザ指定最大バッファ数を設定
            }
            # 入力pipe情報(index=0〜最大検索先)を検索
            for (my $index=0; $index <= $for_max; $index++) {
                # 現在行がseek行番号のデータかチェック
                if ($seek_no == ${${$in_data}[$index]}[2]) {
                    #･･････････････････････････#
                    # seek行番号のデータが存在 #
                    #･･････････････････････････#
                    # 入力区分が"ファイル"の場合、検出したレコードbyte位置へ移動
                    if ($obj->{in_kbn} ne '') {
                        seek EXTRACTION_FILE, (${${$in_data}[$index]}[1]), 0 or "$!($obj->{in_name})";
                    }
                    # ＜seek情報の設定＞
                    $obj->{seek_kbn}          = 'input';                                      # seek区分←入力pipe情報("input")
                    @{$obj->{seek_num}}[0..2] = @{${$in_data}[$index]};                       # seek行情報←入力pipe情報(オリジナル行番号、レコードbyte位置、入力行番号)
                    $obj->{seek_index}        = $index;                                       # seek位置←検出index
                    # ＜get情報の設定＞
                    $obj->{get_kbn}           = $obj->{seek_kbn};                             # get区分
                    @{$obj->{get_num}}        = @{$obj->{seek_num}};                          # get行情報
                    $obj->{get_index}         = $obj->{seek_index};                           # get位置
                    # ＜呼出し元へ復帰＞
                    return 0;
                }
            }
            # seekエラー
            &error_buffers(${${$buff_data}[$#{$buff_data}]}[2],$seek_no);
        } else {
            #--------------------#
            # 初回EDコマンド抽出 #
            #--------------------#
            # 入力区分が"ファイル"の場合、最終バッファ情報のレコードbyte位置へ移動
            if ($obj->{in_kbn} ne '') {
                seek EXTRACTION_FILE, (${${$buff_data}[$#{$buff_data}]}[1]), 0 or "$!($obj->{in_name})";
            }
            # 最終バッファ情報(入力行番号)をチェック行番号へ設定
            my $check_no = ${${$buff_data}[$#{$buff_data}]}[2];
            # オリジナル行データを取得
            my $line = &get_line_data($obj, $check_no);
            # EOFになるまで、オリジナル情報を検索
            while ("$line" ne 'Data_Extraction_END') {
                # チェック行番号をカウントUP
                $check_no++;
                # 現在行がseek行番号のデータかチェック
                if ($seek_no == $check_no) {
                    #･･････････････････････････#
                    # seek行番号のデータを検出 #
                    #･･････････････････････････#
                    # ＜seek情報の設定＞
                    $obj->{seek_kbn}          = 'org';                                        # seek区分←オリジナル情報("org")
                    @{$obj->{seek_num}}[0..2] = ($check_no, (tell EXTRACTION_FILE), $seek_no);# seek行情報←オリジナル情報(チェック行番号、レコードbyte位置、seek行番号)
                    $obj->{seek_index}        = 0;                                            # seek位置←０
                    # ＜get情報の設定＞
                    $obj->{get_kbn}           = $obj->{seek_kbn};                             # get区分
                    @{$obj->{get_num}}        = @{$obj->{seek_num}};                          # get行情報
                    $obj->{get_index}         = $obj->{seek_index};                           # get位置
                    # ＜呼出し元へ復帰＞
                    return 0;
                }
                # オリジナル行データを取得
                $line = &get_line_data($obj, $check_no);
            }
            # seekエラー
            &error_buffers(${${$buff_data}[$#{$buff_data}]}[2],$seek_no);
        }
    }
}
###################################################################################################
#   ＜＜ 抽出対象データ取得 ＞＞                                                                  #
###################################################################################################
sub get_line {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = データ取得区分（org：オリジナル／now：抽出結果）                        #
    # 処理 ： データ取得区分チェック、抽出対象データの取得                                    #
    # 返却 ： 抽出対象データ                                                                  #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $data_kbn) = @_;                                                                # オブジェクト、データ取得区分
    my $line        = '';                                                                     # 抽出対象データ
    my $cond_index  = $obj->{cond_index};                                                     # 処理位置
    my $in_data     = \@{${$obj->{pipe_data}}[$cond_index]};                                  # (処理位置の)入力pipe情報
    my $buff_data   = \@{${$obj->{buff_data}}[$cond_index]};                                  # (処理位置の)バッファ情報
    
    ##########################
    # データ取得区分チェック #
    ##########################
    &check_data_acquisition_division("$data_kbn");
    
    ######################
    # 抽出対象データ取得 #
    ######################
    # 取得区分をチェックし、処理を振り分ける
    if ($data_kbn eq 'org' or $obj->{seek_kbn} eq 'org') {
        #==========================#
        # オリジナルデータから取得 #
        #==========================#
        # seek区分をseek行情報(取得区分)へ設定
        ${$obj->{seek_num}}[3] = $obj->{seek_kbn};
        # seek位置を補正すべきかチェック
        # ・前回取得がオリジナル情報以外、且つ後続(２回目以降の)EDコマンド抽出、且つデータ取得区分の指示によるオリジナル情報取得
        if (${$obj->{get_num}}[3] ne 'org' and
            $obj->{seek_kbn} ne 'org' and
            ${$obj->{get_num}}[2] ne ${$obj->{seek_num}}[2]) {
            # 入力区分が"ファイル"の場合、seek行情報のレコードbyte位置へ移動
            if ($obj->{in_kbn} ne '') {
                seek EXTRACTION_FILE, (${$obj->{seek_num}}[1]), 0 or "$!($obj->{in_name})";
                my $line2 = &get_line_data($obj, ${$obj->{seek_num}}[0]);
                # get_line_dataで次へ移動してしまう為、seek行情報の入力行番号を戻す
                ${$_[0]->{seek_num}}[2]--;
            }
        }
        # 抽出対象データを取得
        if ($_[0]->{in_kbn} eq '') {
            $line = &get_line_data($obj, (${$obj->{seek_num}}[0] - 1));
        } else {
            $line = &get_line_data($obj);
        }
        
        # ＜get情報の設定＞
        $obj->{get_kbn}    = $obj->{seek_kbn};                                                # get区分
        @{$obj->{get_num}} = @{$obj->{seek_num}};                                             # get行情報
        $obj->{get_index}  = $obj->{seek_index};                                              # get位置
        # ＜seek情報の設定＞
        # seek行情報(オリジナル行番号)をカウントUP
        ${$obj->{seek_num}}[0]++;
        # seek区分が「オリジナル情報から取得("org")」以外の場合、seek行情報を設定
        if ($obj->{seek_kbn} eq 'buff' or $obj->{seek_kbn} eq 'input') {
            # seek位置をカウントUPすべきかチェック
            # ・get行情報(取得区分)が「オリジナルから取得("org")」、且つseek行情報(取得区分)が「オリジナルから取得("org")」
            # ・seek区分が「バッファ情報("buff")」、且つseek先オリジナル行番号＜seek行情報(オリジナル行番号)
            # ・seek区分が「入力pipe情報("input")」、且つseek先オリジナル行番号＜seek行情報(オリジナル行番号)
            if ((${$obj->{get_num}}[3] eq 'org'  and ${$obj->{seek_num}}[3] eq 'org') or
                ($obj->{seek_kbn} eq 'buff'  and ${${$buff_data}[$obj->{seek_index}]}[0] < ${$obj->{seek_num}}[0]) or
                ($obj->{seek_kbn} eq 'input' and ${${$in_data}[$obj->{seek_index}]}[0] < ${$obj->{seek_num}}[0])) {
                # seek位置をカウントUP
                $obj->{seek_index}++;
            }
            # seek区分が「バッファ情報から取得("buff")」、且つseek位置がバッファ情報数を超えている場合、seek区分・seek位置を設定
            if ($obj->{seek_kbn} eq 'buff' and $#{$buff_data} < $obj->{seek_index}) {
                # 抽出位置をチェックし、次の取得情報を決める
                if ($cond_index > 0) {
                    #----------------------------#
                    # 次回は入力pipe情報から取得 #
                    #----------------------------#
                    $obj->{seek_kbn}   = 'input';                                             # seek区分←入力pipe情報("input")
                    $obj->{seek_index} = 0;                                                   # seek位置←０
                } else {
                    #------------------------------#
                    # 次回はオリジナル情報から取得 #
                    #------------------------------#
                    $obj->{seek_kbn}   = 'org';                                               # seek区分←オリジナル情報("org")
                    $obj->{seek_index} = 0;                                                   # seek位置←０
                }
            }
        }
        # get行情報の取得区分に「オリジナルから取得("org")」を設定
        ${$obj->{get_num}}[3] = 'org';
    } else {
        #================================#
        # 先行EDコマンド抽出結果から取得 #
        #================================#
        # seek区分をチェックし、データ取得先を振り分ける
        if ($obj->{seek_kbn} eq 'buff') {
            #----------------------#
            # バッファ情報から取得 #
            #----------------------#
            ${$obj->{seek_num}}[0] = ${${$buff_data}[$obj->{seek_index}]}[0];                 # オリジナル行番号
            ${$obj->{seek_num}}[1] = ${${$buff_data}[$obj->{seek_index}]}[1];                 # レコードbyte位置
            $line                  = ${${$buff_data}[$obj->{seek_index}]}[4];                 # 抽出対象データ
        } else {
            #----------------------#
            # 入力pipe情報から取得 #
            #----------------------#
            ${$obj->{seek_num}}[0] = ${${$in_data}[$obj->{seek_index}]}[0];                   # オリジナル行番号
            ${$obj->{seek_num}}[1] = ${${$in_data}[$obj->{seek_index}]}[1];                   # レコードbyte位置
            $line                  = ${${$in_data}[$obj->{seek_index}]}[4];                   # 抽出対象データ
        }
        
        # ＜get情報の設定＞
        $obj->{get_kbn}    = $obj->{seek_kbn};                                                # get区分
        @{$obj->{get_num}} = @{$obj->{seek_num}};                                             # get行情報
        $obj->{get_index}  = $obj->{seek_index};                                              # get位置
        # ＜seek情報の設定＞
        # seek位置をカウントUP
        $obj->{seek_index}++;
        # seek区分・seek位置を再設定する必要があるかチェック
        # ・seek区分が「バッファ情報から取得("buff")」、且つseek位置がバッファ情報数を超えている
        if ($obj->{seek_kbn} eq 'buff' and $#{$buff_data} < $obj->{seek_index}) {
            #----------------------------------#
            # seek区分・seek位置の再設定が必要 #
            #----------------------------------#
            # 抽出位置をチェックし、次の取得情報を決める
            if ($cond_index > 0) {
                #････････････････････････････#
                # 次回は入力pipe情報から取得 #
                #････････････････････････････#
                $obj->{seek_kbn}   = 'input';                                                 # seek区分←入力pipe情報("input")
                $obj->{seek_index} = 0;                                                       # seek位置←０
            } else {
                #･･････････････････････････････#
                # 次回はオリジナル情報から取得 #
                #･･････････････････････････････#
                # 入力区分が"ファイル"の場合、seek行情報のレコードbyte位置へ移動
                if ($obj->{in_kbn} ne '') {
                    seek EXTRACTION_FILE, (${$obj->{seek_num}}[1]), 0 or "$!($obj->{in_name})";
                    my $line2 = &get_line_data($obj, ${$obj->{seek_num}}[0]);
                }
                $obj->{seek_kbn}   = 'org';                                                   # seek区分←オリジナル情報("org")
                $obj->{seek_index} = 0;                                                       # seek位置←０
                # seek行情報(オリジナル行番号)をカウントUP
                ${$obj->{seek_num}}[0]++;
            }
        } else {
            # seek行情報(オリジナル行番号)をカウントUP
            ${$obj->{seek_num}}[0]++;
            # seek行情報(入力行番号)をカウントUP
            ${$obj->{seek_num}}[2]++;
        }
    }
    return "$line";
}
###################################################################################################
#   ＜＜ レコード情報取得 ＞＞                                                                    #
###################################################################################################
sub get_line_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 入力行番号                                                              #
    # 返却 ： 取得レコード情報                                                                #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $line_index) = @_;                                                              # オブジェクト、入力行番号
    my $line = '';                                                                            # 取得レコード情報
    
    # 入力区分をチェックし、取得先を判断
    if ($obj->{in_kbn} eq '') {
        #==============#
        # 変数から取得 #
        #==============#
        my $check = '^';
        for (my $index=1; $index <= $line_index; $index++) {
            $check .= '.*\n';
        }
        $check .= '(.*\n{0,1})';
        if ((eval($obj->{in_name})) =~ /$check/) {
            $line = $1;
        }
    } else {
        #==================#
        # ファイルから取得 #
        #==================#
        $line = <EXTRACTION_FILE>;
    }
    
    # 取得データがEOFかチェック
    if ($line eq '') {
        #=====#
        # EOF #
        #=====#
        # EOF("Data_Extraction_END")を取得レコード情報へ設定
        $line = 'Data_Extraction_END';
    } else {
        #============#
        # データあり #
        #============#
        # 取得データの改行コードを削除
        if ((substr $line, -1) eq "\n") {
            chop $line;
        }
    }
    # seek行情報(入力行番号)をカウントUP
    ${$obj->{seek_num}}[2]++;
    
    # 取得レコード情報を返却
    return "$line";
}
###################################################################################################
#   ＜＜ 抽出区分初期化 ＞＞                                                                      #
###################################################################################################
sub init_extraction_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 配列化した行データの配列数                                              #
    # 処理 ： 抽出区分を初期化（配列化した行データの配列数分）                                #
    # 返却 ： 初期化した抽出区分                                                              #
    #-----------------------------------------------------------------------------------------#
    my $extraction_data = '0' x ($_[0] + 1);
    return "$extraction_data";
}
###################################################################################################
#   ＜＜ 行データ配列変換 ＞＞                                                                    #
###################################################################################################
sub get_col_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = 行データ                                                                #
    #      ： $_[1] = 処理区分（０＝先頭と最後の余白をカットしない）                          #
    # 処理 ： 行データを区切り文字で分割                                                      #
    # 返却 ： 配列化した行データ                                                              #
    #-----------------------------------------------------------------------------------------#
    if ($_[1] ne '0') {
        $_[0] =~  s/^[\s\,]*//;
        $_[0] =~  s/[\s\,]*$//;
    }
    return (split /\s+\,*\s*|\,+\s*/, $_[0]);
}
###################################################################################################
#   ＜＜ 抽出データ追加・更新 ＞＞                                                                #
###################################################################################################
sub add_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #      ： $_[1] = 行データ                                                                #
    # 処理 ： 行データを抽出データのカレント行（seekしている場合は、その行）に追加・更新      #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj, $out_line) = @_;                                                                # オブジェクト、行データ
    my $cond_index = $obj->{cond_index};                                                      # 処理位置
    my $in_data    = \@{${$obj->{pipe_data}}[$cond_index]};                                   # (処理位置の)入力pipe情報
    my $buff_data  = \@{${$obj->{buff_data}}[$cond_index]};                                   # (処理位置の)バッファ情報
    my $mid_data   = \@{${$obj->{mid_data}}[$cond_index]};                                    # (処理位置の)ユーザ先行出力情報
    my $out_data   = \@{${$obj->{pipe_data}}[($cond_index + 1)]};                             # (処理位置の)出力pipe情報
    my $out_index  = \${$obj->{out_index}}[$cond_index];                                      # (処理位置の)出力件数
    
    # get区分をチェックし、出力先を判断
    if ($obj->{get_kbn} eq 'buff') {
        ######################
        # バッファ情報へ出力 #
        ######################
        # カレントが最終バッファ情報位置だった場合、行データをバッファ情報の最後へ追加
        if ($obj->{get_index} == $#{$buff_data}) {
            #================================#
            # カレントが最終バッファ情報位置 #
            #================================#
            # バッファ情報の最後に行データを追加
            ${$out_index}++;
            push(@{$out_data}, ["${${$buff_data}[$#{$buff_data}]}[0]", "${${$buff_data}[$#{$buff_data}]}[1]", "${$out_index}", 'USER', "$out_line"]);
            # ユーザ出力済("output")をユーザ出力区分へ設定
            $obj->{user_out_kbn} = 'output';
        } else {
            #====================#
            # カレントが処理済行 #
            #====================#
            # 出力pipe情報を検索
            for (my $index=$#{$out_data} ; $index >= 0 ; $index--) {
                # オリジナル行番号をチェックし、登録位置を決める
                if (${${$out_data}[$index]}[0] == ${$obj->{get_num}}[0]) {
                    #------------------------#
                    # オリジナル行番号が一致 #
                    #------------------------#
                    # 登録方法(追加・更新)の振り分け
                    if ($obj->{user_out_kbn} ne 'output') {
                        #･･････････････#
                        # ユーザ未出力 #
                        #･･････････････#
                        # 定型抽出結果をユーザ指定データに置換える
                        ${${$out_data}[$index]}[3] = 'USER';                                  # 出力区分
                        ${${$out_data}[$index]}[4] = "$out_line";                             # 抽出対象データ
                    } elsif ($index == $#{$out_data}) {
                        #･･････････････････････････････････#
                        # バッファ情報(最後)にユーザ出力済 #
                        #･･････････････････････････････････#
                        # 出力pipe情報の最後に行データを追加
                        ${$out_index}++;
                        push(@{$out_data}, ["${${$out_data}[$index]}[0]", "${${$out_data}[$index]}[1]", "${$out_index}", 'USER', "$out_line"]);
                    } else {
                        #･･････････････････････････････････#
                        # バッファ情報(途中)にユーザ出力済 #
                        #･･････････････････････････････････#
                        # 出力pipe情報の途中に行データを挿入
                        ${$out_index}++;
                        splice(@{$out_data}, ($index + 1), 0, ["${${$out_data}[$index]}[0]", "${${$out_data}[$index]}[1]", "${$out_index}", 'USER', "$out_line"]);
                    }
                    # ユーザ出力済("output")をユーザ出力区分へ設定
                    $obj->{user_out_kbn} = 'output';
                    # 出力pipe情報の検索を終了
                    last;
                } elsif (${${$out_data}[$index]}[0] < ${$obj->{get_num}}[0]) {
                    #----------------------------------------------------------------------#
                    # オリジナル行番号を未検出のまま出力pipe情報(オリジナル行番号)を過ぎた #
                    #----------------------------------------------------------------------#
                    # 出力pipe情報の途中に行データを挿入
                    ${$out_index}++;
                    splice(@{$out_data}, $index, 0, ["${$obj->{get_num}}[0]", "${$obj->{get_num}}[1]", "${$out_index}", 'USER', "$out_line"]);
                    # ユーザ出力済("output")をユーザ出力区分へ設定
                    $obj->{user_out_kbn} = 'output';
                    # 出力pipe情報の検索を終了
                    last;
                }
            }
            # 対象データを検出したかチェック
            if ($obj->{user_out_kbn} ne 'output') {
                #--------#
                # 未検出 #
                #--------#
                ${$out_index}++;
                if ($#{$out_data} < 0) {
                    #･･････････････････#
                    # 出力済データなし #
                    #･･････････････････#
                    # 出力pipe情報に行データを追加
                    push(@{$out_data}, ["${$obj->{get_num}}[0]", "${$obj->{get_num}}[1]", "${$out_index}", 'USER', "$out_line"]);
                } else {
                    #････････････････････････#
                    # 後続に出力済データあり #
                    #････････････････････････#
                    # 出力pipe情報の先頭に行データを挿入
                    splice(@{$out_data}, 0, 0, ["${$obj->{get_num}}[0]", "${$obj->{get_num}}[1]", "${$out_index}", 'USER', "$out_line"]);
                }
                # ユーザ出力済("output")をユーザ出力区分へ設定
                $obj->{user_out_kbn} = 'output';
            }
        }
    } elsif ($obj->{get_kbn} eq 'input') {
        #================================================#
        # 入力pipe情報をベースにユーザ先行出力情報へ出力 #
        #================================================#
        # カレントの入力pipe情報(行情報)を取得
        my $get_data = \@{${$in_data}[$obj->{get_index}]};
        # 行データをユーザ先行出力情報の最後に追加
        push(@{$mid_data}, ["${$get_data}[0]", "${$get_data}[1]", "${$get_data}[2]", 'USER', "$out_line"]);
    } else {
        #==================================================#
        # オリジナル情報をベースにユーザ先行出力情報へ出力 #
        #==================================================#
        # 行情報(get行情報(オリジナル行番号、レコードbyte位置、入力行番号、"USER"、行データ)をユーザ先行出力情報の最後に追加
        push(@{$mid_data}, ["${$obj->{get_num}}[0]", "${$obj->{get_num}}[1]", "${$obj->{get_num}}[2]", 'USER', "$out_line"]);
    }
}
###################################################################################################
#   ＜＜ 抽出データ削除 ＞＞                                                                      #
###################################################################################################
sub del_data {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    # 処理 ： 抽出データからカレント行（seekしている場合は、その行）を削除                    #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my ($obj)      = @_;                                                                      # オブジェクト
    my $cond_index = $obj->{cond_index};                                                      # 処理位置
    my $in_data    = \@{${$obj->{pipe_data}}[$cond_index]};                                   # (処理位置の)入力pipe情報
    my $buff_data  = \@{${$obj->{buff_data}}[$cond_index]};                                   # (処理位置の)バッファ情報
    my $mid_data   = \@{${$obj->{mid_data}}[$cond_index]};                                    # (処理位置の)ユーザ先行出力情報
    my $out_data   = \@{${$obj->{pipe_data}}[($cond_index + 1)]};                             # (処理位置の)出力pipe情報
    my $out_index  = \${$obj->{out_index}}[$cond_index];                                      # (処理位置の)出力件数
    
    # get区分をチェックし、削除先を判断
    if ($obj->{get_kbn} eq 'buff') {
        ######################
        # バッファ情報を削除 #
        ######################
        # カレントが最終バッファ情報位置だった場合、削除データ(出力区分="DEL")をバッファ情報の最後へ追加
        if ($obj->{get_index} == $#{$buff_data}) {
            #================================#
            # カレントが最終バッファ情報位置 #
            #================================#
            # バッファ情報の最後に削除データを追加
            push(@{$out_data}, ["${${$buff_data}[$#{$buff_data}]}[0]", '', '', 'DEL', '']);
        } else {
            #====================#
            # カレントが処理済行 #
            #====================#
            # 出力pipe情報を検索
            my $del_flg = '';                                                                 # 削除フラグ（１＝該当行番号検出）
            for (my $index=$#{$out_data} ; $index >= 0 ; $index--) {
                # 削除対象行かチェック
                if (${${$out_data}[$index]}[2] == ${$obj->{get_num}}[2]) {
                    #------------------#
                    # 入力行番号が一致 #
                    #------------------#
                    # 定型抽出による出力かチェック
                    if (${${$out_data}[$index]}[4] eq '' or $index == 0) {
                        #･･････････････#
                        # 定型抽出出力 #
                        #･･････････････#
                        # 該当データを削除
                        splice(@{$out_data}, $index, 1);
                        # 出力pipe情報の検索を終了
                        last;
                    } else {
                        #････････････････#
                        # ユーザ抽出出力 #
                        #････････････････#
                        # 該当行番号検出("1")を削除フラグに設定
                        $del_flg = '1';
                    }
                # 削除フラグが該当行番号検出("1")の場合、該当データを削除
                } elsif ($del_flg eq '1') {
                    #--------------------#
                    # が該当行番号検出済 #
                    #--------------------#
                    splice(@{$out_data}, ($index + 1), 1);
                    # 出力pipe情報の検索を終了
                    last;
                }
            }
        }
        # ユーザ出力済("output")をユーザ出力区分へ設定
        $obj->{user_out_kbn} = 'output';
    } elsif ($obj->{get_kbn} eq 'input') {
        ######################
        # 入力pipe情報を削除 #
        ######################
        # カレント行の削除指示をユーザ先行出力情報の最後に追加
        my $get_data = \@{${$in_data}[$obj->{get_index}]};
        push(@{$mid_data}, ["${$get_data}[0]", '', "${$get_data}[2]", 'DEL', '']);
    } else {
        #========================================#
        # オリジナル情報に該当する行データを削除 #
        #========================================#
        # 行情報(get行情報(オリジナル行番号、""、入力行番号･･･)の削除指示をユーザ先行出力情報の最後に追加
        push(@{$mid_data}, ["${$obj->{get_num}}[0]", '', "${$obj->{get_num}}[2]", 'DEL', '']);
    }
}
###################################################################################################
#   ＜＜ 行末改行コード削除 ＞＞                                                                  #
###################################################################################################
sub cut_last_0a{
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0] = オブジェクト                                                            #
    #         $_[1] = 行データ                                                                #
    # 処理 ： 行末の改行コードを削除                                                          #
    # 返却 ： 行データ                                                                        #
    #-----------------------------------------------------------------------------------------#
    if ((substr $_[0], -1) eq "\n") {
        chop $_[0];
    }
}
###################################################################################################
#   ＜＜ 正規表現指定による行抽出の起点(開始条件)検出 ＞＞                                        #
###################################################################################################
sub get_cond_lr_s {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = オブジェクト                                                           #
    #      ： $_[1]  = カレント行番号                                                         #
    #      ： $_[2]  = 最終行番号                                                             #
    #      ： $_[3]  = 行データ                                                               #
    #      ： $_[4〜]= 抽出条件（正規表現による行抽出）                                       #
    # 処理 ： 終了条件なし）                                                                  #
    #                  ・行番号指定（抽出区分＝"L"）に変換                                    #
    #         終了条件あり）                                                                  #
    #                  ・終了条件が正規表現の場合、開始のみ行番号指定（抽出区分＝"r"）に変換  #
    #                  ・上記以外の場合、行番号指定（抽出区分＝"L"）に変換                    #
    # 返却 ： 変換後抽出条件（行番号指定に変換した抽出条件）                                  #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj       = shift;                                                                    # オブジェクト
    my $line_now  = shift;                                                                    # カレント行番号
    my $line_end  = shift;                                                                    # 最終行番号
    my $line_data = shift;                                                                    # 行データ
    my @add_cond  = ();                                                                       # 変換後抽出条件
    my $in_data   = \@{${$obj->{pipe_data}}[$obj->{cond_index}]};                             # (処理位置の)入力pipe情報
    
    ##################################
    # 正規表現指定を行番号指定に変換 #
    ##################################
    foreach my $cond(@_) {
        #********************************************************************************#
        # ＜抽出条件の詳細＞                                                             #
        # ${$cond}[0] ： "LR"(正規行現による行抽出)                                      #
        # ${$cond}[1] ： 肯定否定区分                                                    #
        # ${$cond}[2] ： 開始条件(抽出条件/開始条件)                                     #
        # ${$cond}[3] ：[終了条件({+|-}範囲/end[-範囲]/終了条件)]                        #
        #     ：                   ：                                                    #
        # ${$cond}[8] ： 否定抽出区分（null＝出力対象外、"0"＝条件検出、"1"＝出力対象）  #
        # ${$cond}[9] ： 暫定否定抽出開始行                                              #
        #********************************************************************************#
        # 抽出条件出力フラグを初期化
        my $cond_flg = '';                                                                   # 抽出条件出力フラグ（"1"＝変換後抽出条件出力済）
        # 行データ(カレント行)に開始条件が含まれているかチェック
        if ("$line_data" =~ /${$cond}[2]/) {
            #==============#
            # 開始条件あり #
            #==============#
            # 肯定否定かチェック
            if (${$cond}[1] eq '') {
                #------#
                # 肯定 #
                #------#
                # ＜終了条件チェック＞
                if (${$cond}[3] eq '') {
                    #･･････････････#
                    # 終了条件なし #
                    #･･････････････#
                    # 行番号指定抽出("L")を変換後抽出条件へ追加
                    push(@add_cond, ['L', '', "$line_now", "$line_now", "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                } elsif (${$cond}[3] =~ /^end(-\d+)*$/ ) {
                    #･････････････････････････････#
                    # 最終行からの範囲指定("end") #
                    #･････････････････････････････#
                    # 行番号指定抽出("L")を変換後抽出条件へ追加
                    my $cond3 = $1;
                    if ($line_end > 0) {
                        $cond3 = $cond3 + $line_end;
                        if ($line_now < $cond3) {
                            push(@add_cond, ['L', '', "$line_now", "$cond3", "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                        } else {
                            push(@add_cond, ['L', '', "$cond3", "$line_now", "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                        }
                    } else {
                        push(@add_cond, ['L', '', "$line_now", "${$cond}[3]", "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                    }
                } elsif (${$cond}[3] =~ /^\+\d+$/ ) {
                    #･･････････････････････････････#
                    # 後続範囲指定(プラス付き数字) #
                    #･･････････････････････････････#
                    # 行番号指定抽出("L")を変換後抽出条件へ追加
                    push(@add_cond, ['L', '', "$line_now", ($line_now + ${$cond}[3]), "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                } elsif (${$cond}[3] =~ /^-\d+$/ ) {
                    #････････････････････････････････#
                    # 先行範囲指定(マイナス付き数字) #
                    #････････････････････････････････#
                    # 処理なし
                } else {
                    #･･････････････#
                    # 正規表現指定 #
                    #･･････････････#
                    # 開始のみ行番号指定("r")を変換後抽出条件へ追加
                    push(@add_cond, ['r', '', "$line_now", "${$cond}[3]", "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                }
            } else {
                #------#
                # 否定 #
                #------#
                # ＜終了条件チェック＞
                if (${$cond}[3] eq '') {
                    #･･････････････#
                    # 終了条件なし #
                    #･･････････････#
                    # 否定抽出出力対象の場合、行番号指定抽出("L")を変換後抽出条件へ追加
                    if (${$cond}[8] eq '1') {
                        push(@add_cond, ['L', '', "${$cond}[9]", ($line_now - 1), "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                    }
                    ${$cond}[9] = $line_now + 1;
                } elsif (${$cond}[3] =~ /^end(-\d+)*$/ ) {
                    #･････････････････････････････#
                    # 最終行からの範囲指定("end") #
                    #･････････････････････････････#
                    my $cond3 = $1;
                    if (${$cond}[8] eq '1') {
                        if ($line_end eq 0 or ($line_end + $cond3) gt ${$cond}[9]) {
                            push(@add_cond, ['L', '', "${$cond}[9]", ($line_now - 1), "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                        }
                        ${$cond}[9] = "x";
                    }
                    if ($line_end ne 0 and ($line_end + $cond3) gt ${$cond}[9]) {
                        ${$cond}[9] = $line_end + 1;
                        if ($cond3 ne '') {
                            ${$cond}[9] += $cond3;
                        }
                    }
                } elsif (${$cond}[3] =~ /^\+\d+$/ ) {
                    #･･････････････････････････････#
                    # 後続範囲指定(プラス付き数字) #
                    #･･････････････････････････････#
                    # 否定抽出出力対象の場合、行番号指定抽出("L")を変換後抽出条件へ追加
                    if (${$cond}[8] eq '1') {
                        push(@add_cond, ['L', '', "${$cond}[9]", ($line_now - 1), "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                    }
                    ${$cond}[9] = $line_now + ${$cond}[3] + 1;
                } elsif (${$cond}[3] =~ /^-\d+$/ ) {
                    #････････････････････････････････#
                    # 先行範囲指定(マイナス付き数字) #
                    #････････････････････････････････#
                    # 処理なし
                } else {
                    #･･････････････#
                    # 正規表現指定 #
                    #･･････････････#
                    # 否定抽出出力対象の場合、開始のみ行番号指定("r")を変換後抽出条件へ追加
                    if (${$cond}[8] eq '1') {
                        push(@add_cond, ['L', '', "${$cond}[9]", ($line_now - 1), "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                    }
                }
                # 否定抽出区分を初期化
                ${$cond}[8] = '';
            }
            # 変換後抽出条件出力済("1")を抽出条件出力フラグへ設定
            $cond_flg = '1';
        }
        # 終了条件がマイナス付き数字だった場合、先行行に開始条件が含まれているかチェック
        if (${$cond}[3] =~ /^-\d+$/ and ${$in_data}[(${$cond}[3] * -1) - 1] ne 'Data_Extraction_END' and ${${$in_data}[(${$cond}[3] * -1) - 1]}[4] =~ /${$cond}[2]/) {
            # 肯定否定かチェック
            if (${$cond}[1] eq '') {
                #------#
                # 肯定 #
                #------#
                # 行番号指定抽出("L")を変換後抽出条件へ追加
                my $cond_end   = $line_now + (${$cond}[3] * -1);
                my $cond_start = $cond_end + ${$cond}[3];
                if ($cond_start < 1) { $cond_start = 1; }
                push(@add_cond, ['L', '', "$cond_start", "$cond_end", "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
            } else {
                #------#
                # 否定 #
                #------#
                # 否定抽出出力対象の場合、行番号指定抽出("L")を変換後抽出条件へ追加
                if (${$cond}[8] eq '1') {
                    push(@add_cond, ['L', '', "${$cond}[9]", ($line_now - 1), "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                }
                # 暫定否定抽出開始行を再設定
                ${$cond}[9] = ($line_now + (${$cond}[3] * -1) + 1);
                # 否定抽出区分を初期化
                ${$cond}[8] = '';
            }
            # 変換後抽出条件出力済("1")を抽出条件出力フラグへ設定
            $cond_flg = '1';
        } elsif ( $line_now == 1 and ${$cond}[3] =~ /^-\d+$/ and ${$in_data}[(${$cond}[3] * -1) - 1] ne 'Data_Extraction_END') {
            my $set = '';
            if ($line_data =~ /${$cond}[2]/) {
                $set = -1;
            } else {
                for (my $i=0 ; $i <= ((${$cond}[3] * -1) - 1) and $set eq ''; $i++) {
                    if (${${$in_data}[$i]}[4] =~ /${$cond}[2]/) { $set = $i; }
                }
            }
            if ($set ne '' ) {
                # 肯定否定かチェック
                if (${$cond}[1] eq '') {
                    #------#
                    # 肯定 #
                    #------#
                    # 行番号指定抽出("L")を変換後抽出条件へ追加
                    my $cond_end   = $line_now + $set + 1;
                    my $cond_start = $cond_end + ${$cond}[3];
                    if ($cond_start < 1) { $cond_start = 1; }
                    push(@add_cond, ['L', '', "$cond_start", "$cond_end", "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                } else {
                    #------#
                    # 否定 #
                    #------#
                    # 否定抽出出力対象の場合、行番号指定抽出("L")を変換後抽出条件へ追加
                    if (($line_now - 1) > 0) {
                        push(@add_cond, ['L', '', "${$cond}[9]", ($line_now - 1), "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                    }
                    # 暫定否定抽出開始行を再設定
                    ${$cond}[9] = $line_now + $set + 1;
                    # 否定抽出区分を初期化
                    ${$cond}[8] = '';
                }
                # 変換後抽出条件出力済("1")を抽出条件出力フラグへ設定
                $cond_flg = '1';
            }
        }
        # 変換後抽出条件が未出力かチェック
        if ($cond_flg eq '') {
            #========#
            # 未出力 #
            #========#
            # 抽出条件の状態をチェックし、否定抽出区分と暫定否定抽出開始行を設定
            if (${$cond}[8] eq '') {
                #------------#
                # 出力対象外 #
                #------------#
                if (${$cond}[3] eq '' or ${$cond}[3] =~ /^[\+-]\d+$/ or ${$cond}[3] =~ /^end(-\d+)*$/) {
                    #････････････････････････････････････････････････････････････････････････#
                    # 終了条件無し、又はプラスマイナス付き数字指定、又は最終行からの範囲指定 #
                    #････････････････････････････････････････････････････････････････････････#
                    # 暫定否定抽出開始行がカレント行以前を指す場合、出力対象("1")を否定抽出区分に設定
                    if (${$cond}[9] eq '' or (${$cond}[9] =~ /^[0-9]+$/ and ${$cond}[9] <= $line_now)) {
                        ${$cond}[8] = '1';
                    }
                    if ($line_end != 0 and ${$cond}[3] =~ /^end(-\d+)*$/) {
                        my $cond3 = 0;
                        if (${$cond}[3] =~ /^end(-\d+)*$/) {
                            $cond3 = $1;
                        }
                        if (${$cond}[1] eq '') {
                            if (($line_end + $cond3) le $line_now) {
                                # 開始のみ行番号指定("r")を変換後抽出条件へ追加
                                push(@add_cond, ['r', '', "$line_now", "${$cond}[2]", "${$cond}[4]", "${$cond}[5]", "${$cond}[6]", "${$cond}[7]"]);
                            }
                        } else {
                            if (${$cond}[9] eq 'x' and ($line_end + $cond3) lt $line_now and (grep{$_ ne 'Data_Extraction_END' and ${$_}[4] =~ /${$cond}[2]/}@{$in_data}) eq 0) {
                                ${$cond}[8] = '1';
                                ${$cond}[9] = $line_now;
                            }
                        }
                    }
                } else {
                    #･･････････････#
                    # 正規表現指定 #
                    #･･････････････#
                    # 終了条件が行データに存在する場合、否定抽出区分と暫定否定抽出開始行を設定
                    if ($line_data =~ /${$cond}[3]/) {
                        # 条件検出("0")を否定抽出区分へ設定
                        ${$cond}[8] = '0';
                        # 次行の行番号を暫定否定抽出開始行へ設定
                        ${$cond}[9] = ($line_now + 1);
                    }
                }
            } elsif (${$cond}[8] eq 0) {
                my $cond3 = 0;
                if (${$cond}[3] =~ /^end(-\d+)*$/) { $cond3 = $1; }
                #----------#
                # 条件検出 #
                #----------#
                ${$cond}[8] = '1';
                if ($line_end == 0 or ($line_end != 0 and
                  ((${$cond}[1] eq '' and ($line_end + $cond3) le $line_now) or
                   (${$cond}[1] ne '' and ($line_end + $cond3) gt $line_now))))  {
                    ${$cond}[9] = $line_now;
                }
            } elsif (${$cond}[9] eq 'x') {
                my $cond3 = 0;
                if (${$cond}[3] =~ /^end(-\d+)*$/) { $cond3 = $1; }
                if ($line_end != 0 and ($line_end + $cond3) ge $line_now) {
                    ${$cond}[9] = ($line_end + $cond3 + 1);
                }
            }
        }
    }
    
    ########################
    # 変換後抽出条件を返却 #
    ########################
    return @add_cond;
}
###################################################################################################
#   ＜＜ 正規表現指定による行抽出の範囲(終了条件)検出 ＞＞                                        #
###################################################################################################
sub get_cond_lr_e {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = カレント行番号                                                         #
    #      ： $_[1〜]= 抽出条件                                                               #
    # 処理 ： 正規表現（終了条件）を行番号指定に変換                                          #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $line_now = shift;                                                                     # カレント行番号
    
    ##################################
    # 正規表現指定を行番号指定に変換 #
    ##################################
    foreach my $cond(@_) {
        ${$cond}[0] = 'L';
        ${$cond}[3] = $line_now;
    }
}
###################################################################################################
#   ＜＜ 最終行指定による行抽出の起点(抽出開始条件)検出 ＞＞                                      #
###################################################################################################
sub get_cond_l_s {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 最終行番号                                                             #
    #      ： $_[1〜]= 抽出条件（最終行指定"E"による行抽出）                                  #
    # 処理 ： 最終行指定を行番号指定に変換                                                    #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $line_end = shift;                                                                     # 最終行番号
    
    ################################
    # 最終行指定を行番号指定に変換 #
    ################################
    foreach my $cond(@_) {
        #********************************************************************************#
        # ＜抽出条件の詳細＞                                                             #
        # ${$cond}[0] ： "L"(行番号による行抽出)                                         #
        # ${$cond}[1] ： 肯定否定区分                                                    #
        # ${$cond}[2] ： "end"(最終行指定)                                               #
        # ${$cond}[3] ：[終了条件(プラスマイナス範囲/E/終了行番号)]                      #
        #********************************************************************************#
        # 開始行番号を算出
        if (${$cond}[2] =~ /^end(-\d+)$/) {
            ${$cond}[2] = $line_end + $1;
        } else {
            ${$cond}[2] = $line_end;
        }
        # 抽出終了条件をチェックし、終了行番号を設定
        if (${$cond}[3] eq '') {
            #==========#
            # 指定なし #
            #==========#
            # 最終行番号を終了行番号へ設定
            ${$cond}[3] = ${$cond}[2];
        } elsif (${$cond}[3] =~ /^end(-\d+)*$/) {
            #=============================#
            # 最終行からの範囲指定("end") #
            #=============================#
            # 終了行番号を算出
            my $cond3 = $1;
            ${$cond}[3] = $line_end;
            if ($cond3 ne '') {
                ${$cond}[3] += $cond3;
            }
            # 開始行番号より終了行番号が小さい場合、入替える
            if (${$cond}[2] > ${$cond}[3]) {
                my $temp_su = ${$cond}[2];
                ${$cond}[2] = ${$cond}[3];
                ${$cond}[3] = $temp_su;
            }
        } elsif (${$cond}[3] =~ /^\d+$/) {
            #============#
            # 行番号指定 #
            #============#
            # 開始行番号より終了行番号が小さい場合、入替える
            if (${$cond}[2] > ${$cond}[3]) {
                my $temp_su = ${$cond}[2];
                ${$cond}[2] = ${$cond}[3];
                ${$cond}[3] = $temp_su;
            }
        } elsif (${$cond}[3] =~ /^\+\d+$/) {
            #------------------------------#
            # 後続範囲指定(プラス付き数字) #
            #------------------------------#
            # 終了行番号を算出
            ${$cond}[3] += ${$cond}[2];
        } elsif (${$cond}[3] =~ /^-\d+$/) {
            #--------------------------------#
            # 先行範囲指定(マイナス付き数字) #
            #--------------------------------#
            # 開始行番号と終了行番号を算出
            my $temp_su  = ${$cond}[2];
            ${$cond}[2] += ${$cond}[3];
            ${$cond}[3]  = $temp_su;
        }
    }
}
###################################################################################################
#   ＜＜ 最終行指定による行抽出の範囲(抽出終了条件)検出 ＞＞                                      #
###################################################################################################
sub get_cond_l_e {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 最終行番号                                                             #
    #      ： $_[1〜]= 抽出条件（最終行指定"end"による行抽出）                                #
    # 処理 ： 最終行指定を行番号指定に変換                                                    #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $line_end = shift;                                                                     # 最終行番号
    
    ################################
    # 最終行指定を行番号指定に変換 #
    ################################
    foreach my $cond(@_) {
        #********************************************************************************#
        # ＜抽出条件の詳細＞                                                             #
        # ${$cond}[0] ： "L"(行番号による行抽出)                                         #
        #     ：                   ：                                                    #
        # ${$cond}[3] ： "end"(最終行指定)                                               #
        #********************************************************************************#
        if (${$cond}[3] =~ /^end(-\d+)$/) {
            ${$cond}[3] = $line_end + $1;
        } else {
            ${$cond}[3] = $line_end;
        }
        # 開始行番号より終了行番号が小さい場合、入替える
        if (${$cond}[2] > ${$cond}[3]) {
            my $temp_su = ${$cond}[2];
            ${$cond}[2] = ${$cond}[3];
            ${$cond}[3] = $temp_su;
        }
    }
}
###################################################################################################
#   ＜＜ ユーザ抽出 ＞＞                                                                          #
###################################################################################################
sub get_cond_user {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = オブジェクト                                                           #
    #      ： $_[1]  = 行データ                                                               #
    #      ： $_[1〜]= ユーザー引数                                                           #
    # 処理 ： ユーザ関数の呼出し                                                              #
    # 返却 ： ユーザ抽出結果（抽出対象区分）                                                  #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $obj              = shift;                                                             # オブジェクト
    my $line_data        = shift;                                                             # 行データ
    my $extraction_data  = undef;                                                             # ユーザ抽出結果（抽出対象区分）
    $obj->{user_out_kbn} = '';                                                                # ユーザ出力区分
    my $buff_data        = \@{${$obj->{buff_data}}[$obj->{cond_index}]};                      # (処理位置の)バッファ情報
    
    ##############
    # ユーザ抽出 #
    ##############
    foreach my $user(@_) {
        # ＜seek情報の設定＞
        $obj->{seek_kbn}          = 'buff';                                                   # seek区分←バッファ情報("buff")
        @{$obj->{seek_num}}[0..2] = @{${$buff_data}[$#{$buff_data}]};                         # seek行情報←バッファ情報(オリジナル行番号、レコードbyte位置、入力行番号)
        $obj->{seek_index}        = $#{$buff_data};                                           # seek位置←バッファ情報数(カレント情報位置)
        # ＜get情報の設定＞
        $obj->{get_kbn}           = $obj->{seek_kbn};                                         # get区分
        @{$obj->{get_num}}        = @{$obj->{seek_num}};                                      # get行情報
        $obj->{get_index}         = $obj->{seek_index};                                       # get位置
        # 最終バッファ情報のレコードbyte位置へ移動
        seek EXTRACTION_FILE, (${$obj->{get_num}}[1]), 0 or "$!($obj->{in_name})";
        
        #==================#
        # ユーザ関数呼出し #
        #==================#
        # ユーザ関数呼出し時の構文生成
        my $user_sub = '&'.${$user}[1].'('."\'$line_data\'";
        for (my $index1=2 ; $index1 <= $#{$user}; $index1++) {
            $user_sub .= ', "'.${$user}[$index1].'"';
        }
        $user_sub .= ');';
        # ユーザ関数の呼出し、結果取得
        $extraction_data = "$extraction_data" | eval($user_sub);
    }
    
    ########################################
    # ユーザ抽出結果（抽出対象区分）を返却 #
    ########################################
    return "$extraction_data";
}
###################################################################################################
#   ＜＜ 行・列抽出 ＞＞                                                                          #
###################################################################################################
sub get_cond_lc {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 行データ                                                               #
    #      ： $_[1]  = 配列化した行データの配列数                                             #
    #      ： $_[2〜]= 抽出条件（処理行の行・ブロック抽出）                                   #
    # 処理 ： 行抽出、列抽出（列番号指定による列抽出、正規表現指定による列抽出）              #
    # 返却 ： 抽出結果（抽出対象区分）                                                        #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $line_data   = shift;                                                                  # 行データ
    my $line_col_su = shift;                                                                  # 配列化した行データの配列数
    my $extraction_data = '';
    
    # 列抽出条件の有無をチェック
    if ((grep{${$_}[4] eq ''}@_) > 0) {
        #========#
        # 行抽出 #
        #========#
        $extraction_data = '1';
    } else {
        #========#
        # 列抽出 #
        #========#
        # 列番号指定による列抽出
        $extraction_data = &get_cond_c($line_col_su, grep{${$_}[4] eq 'C'}@_);
        # 正規表現指定による列抽出
        $extraction_data = "$extraction_data" | &get_cond_cr("$line_data", $line_col_su, grep{${$_}[4] eq 'CR'}@_);
    }
    
    # 列抽出結果を返却
    return "$extraction_data";
}
###################################################################################################
#   ＜＜ 列番号指定による列抽出 ＞＞                                                              #
###################################################################################################
sub get_cond_c {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 配列化した行データの配列数                                             #
    #      ： $_[1〜]= 抽出条件（列番号による列抽出）                                         #
    # 処理 ： 列番号指定による列抽出                                                          #
    # 返却 ： 列抽出結果（抽出対象区分）                                                      #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $col_su          = shift;                                                              # 配列化した行データの配列数
    my $col_start       = undef;                                                              # (列抽出の)抽出開始列
    my $col_end         = undef;                                                              # (列抽出の)抽出終了列
    my $col_add         = undef;                                                              # (列抽出の)cond判定位置
    my $extraction_data = '0' x $col_su;                                                      # 列抽出結果（抽出対象区分）
    
    ##########
    # 列抽出 #
    ##########
    foreach my $cond(@_) {
        #********************************************************************************#
        # ＜抽出条件の詳細＞                                                             #
        # 列抽出時）                                                                     #
        # ${$cond}[0] ： "C"(列番号による列抽出)                                         #
        # ${$cond}[1] ： 肯定否定区分                                                    #
        # ${$cond}[2] ： 開始条件(列番号/開始列番号/end[-行数])                          #
        # ${$cond}[3] ：[終了条件({+|-}範囲/end[-行数]/終了列番号)]                      #
        #     ：                   ：                                                    #
        # ------------------------------------------------------------------------------ #
        # 行列抽出時）                                                                   #
        #     ：                   ：                                                    #
        # ${$cond}[4] ： "C"(列番号による列抽出)                                         #
        # ${$cond}[5] ： 肯定否定区分                                                    #
        # ${$cond}[6] ： 開始条件(列番号/開始列番号/end[-行数])                          #
        # ${$cond}[7] ：[終了条件({+|-}範囲/end[-行数]/終了列番号)]                      #
        #     ：                   ：                                                    #
        #********************************************************************************#
        #====================#
        # cond判定位置の設定 #
        #====================#
        # 抽出判定対象をチェックし、cond判定位置を設定
        if (${$cond}[0] eq 'C') {
            #--------#
            # 列抽出 #
            #--------#
            $col_add = 0;
        } else {
            #----------#
            # 行列抽出 #
            #----------#
            $col_add = 4;
        }
        
        #==================#
        # 抽出開始列を設定 #
        #==================#
        # 開始条件の指定方法をチェック
        if (${$cond}[(2 + $col_add)] =~ /^end(-\d+)*$/) {
            #-----------------------------#
            # 最終列からの範囲指定("end") #
            #-----------------------------#
            my $cond2 = $1;
            $col_start = $col_su;
            if ($cond2 ne '') {
                $col_start += $cond2;
            }
        } else {
            #------------#
            # 列番号指定 #
            #------------#
            $col_start = ${$cond}[(2 + $col_add)];
        }
        
        #==================#
        # 抽出終了列を設定 #
        #==================#
        # 終了条件の指定方法をチェック
        if (${$cond}[(3 + $col_add)] eq '') {
            #--------------#
            # 範囲指定なし #
            #--------------#
            $col_end = $col_start;
        } elsif (${$cond}[(3 + $col_add)] =~ /^end(-\d+)*$/) {
            #-----------------------------#
            # 最終列からの範囲指定("end") #
            #-----------------------------#
            my $cond3 = $1;
            if ($cond3 eq '') {
                if ($col_start <= $col_su) {
                    $col_end = $col_su;
                } else {
                    $col_end   = $col_start;
                    $col_start = $col_su;
                }
            } else {
                if ($col_start <= ($col_su + $cond3)) {
                    $col_end = $col_su + $cond3;
                } else {
                    $col_end   = $col_start;
                    $col_start = $col_su + $cond3;
                }
            }
        } elsif (${$cond}[(3 + $col_add)] =~ /^\-(\d+)$/) {
            #--------------------------------#
            # 先行範囲指定(マイナス付き数字) #
            #--------------------------------#
            $col_end   = $col_start;
            $col_start = $col_start + ${$cond}[(3 + $col_add)];
        } elsif (${$cond}[(3 + $col_add)] =~ /^\+(\d+)$/) {
            #------------------------------#
            # 後続範囲指定(プラス付き数字) #
            #------------------------------#
            $col_end   = $col_start + ${$cond}[(3 + $col_add)];
        } elsif (${$cond}[(2 + $col_add)] <= ${$cond}[(3 + $col_add)]) {
            #----------------#
            # 後続列番号指定 #
            #----------------#
            $col_end   = ${$cond}[(3 + $col_add)];
        } else {
            #----------------#
            # 先行列番号指定 #
            #----------------#
            $col_end   = $col_start;
            $col_start = ${$cond}[(3 + $col_add)];
        }
        
        #==================#
        # 抽出対象列を設定 #
        #==================#
        if ($col_start < 0) {$col_start = 0}
        if ($col_end   < 0) {$col_end   = 0}
        for (my $index2=1; $index2 <= $col_su; $index2++) {
            # 肯定否定区分と条件範囲をチェックし、抽出対象列を設定
            if ((${$cond}[(1 + $col_add)] eq '' and $index2 >= $col_start and $index2 <= $col_end) or (${$cond}[(1 + $col_add)] ne '' and ($index2 < $col_start or $index2 > $col_end))) {
                substr($extraction_data, $index2, 1) = '1';
            }
        }
    }
    
    ####################
    # 列抽出結果を返却 #
    ####################
    return "$extraction_data";
}
###################################################################################################
#   ＜＜ 正規表現指定による列抽出 ＞＞                                                            #
###################################################################################################
sub get_cond_cr {
    #-----------------------------------------------------------------------------------------#
    # 引数 ： $_[0]  = 行データ                                                               #
    #      ： $_[1]  = 配列化した行データの配列数                                             #
    #      ： $_[1〜]= 抽出条件（正規表現による列抽出）                                       #
    # 処理 ： 正規表現指定による列抽出                                                        #
    # 返却 ： 列抽出結果（抽出対象区分）                                                      #
    #-----------------------------------------------------------------------------------------#
    ############
    # 変数定義 #
    ############
    my $in_line         = shift;                                                              # 行データ
    my $col_su          = shift;                                                              # 配列化した行データの配列数
    my $col_start       = undef;                                                              # (列抽出の)抽出開始列
    my $col_end         = undef;                                                              # (列抽出の)抽出終了列
    my $col_add         = undef;                                                              # (列抽出の)cond判定位置
    my $check_key1      = undef;                                                              # (列抽出の)開始判定キー
    my $check_key2      = undef;                                                              # (列抽出の)終了判定キー
    my $extraction_data = '0' x $col_su;                                                      # 列抽出結果（抽出対象区分）
    
    ##########
    # 列抽出 #
    ##########
    foreach my $cond(@_) {
        #********************************************************************************#
        # ＜抽出条件の詳細＞                                                             #
        # 列抽出時）                                                                     #
        # ${$cond}[0] ： "CR"(正規行現による列抽出)                                      #
        # ${$cond}[1] ： 肯定否定区分                                                    #
        # ${$cond}[2] ： 開始条件(抽出条件/開始条件)                                     #
        # ${$cond}[3] ：[終了条件({+|-}範囲/end[-範囲]/終了条件)]                        #
        #     ：                   ：                                                    #
        # ------------------------------------------------------------------------------ #
        # 行列抽出時）                                                                   #
        #     ：                   ：                                                    #
        # ${$cond}[4] ： "CR"(正規行現による列抽出)                                      #
        # ${$cond}[5] ： 肯定否定区分                                                    #
        # ${$cond}[6] ： 開始条件(抽出条件/開始条件)                                     #
        # ${$cond}[7] ：[終了条件({+|-}範囲/end[-範囲]/終了条件)]                        #
        #     ：                   ：                                                    #
        #********************************************************************************#
        #============================#
        # 列抽出判定用行データの設定 #
        #============================#
        # 行データを列抽出判定用行データへ設定
        my $line_data = "$in_line";
        
        #====================#
        # cond判定位置の設定 #
        #====================#
        # 抽出判定対象をチェックし、cond判定位置を設定
        if (${$cond}[0] eq 'CR') {
            #--------#
            # 列抽出 #
            #--------#
            $col_add = 0;
        } else {
            #----------#
            # 行列抽出 #
            #----------#
            $col_add = 4;
        }
        
        #==========================#
        # 開始条件・終了条件の補正 #
        #==========================#
        my $col_s = 0;
        my $col_e = 0;
        # 処理中不要となる記述を削除
        ${$cond}[(2 + $col_add)] =~  s/^\\s\*|^\\,\*|^,\*|^\[\\s\]\*|^\[\\,\]\*|^\[,\]\*|^\[\\,\\s\]\*|^\[,\\s\]\*|^\[\\s\\,\]\*|^\[\\s,\]\*//;
        ${$cond}[(2 + $col_add)] =~  s/^(\[.*)\\s(.*\]\*)/$1$2/;
        ${$cond}[(2 + $col_add)] =~  s/^(\[.*)\\,(.*\]\*)/$1$2/;
        ${$cond}[(2 + $col_add)] =~  s/^(\[.*),(.*\]\*)/$1$2/;
        if (${$cond}[(3 + $col_add)] ne '' and ${$cond}[(3 + $col_add)] !~ /^[\+-]\d+$/ and ${$cond}[(3 + $col_add)] !~ /^end(-\d+)*$/) {
            ${$cond}[(3 + $col_add)] =~  s/^\\s\*|^\\,\*|^,\*|^\[\\s\]\*|^\[\\,\]\*|^\[,\]\*|^\[\\,\\s\]\*|^\[,\\s\]\*|^\[\\s\\,\]\*|^\[\\s,\]\*//;
            ${$cond}[(3 + $col_add)] =~  s/^(\[.*)\\s(.*\]\*)/$1$2/;
            ${$cond}[(3 + $col_add)] =~  s/^(\[.*)\\,(.*\]\*)/$1$2/;
            ${$cond}[(3 + $col_add)] =~  s/^(\[.*),(.*\]\*)/$1$2/;
        }
        
        #==============#
        # 変数を初期化 #
        #==============#
        my @cond_c_new = ();                                                                  # 条件範囲
        $col_start = 0;                                                                       # (列抽出の)開始位置
        $col_end   = 0;                                                                       # (列抽出の)終了位置
        
        #============#
        # 列抽出判定 #
        #============#
        # 列抽出が完了するまで抽出（無限ループ）
        while (1) {
            #----------------#
            # 開始条件の補正 #
            #----------------#
            my $key = undef;
            # 開始条件を列抽出判定用行データから取得
            if ("$line_data" =~ /(${$cond}[(2 + $col_add)])/) {
                $key = $1;
            }
            $check_key1 = '';
            # 左端が区切り文字でなければ、区切り文字(正規表現)を追加
            if ($key !~ /^\s|^\,/) {
                if (${$cond}[(2 + $col_add)] !~ /^\^/) {
                    $check_key1 .= '[^\s\,]*';
                } else {
                    $check_key1 .= '(^|[\s\,]+)';
                }
            }
            my $set_key = ${$cond}[(2 + $col_add)];
            if (${$cond}[(2 + $col_add)] =~ /^\^/) {
                $set_key =~ s/^\^//;
            }
            if (${$cond}[(2 + $col_add)] =~ /\$$/) {
                $set_key =~ s/\$$//;
            }
            $check_key1 .= $set_key;
            # 右端が区切り文字でなければ、区切り文字(正規表現)を追加
            if ($key !~ /\s$|\,$|\n$|\$$/) {
                if (${$cond}[(2 + $col_add)] !~ /\$$/) {
                    $check_key1 .= '[^\s\,\n]*';
                } else {
                    $check_key1 .= '([\s\,\n]+|$)';
                }
            }
            
            #--------------------#
            # 開始条件をチェック #
            #--------------------#
            # 列抽出判定用行データが開始条件を含んでいるかチェック
            if ("$line_data" !~ /($check_key1.*)/) {
                #･･････････････#
                # 開始条件なし #
                #･･････････････#
                # 列抽出判定処理の繰り返し(while)を抜ける
                last;
            }
            
            #------------------------------#
            # 次回チェック対象データを退避 #
            #------------------------------#
            my $next_data = $1;
            $next_data =~ s/$check_key1//;
            $next_data =~  s/^[\s\,]*//;
            $next_data =~  s/[\s\,]*$//;
            #----------------#
            # 終了条件の補正 #
            #----------------#
            $check_key2 = '';
            # 正規表現指定の終了条件があるかチェック
            if (${$cond}[(3 + $col_add)] ne '' and ${$cond}[(3 + $col_add)] !~ /^[\+-]\d+$/ and ${$cond}[(3 + $col_add)] !~ /^end(-\d+)*$/) {
                #････････････････････････････#
                # 正規表現指定の終了条件あり #
                #････････････････････････････#
                # 終了条件を列抽出判定用行データから取得
                if ("$line_data" =~ /(${$cond}[(3 + $col_add)])/) {
                    $key = $1;
                }
                # 左端が区切り文字でなければ、区切り文字(正規表現)を追加
                if ($key !~ /^\s|^\,/) {
                    if (${$cond}[(3 + $col_add)] !~ /^\^/) {
                        $check_key2 .= '[^\s\,]*';
                    } else {
                        $check_key2 .= '(^|[\s\,]+)';
                    }
                }
                my $set_key = ${$cond}[(3 + $col_add)];
                if (${$cond}[(3 + $col_add)] =~ /^\^/) {
                    $set_key =~ s/^\^//;
                }
                if (${$cond}[(3 + $col_add)] =~ /\$$/) {
                    $set_key =~ s/\$$//;
                }
                $check_key2 .= $set_key;
                # 右端が区切り文字でなければ、区切り文字(正規表現)を追加
                if ($key !~ /\s$|\,$|\n$|\$$/) {
                    if (${$cond}[(3 + $col_add)] !~ /\$$/) {
                        $check_key2 .= '[^\s\,]*';
                    } else {
                        $check_key2 .= '([\s\,]+|$)';
                    }
                }
            }
            
            #------------------#
            # 抽出開始列を設定 #
            #------------------#
            my @split_out1 = split /($check_key1)/, $line_data, 3;
            my $split_out1_add = 0;
            if ($split_out1[0] =~ /^\s+\,*\s*$|^\,+\s*$/) {
            } else {
                if ($split_out1[0] =~ /^\s|^\,/ and $split_out1[0] =~ /\s+$|\,+$/) {
                    $split_out1_add--;
                }
            }
            $col_start += (&get_col_data("$split_out1[0]")) + $split_out1_add + 1;
            
            #--------------------------#
            # 次回チェック開始列を算出 #
            #--------------------------#
            my $col_split_out1 = &get_col_data("$split_out1[1]");
            my $col_end2 = $col_start + $col_split_out1 - 1;
            
            #------------------#
            # 抽出終了列を設定 #
            #------------------#
            # 終了条件の指定方法をチェック
            if (${$cond}[(3 + $col_add)] eq '') {
                #･･････････････#
                # 範囲指定なし #
                #･･････････････#
                $col_end = $col_end2;
            } elsif (${$cond}[(3 + $col_add)] =~ /^end(-\d+)*$/) {
                #-----------------------------#
                # 最終列からの範囲指定("end") #
                #-----------------------------#
                my $cond3 = $1;
                if ($cond3 eq '') {
                    if ($col_start <= $col_su) {
                        $col_end = $col_su;
                    } else {
                        $col_end   = $col_start;
                        $col_start = $col_su;
                    }
                } else {
                    if ($col_start <= ($col_su + $cond3)) {
                        $col_end = $col_su + $cond3;
                    } else {
                        $col_end   = $col_start;
                        $col_start = $col_su + $cond3;
                    }
                }
            } elsif (${$cond}[(3 + $col_add)] =~ /^\+(\d+)$/) {
                #･･････････････････････････････#
                # 後続範囲指定(プラス付き数字) #
                #･･････････････････････････････#
                $col_end = $col_end2 + ${$cond}[(3 + $col_add)];
            } elsif (${$cond}[(3 + $col_add)] =~ /^-(\d+)$/) {
                #････････････････････････････････#
                # 先行範囲指定(マイナス付き数字) #
                #････････････････････････････････#
                $col_start += ${$cond}[(3 + $col_add)];
                $col_end    = $col_end2;
            } else {
                #････････････#
                # 正規表指定 #
                #････････････#
                if ("$next_data" =~ /($check_key2.*)/) {
                    my $back_data = $1;
                    $back_data =~ s/$check_key2//;
                    $back_data =~  s/^[\s\,]*//;
                    $back_data =~  s/[\s\,]*$//;
                    $col_end = $col_su - (&get_col_data("$back_data"));
                } else {
                    $col_end = $col_su;
                    my @split_out2 = &get_col_data("$line_data");
                    for (my $index4=($col_start - 1); $index4 <= ($col_end2 - 1); $index4++) {
                        if ("$split_out2[$index4]" =~ /($check_key2)/) {
                            $col_end = $col_end2;
                        }
                    }
                }
            }
            
            #----------------#
            # 条件範囲を設定 #
            #----------------#
            if ($col_start < 0) {$col_start = 0}
            if ($col_end   < 0) {$col_end   = 0}
            # 抽出開始列から抽出終了列が示す列に対してチェック
            for (my $index3=$col_start; $index3 <= $col_end; $index3++) {
                # 条件範囲内("1")を設定
                $cond_c_new[$index3] = '1';
            }
            
            #------------------------#
            # 次回チェック情報を設定 #
            #------------------------#
            $col_start = $col_end2;                                                           # (列抽出の)開始位置
            $line_data = "$next_data";                                                        # 列抽出判定用行データ
        }
        
        #==================#
        # 抽出対象列を設定 #
        #==================#
        for (my $index2=1; $index2 <= $col_su; $index2++) {
            # 肯定否定区分と条件範囲をチェックし、抽出対象列を設定
            if ((${$cond}[(1 + $col_add)] eq '' and $cond_c_new[$index2] eq '1') or (${$cond}[(1 + $col_add)] ne '' and $cond_c_new[$index2] eq '')) {
                substr($extraction_data, $index2, 1) = '1';
            }
        }
    }
    
    ####################
    # 列抽出結果を返却 #
    ####################
    return "$extraction_data";
}
1;
